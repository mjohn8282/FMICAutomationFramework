<html>
<head>
<title>argparsing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #c678dd;}
.s1 { color: #abb2bf;}
.s2 { color: #98c379;}
.s3 { color: #5c6370;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
argparsing.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">argparse</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">gettext </span><span class="s0">import </span><span class="s1">gettext</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Mapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">py</span>

<span class="s0">import </span><span class="s1">_pytest._io</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">final</span>
<span class="s0">from </span><span class="s1">_pytest.config.exceptions </span><span class="s0">import </span><span class="s1">UsageError</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NoReturn</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span>

<span class="s1">FILE_OR_DIR = </span><span class="s2">&quot;file_or_dir&quot;</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">Parser:</span>
    <span class="s3">&quot;&quot;&quot;Parser for command line arguments and ini-file values. 
 
    :ivar extra_info: Dict of generic param -&gt; value to display in case 
        there's an error processing the command line arguments. 
    &quot;&quot;&quot;</span>

    <span class="s1">prog: Optional[str] = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">usage: Optional[str] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">processopt: Optional[Callable[[</span><span class="s2">&quot;Argument&quot;</span><span class="s1">], </span><span class="s0">None</span><span class="s1">]] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._anonymous = OptionGroup(</span><span class="s2">&quot;custom options&quot;</span><span class="s1">, parser=self)</span>
        <span class="s1">self._groups: List[OptionGroup] = []</span>
        <span class="s1">self._processopt = processopt</span>
        <span class="s1">self._usage = usage</span>
        <span class="s1">self._inidict: Dict[str, Tuple[str, Optional[str], Any]] = {}</span>
        <span class="s1">self._ininames: List[str] = []</span>
        <span class="s1">self.extra_info: Dict[str, Any] = {}</span>

    <span class="s0">def </span><span class="s1">processoption(self, option: </span><span class="s2">&quot;Argument&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self._processopt:</span>
            <span class="s0">if </span><span class="s1">option.dest:</span>
                <span class="s1">self._processopt(option)</span>

    <span class="s0">def </span><span class="s1">getgroup(</span>
        <span class="s1">self, name: str, description: str = </span><span class="s2">&quot;&quot;</span><span class="s1">, after: Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;OptionGroup&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Get (or create) a named option Group. 
 
        :name: Name of the option group. 
        :description: Long description for --help output. 
        :after: Name of another group, used for ordering --help output. 
 
        The returned group object has an ``addoption`` method with the same 
        signature as :py:func:`parser.addoption 
        &lt;_pytest.config.argparsing.Parser.addoption&gt;` but will be shown in the 
        respective group in the output of ``pytest. --help``. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">group </span><span class="s0">in </span><span class="s1">self._groups:</span>
            <span class="s0">if </span><span class="s1">group.name == name:</span>
                <span class="s0">return </span><span class="s1">group</span>
        <span class="s1">group = OptionGroup(name, description, parser=self)</span>
        <span class="s1">i = </span><span class="s4">0</span>
        <span class="s0">for </span><span class="s1">i, grp </span><span class="s0">in </span><span class="s1">enumerate(self._groups):</span>
            <span class="s0">if </span><span class="s1">grp.name == after:</span>
                <span class="s0">break</span>
        <span class="s1">self._groups.insert(i + </span><span class="s4">1</span><span class="s1">, group)</span>
        <span class="s0">return </span><span class="s1">group</span>

    <span class="s0">def </span><span class="s1">addoption(self, *opts: str, **attrs: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register a command line option. 
 
        :opts: Option names, can be short or long options. 
        :attrs: Same attributes which the ``add_argument()`` function of the 
           `argparse library &lt;https://docs.python.org/library/argparse.html&gt;`_ 
           accepts. 
 
        After command line parsing, options are available on the pytest config 
        object via ``config.option.NAME`` where ``NAME`` is usually set 
        by passing a ``dest`` attribute, for example 
        ``addoption(&quot;--long&quot;, dest=&quot;NAME&quot;, ...)``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._anonymous.addoption(*opts, **attrs)</span>

    <span class="s0">def </span><span class="s1">parse(</span>
        <span class="s1">self,</span>
        <span class="s1">args: Sequence[Union[str, py.path.local]],</span>
        <span class="s1">namespace: Optional[argparse.Namespace] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; argparse.Namespace:</span>
        <span class="s0">from </span><span class="s1">_pytest._argcomplete </span><span class="s0">import </span><span class="s1">try_argcomplete</span>

        <span class="s1">self.optparser = self._getparser()</span>
        <span class="s1">try_argcomplete(self.optparser)</span>
        <span class="s1">strargs = [str(x) </span><span class="s0">if </span><span class="s1">isinstance(x, py.path.local) </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args]</span>
        <span class="s0">return </span><span class="s1">self.optparser.parse_args(strargs, namespace=namespace)</span>

    <span class="s0">def </span><span class="s1">_getparser(self) -&gt; </span><span class="s2">&quot;MyOptionParser&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">_pytest._argcomplete </span><span class="s0">import </span><span class="s1">filescompleter</span>

        <span class="s1">optparser = MyOptionParser(self, self.extra_info, prog=self.prog)</span>
        <span class="s1">groups = self._groups + [self._anonymous]</span>
        <span class="s0">for </span><span class="s1">group </span><span class="s0">in </span><span class="s1">groups:</span>
            <span class="s0">if </span><span class="s1">group.options:</span>
                <span class="s1">desc = group.description </span><span class="s0">or </span><span class="s1">group.name</span>
                <span class="s1">arggroup = optparser.add_argument_group(desc)</span>
                <span class="s0">for </span><span class="s1">option </span><span class="s0">in </span><span class="s1">group.options:</span>
                    <span class="s1">n = option.names()</span>
                    <span class="s1">a = option.attrs()</span>
                    <span class="s1">arggroup.add_argument(*n, **a)</span>
        <span class="s1">file_or_dir_arg = optparser.add_argument(FILE_OR_DIR, nargs=</span><span class="s2">&quot;*&quot;</span><span class="s1">)</span>
        <span class="s3"># bash like autocompletion for dirs (appending '/')</span>
        <span class="s3"># Type ignored because typeshed doesn't know about argcomplete.</span>
        <span class="s1">file_or_dir_arg.completer = filescompleter  </span><span class="s3"># type: ignore</span>
        <span class="s0">return </span><span class="s1">optparser</span>

    <span class="s0">def </span><span class="s1">parse_setoption(</span>
        <span class="s1">self,</span>
        <span class="s1">args: Sequence[Union[str, py.path.local]],</span>
        <span class="s1">option: argparse.Namespace,</span>
        <span class="s1">namespace: Optional[argparse.Namespace] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; List[str]:</span>
        <span class="s1">parsedoption = self.parse(args, namespace=namespace)</span>
        <span class="s0">for </span><span class="s1">name, value </span><span class="s0">in </span><span class="s1">parsedoption.__dict__.items():</span>
            <span class="s1">setattr(option, name, value)</span>
        <span class="s0">return </span><span class="s1">cast(List[str], getattr(parsedoption, FILE_OR_DIR))</span>

    <span class="s0">def </span><span class="s1">parse_known_args(</span>
        <span class="s1">self,</span>
        <span class="s1">args: Sequence[Union[str, py.path.local]],</span>
        <span class="s1">namespace: Optional[argparse.Namespace] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; argparse.Namespace:</span>
        <span class="s3">&quot;&quot;&quot;Parse and return a namespace object with known arguments at this point.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.parse_known_and_unknown_args(args, namespace=namespace)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">parse_known_and_unknown_args(</span>
        <span class="s1">self,</span>
        <span class="s1">args: Sequence[Union[str, py.path.local]],</span>
        <span class="s1">namespace: Optional[argparse.Namespace] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; Tuple[argparse.Namespace, List[str]]:</span>
        <span class="s3">&quot;&quot;&quot;Parse and return a namespace object with known arguments, and 
        the remaining arguments unknown at this point.&quot;&quot;&quot;</span>
        <span class="s1">optparser = self._getparser()</span>
        <span class="s1">strargs = [str(x) </span><span class="s0">if </span><span class="s1">isinstance(x, py.path.local) </span><span class="s0">else </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">args]</span>
        <span class="s0">return </span><span class="s1">optparser.parse_known_args(strargs, namespace=namespace)</span>

    <span class="s0">def </span><span class="s1">addini(</span>
        <span class="s1">self,</span>
        <span class="s1">name: str,</span>
        <span class="s1">help: str,</span>
        <span class="s1">type: Optional[</span>
            <span class="s2">&quot;Literal['string', 'pathlist', 'args', 'linelist', 'bool']&quot;</span>
        <span class="s1">] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Register an ini-file option. 
 
        :name: Name of the ini-variable. 
        :type: Type of the variable, can be ``string``, ``pathlist``, ``args``, 
               ``linelist`` or ``bool``.  Defaults to ``string`` if ``None`` or 
               not passed. 
        :default: Default value if no ini-file option exists but is queried. 
 
        The value of ini-variables can be retrieved via a call to 
        :py:func:`config.getini(name) &lt;_pytest.config.Config.getini&gt;`. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">type </span><span class="s0">in </span><span class="s1">(</span><span class="s0">None</span><span class="s1">, </span><span class="s2">&quot;string&quot;</span><span class="s1">, </span><span class="s2">&quot;pathlist&quot;</span><span class="s1">, </span><span class="s2">&quot;args&quot;</span><span class="s1">, </span><span class="s2">&quot;linelist&quot;</span><span class="s1">, </span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s1">self._inidict[name] = (help, type, default)</span>
        <span class="s1">self._ininames.append(name)</span>


<span class="s0">class </span><span class="s1">ArgumentError(Exception):</span>
    <span class="s3">&quot;&quot;&quot;Raised if an Argument instance is created with invalid or 
    inconsistent arguments.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self, msg: str, option: Union[</span><span class="s2">&quot;Argument&quot;</span><span class="s1">, str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.msg = msg</span>
        <span class="s1">self.option_id = str(option)</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.option_id:</span>
            <span class="s0">return </span><span class="s2">f&quot;option </span><span class="s5">{</span><span class="s1">self.option_id</span><span class="s5">}</span><span class="s2">: </span><span class="s5">{</span><span class="s1">self.msg</span><span class="s5">}</span><span class="s2">&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.msg</span>


<span class="s0">class </span><span class="s1">Argument:</span>
    <span class="s3">&quot;&quot;&quot;Class that mimics the necessary behaviour of optparse.Option. 
 
    It's currently a least effort implementation and ignoring choices 
    and integer prefixes. 
 
    https://docs.python.org/3/library/optparse.html#optparse-standard-option-types 
    &quot;&quot;&quot;</span>

    <span class="s1">_typ_map = {</span><span class="s2">&quot;int&quot;</span><span class="s1">: int, </span><span class="s2">&quot;string&quot;</span><span class="s1">: str, </span><span class="s2">&quot;float&quot;</span><span class="s1">: float, </span><span class="s2">&quot;complex&quot;</span><span class="s1">: complex}</span>

    <span class="s0">def </span><span class="s1">__init__(self, *names: str, **attrs: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Store parms in private vars for use in add_argument.&quot;&quot;&quot;</span>
        <span class="s1">self._attrs = attrs</span>
        <span class="s1">self._short_opts: List[str] = []</span>
        <span class="s1">self._long_opts: List[str] = []</span>
        <span class="s0">if </span><span class="s2">&quot;%default&quot; </span><span class="s0">in </span><span class="s1">(attrs.get(</span><span class="s2">&quot;help&quot;</span><span class="s1">) </span><span class="s0">or </span><span class="s2">&quot;&quot;</span><span class="s1">):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s2">'pytest now uses argparse. &quot;%default&quot; should be'</span>
                <span class="s2">' changed to &quot;%(default)s&quot; '</span><span class="s1">,</span>
                <span class="s1">DeprecationWarning,</span>
                <span class="s1">stacklevel=</span><span class="s4">3</span><span class="s1">,</span>
            <span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">typ = attrs[</span><span class="s2">&quot;type&quot;</span><span class="s1">]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># This might raise a keyerror as well, don't want to catch that.</span>
            <span class="s0">if </span><span class="s1">isinstance(typ, str):</span>
                <span class="s0">if </span><span class="s1">typ == </span><span class="s2">&quot;choice&quot;</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s2">&quot;`type` argument to addoption() is the string %r.&quot;</span>
                        <span class="s2">&quot; For choices this is optional and can be omitted, &quot;</span>
                        <span class="s2">&quot; but when supplied should be a type (for example `str` or `int`).&quot;</span>
                        <span class="s2">&quot; (options: %s)&quot; </span><span class="s1">% (typ, names),</span>
                        <span class="s1">DeprecationWarning,</span>
                        <span class="s1">stacklevel=</span><span class="s4">4</span><span class="s1">,</span>
                    <span class="s1">)</span>
                    <span class="s3"># argparse expects a type here take it from</span>
                    <span class="s3"># the type of the first element</span>
                    <span class="s1">attrs[</span><span class="s2">&quot;type&quot;</span><span class="s1">] = type(attrs[</span><span class="s2">&quot;choices&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s2">&quot;`type` argument to addoption() is the string %r, &quot;</span>
                        <span class="s2">&quot; but when supplied should be a type (for example `str` or `int`).&quot;</span>
                        <span class="s2">&quot; (options: %s)&quot; </span><span class="s1">% (typ, names),</span>
                        <span class="s1">DeprecationWarning,</span>
                        <span class="s1">stacklevel=</span><span class="s4">4</span><span class="s1">,</span>
                    <span class="s1">)</span>
                    <span class="s1">attrs[</span><span class="s2">&quot;type&quot;</span><span class="s1">] = Argument._typ_map[typ]</span>
                <span class="s3"># Used in test_parseopt -&gt; test_parse_defaultgetter.</span>
                <span class="s1">self.type = attrs[</span><span class="s2">&quot;type&quot;</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.type = typ</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s3"># Attribute existence is tested in Config._processopt.</span>
            <span class="s1">self.default = attrs[</span><span class="s2">&quot;default&quot;</span><span class="s1">]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">pass</span>
        <span class="s1">self._set_opt_strings(names)</span>
        <span class="s1">dest: Optional[str] = attrs.get(</span><span class="s2">&quot;dest&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">dest:</span>
            <span class="s1">self.dest = dest</span>
        <span class="s0">elif </span><span class="s1">self._long_opts:</span>
            <span class="s1">self.dest = self._long_opts[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">:].replace(</span><span class="s2">&quot;-&quot;</span><span class="s1">, </span><span class="s2">&quot;_&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.dest = self._short_opts[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s1">self.dest = </span><span class="s2">&quot;???&quot;  </span><span class="s3"># Needed for the error repr.</span>
                <span class="s0">raise </span><span class="s1">ArgumentError(</span><span class="s2">&quot;need a long or short option&quot;</span><span class="s1">, self) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">def </span><span class="s1">names(self) -&gt; List[str]:</span>
        <span class="s0">return </span><span class="s1">self._short_opts + self._long_opts</span>

    <span class="s0">def </span><span class="s1">attrs(self) -&gt; Mapping[str, Any]:</span>
        <span class="s3"># Update any attributes set by processopt.</span>
        <span class="s1">attrs = </span><span class="s2">&quot;default dest help&quot;</span><span class="s1">.split()</span>
        <span class="s1">attrs.append(self.dest)</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">attrs:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self._attrs[attr] = getattr(self, attr)</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s0">pass</span>
        <span class="s0">if </span><span class="s1">self._attrs.get(</span><span class="s2">&quot;help&quot;</span><span class="s1">):</span>
            <span class="s1">a = self._attrs[</span><span class="s2">&quot;help&quot;</span><span class="s1">]</span>
            <span class="s1">a = a.replace(</span><span class="s2">&quot;%default&quot;</span><span class="s1">, </span><span class="s2">&quot;%(default)s&quot;</span><span class="s1">)</span>
            <span class="s3"># a = a.replace('%prog', '%(prog)s')</span>
            <span class="s1">self._attrs[</span><span class="s2">&quot;help&quot;</span><span class="s1">] = a</span>
        <span class="s0">return </span><span class="s1">self._attrs</span>

    <span class="s0">def </span><span class="s1">_set_opt_strings(self, opts: Sequence[str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Directly from optparse. 
 
        Might not be necessary as this is passed to argparse later on. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">opt </span><span class="s0">in </span><span class="s1">opts:</span>
            <span class="s0">if </span><span class="s1">len(opt) &lt; </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ArgumentError(</span>
                    <span class="s2">&quot;invalid option string %r: &quot;</span>
                    <span class="s2">&quot;must be at least two characters long&quot; </span><span class="s1">% opt,</span>
                    <span class="s1">self,</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">len(opt) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">(opt[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;-&quot; </span><span class="s0">and </span><span class="s1">opt[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">&quot;-&quot;</span><span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">ArgumentError(</span>
                        <span class="s2">&quot;invalid short option string %r: &quot;</span>
                        <span class="s2">&quot;must be of the form -x, (x any non-dash char)&quot; </span><span class="s1">% opt,</span>
                        <span class="s1">self,</span>
                    <span class="s1">)</span>
                <span class="s1">self._short_opts.append(opt)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if not </span><span class="s1">(opt[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">2</span><span class="s1">] == </span><span class="s2">&quot;--&quot; </span><span class="s0">and </span><span class="s1">opt[</span><span class="s4">2</span><span class="s1">] != </span><span class="s2">&quot;-&quot;</span><span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">ArgumentError(</span>
                        <span class="s2">&quot;invalid long option string %r: &quot;</span>
                        <span class="s2">&quot;must start with --, followed by non-dash&quot; </span><span class="s1">% opt,</span>
                        <span class="s1">self,</span>
                    <span class="s1">)</span>
                <span class="s1">self._long_opts.append(opt)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">args: List[str] = []</span>
        <span class="s0">if </span><span class="s1">self._short_opts:</span>
            <span class="s1">args += [</span><span class="s2">&quot;_short_opts: &quot; </span><span class="s1">+ repr(self._short_opts)]</span>
        <span class="s0">if </span><span class="s1">self._long_opts:</span>
            <span class="s1">args += [</span><span class="s2">&quot;_long_opts: &quot; </span><span class="s1">+ repr(self._long_opts)]</span>
        <span class="s1">args += [</span><span class="s2">&quot;dest: &quot; </span><span class="s1">+ repr(self.dest)]</span>
        <span class="s0">if </span><span class="s1">hasattr(self, </span><span class="s2">&quot;type&quot;</span><span class="s1">):</span>
            <span class="s1">args += [</span><span class="s2">&quot;type: &quot; </span><span class="s1">+ repr(self.type)]</span>
        <span class="s0">if </span><span class="s1">hasattr(self, </span><span class="s2">&quot;default&quot;</span><span class="s1">):</span>
            <span class="s1">args += [</span><span class="s2">&quot;default: &quot; </span><span class="s1">+ repr(self.default)]</span>
        <span class="s0">return </span><span class="s2">&quot;Argument({})&quot;</span><span class="s1">.format(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(args))</span>


<span class="s0">class </span><span class="s1">OptionGroup:</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self, name: str, description: str = </span><span class="s2">&quot;&quot;</span><span class="s1">, parser: Optional[Parser] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.description = description</span>
        <span class="s1">self.options: List[Argument] = []</span>
        <span class="s1">self.parser = parser</span>

    <span class="s0">def </span><span class="s1">addoption(self, *optnames: str, **attrs: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Add an option to this group. 
 
        If a shortened version of a long option is specified, it will 
        be suppressed in the help. addoption('--twowords', '--two-words') 
        results in help showing '--two-words' only, but --twowords gets 
        accepted **and** the automatic destination is in args.twowords. 
        &quot;&quot;&quot;</span>
        <span class="s1">conflict = set(optnames).intersection(</span>
            <span class="s1">name </span><span class="s0">for </span><span class="s1">opt </span><span class="s0">in </span><span class="s1">self.options </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">opt.names()</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">conflict:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;option names %s already added&quot; </span><span class="s1">% conflict)</span>
        <span class="s1">option = Argument(*optnames, **attrs)</span>
        <span class="s1">self._addoption_instance(option, shortupper=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_addoption(self, *optnames: str, **attrs: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">option = Argument(*optnames, **attrs)</span>
        <span class="s1">self._addoption_instance(option, shortupper=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_addoption_instance(self, option: </span><span class="s2">&quot;Argument&quot;</span><span class="s1">, shortupper: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">shortupper:</span>
            <span class="s0">for </span><span class="s1">opt </span><span class="s0">in </span><span class="s1">option._short_opts:</span>
                <span class="s0">if </span><span class="s1">opt[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;-&quot; </span><span class="s0">and </span><span class="s1">opt[</span><span class="s4">1</span><span class="s1">].islower():</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;lowercase shortoptions reserved&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.parser:</span>
            <span class="s1">self.parser.processoption(option)</span>
        <span class="s1">self.options.append(option)</span>


<span class="s0">class </span><span class="s1">MyOptionParser(argparse.ArgumentParser):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">parser: Parser,</span>
        <span class="s1">extra_info: Optional[Dict[str, Any]] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">prog: Optional[str] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._parser = parser</span>
        <span class="s1">argparse.ArgumentParser.__init__(</span>
            <span class="s1">self,</span>
            <span class="s1">prog=prog,</span>
            <span class="s1">usage=parser._usage,</span>
            <span class="s1">add_help=</span><span class="s0">False</span><span class="s1">,</span>
            <span class="s1">formatter_class=DropShorterLongHelpFormatter,</span>
            <span class="s1">allow_abbrev=</span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">)</span>
        <span class="s3"># extra_info is a dict of (param -&gt; value) to display if there's</span>
        <span class="s3"># an usage error to provide more contextual information to the user.</span>
        <span class="s1">self.extra_info = extra_info </span><span class="s0">if </span><span class="s1">extra_info </span><span class="s0">else </span><span class="s1">{}</span>

    <span class="s0">def </span><span class="s1">error(self, message: str) -&gt; </span><span class="s2">&quot;NoReturn&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Transform argparse error message into UsageError.&quot;&quot;&quot;</span>
        <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">self.prog</span><span class="s5">}</span><span class="s2">: error: </span><span class="s5">{</span><span class="s1">message</span><span class="s5">}</span><span class="s2">&quot;</span>

        <span class="s0">if </span><span class="s1">hasattr(self._parser, </span><span class="s2">&quot;_config_source_hint&quot;</span><span class="s1">):</span>
            <span class="s3"># Type ignored because the attribute is set dynamically.</span>
            <span class="s1">msg = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">msg</span><span class="s5">} </span><span class="s2">(</span><span class="s5">{</span><span class="s1">self._parser._config_source_hint</span><span class="s5">}</span><span class="s2">)&quot;  </span><span class="s3"># type: ignore</span>

        <span class="s0">raise </span><span class="s1">UsageError(self.format_usage() + msg)</span>

    <span class="s3"># Type ignored because typeshed has a very complex type in the superclass.</span>
    <span class="s0">def </span><span class="s1">parse_args(  </span><span class="s3"># type: ignore</span>
        <span class="s1">self,</span>
        <span class="s1">args: Optional[Sequence[str]] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">namespace: Optional[argparse.Namespace] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; argparse.Namespace:</span>
        <span class="s3">&quot;&quot;&quot;Allow splitting of positional arguments.&quot;&quot;&quot;</span>
        <span class="s1">parsed, unrecognized = self.parse_known_args(args, namespace)</span>
        <span class="s0">if </span><span class="s1">unrecognized:</span>
            <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">unrecognized:</span>
                <span class="s0">if </span><span class="s1">arg </span><span class="s0">and </span><span class="s1">arg[</span><span class="s4">0</span><span class="s1">] == </span><span class="s2">&quot;-&quot;</span><span class="s1">:</span>
                    <span class="s1">lines = [</span><span class="s2">&quot;unrecognized arguments: %s&quot; </span><span class="s1">% (</span><span class="s2">&quot; &quot;</span><span class="s1">.join(unrecognized))]</span>
                    <span class="s0">for </span><span class="s1">k, v </span><span class="s0">in </span><span class="s1">sorted(self.extra_info.items()):</span>
                        <span class="s1">lines.append(</span><span class="s2">f&quot;  </span><span class="s5">{</span><span class="s1">k</span><span class="s5">}</span><span class="s2">: </span><span class="s5">{</span><span class="s1">v</span><span class="s5">}</span><span class="s2">&quot;</span><span class="s1">)</span>
                    <span class="s1">self.error(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">.join(lines))</span>
            <span class="s1">getattr(parsed, FILE_OR_DIR).extend(unrecognized)</span>
        <span class="s0">return </span><span class="s1">parsed</span>

    <span class="s0">if </span><span class="s1">sys.version_info[:</span><span class="s4">2</span><span class="s1">] &lt; (</span><span class="s4">3</span><span class="s1">, </span><span class="s4">9</span><span class="s1">):  </span><span class="s3"># pragma: no cover</span>
        <span class="s3"># Backport of https://github.com/python/cpython/pull/14316 so we can</span>
        <span class="s3"># disable long --argument abbreviations without breaking short flags.</span>
        <span class="s0">def </span><span class="s1">_parse_optional(</span>
            <span class="s1">self, arg_string: str</span>
        <span class="s1">) -&gt; Optional[Tuple[Optional[argparse.Action], str, Optional[str]]]:</span>
            <span class="s0">if not </span><span class="s1">arg_string:</span>
                <span class="s0">return None</span>
            <span class="s0">if not </span><span class="s1">arg_string[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">self.prefix_chars:</span>
                <span class="s0">return None</span>
            <span class="s0">if </span><span class="s1">arg_string </span><span class="s0">in </span><span class="s1">self._option_string_actions:</span>
                <span class="s1">action = self._option_string_actions[arg_string]</span>
                <span class="s0">return </span><span class="s1">action, arg_string, </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">len(arg_string) == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">return None</span>
            <span class="s0">if </span><span class="s2">&quot;=&quot; </span><span class="s0">in </span><span class="s1">arg_string:</span>
                <span class="s1">option_string, explicit_arg = arg_string.split(</span><span class="s2">&quot;=&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">option_string </span><span class="s0">in </span><span class="s1">self._option_string_actions:</span>
                    <span class="s1">action = self._option_string_actions[option_string]</span>
                    <span class="s0">return </span><span class="s1">action, option_string, explicit_arg</span>
            <span class="s0">if </span><span class="s1">self.allow_abbrev </span><span class="s0">or not </span><span class="s1">arg_string.startswith(</span><span class="s2">&quot;--&quot;</span><span class="s1">):</span>
                <span class="s1">option_tuples = self._get_option_tuples(arg_string)</span>
                <span class="s0">if </span><span class="s1">len(option_tuples) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">msg = gettext(</span>
                        <span class="s2">&quot;ambiguous option: %(option)s could match %(matches)s&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">options = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(option </span><span class="s0">for </span><span class="s1">_, option, _ </span><span class="s0">in </span><span class="s1">option_tuples)</span>
                    <span class="s1">self.error(msg % {</span><span class="s2">&quot;option&quot;</span><span class="s1">: arg_string, </span><span class="s2">&quot;matches&quot;</span><span class="s1">: options})</span>
                <span class="s0">elif </span><span class="s1">len(option_tuples) == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">(option_tuple,) = option_tuples</span>
                    <span class="s0">return </span><span class="s1">option_tuple</span>
            <span class="s0">if </span><span class="s1">self._negative_number_matcher.match(arg_string):</span>
                <span class="s0">if not </span><span class="s1">self._has_negative_number_optionals:</span>
                    <span class="s0">return None</span>
            <span class="s0">if </span><span class="s2">&quot; &quot; </span><span class="s0">in </span><span class="s1">arg_string:</span>
                <span class="s0">return None</span>
            <span class="s0">return None</span><span class="s1">, arg_string, </span><span class="s0">None</span>


<span class="s0">class </span><span class="s1">DropShorterLongHelpFormatter(argparse.HelpFormatter):</span>
    <span class="s3">&quot;&quot;&quot;Shorten help for long options that differ only in extra hyphens. 
 
    - Collapse **long** options that are the same except for extra hyphens. 
    - Shortcut if there are only two options and one of them is a short one. 
    - Cache result on the action object as this is called at least 2 times. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self, *args: Any, **kwargs: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># Use more accurate terminal width.</span>
        <span class="s0">if </span><span class="s2">&quot;width&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = _pytest._io.get_terminal_width()</span>
        <span class="s1">super().__init__(*args, **kwargs)</span>

    <span class="s0">def </span><span class="s1">_format_action_invocation(self, action: argparse.Action) -&gt; str:</span>
        <span class="s1">orgstr = argparse.HelpFormatter._format_action_invocation(self, action)</span>
        <span class="s0">if </span><span class="s1">orgstr </span><span class="s0">and </span><span class="s1">orgstr[</span><span class="s4">0</span><span class="s1">] != </span><span class="s2">&quot;-&quot;</span><span class="s1">:  </span><span class="s3"># only optional arguments</span>
            <span class="s0">return </span><span class="s1">orgstr</span>
        <span class="s1">res: Optional[str] = getattr(action, </span><span class="s2">&quot;_formatted_action_invocation&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">res:</span>
            <span class="s0">return </span><span class="s1">res</span>
        <span class="s1">options = orgstr.split(</span><span class="s2">&quot;, &quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">len(options) == </span><span class="s4">2 </span><span class="s0">and </span><span class="s1">(len(options[</span><span class="s4">0</span><span class="s1">]) == </span><span class="s4">2 </span><span class="s0">or </span><span class="s1">len(options[</span><span class="s4">1</span><span class="s1">]) == </span><span class="s4">2</span><span class="s1">):</span>
            <span class="s3"># a shortcut for '-h, --help' or '--abc', '-a'</span>
            <span class="s1">action._formatted_action_invocation = orgstr  </span><span class="s3"># type: ignore</span>
            <span class="s0">return </span><span class="s1">orgstr</span>
        <span class="s1">return_list = []</span>
        <span class="s1">short_long: Dict[str, str] = {}</span>
        <span class="s0">for </span><span class="s1">option </span><span class="s0">in </span><span class="s1">options:</span>
            <span class="s0">if </span><span class="s1">len(option) == </span><span class="s4">2 </span><span class="s0">or </span><span class="s1">option[</span><span class="s4">2</span><span class="s1">] == </span><span class="s2">&quot; &quot;</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">option.startswith(</span><span class="s2">&quot;--&quot;</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ArgumentError(</span>
                    <span class="s2">'long optional argument without &quot;--&quot;: [%s]' </span><span class="s1">% (option), option</span>
                <span class="s1">)</span>
            <span class="s1">xxoption = option[</span><span class="s4">2</span><span class="s1">:]</span>
            <span class="s1">shortened = xxoption.replace(</span><span class="s2">&quot;-&quot;</span><span class="s1">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">shortened </span><span class="s0">not in </span><span class="s1">short_long </span><span class="s0">or </span><span class="s1">len(short_long[shortened]) &lt; len(</span>
                <span class="s1">xxoption</span>
            <span class="s1">):</span>
                <span class="s1">short_long[shortened] = xxoption</span>
        <span class="s3"># now short_long has been filled out to the longest with dashes</span>
        <span class="s3"># **and** we keep the right option ordering from add_argument</span>
        <span class="s0">for </span><span class="s1">option </span><span class="s0">in </span><span class="s1">options:</span>
            <span class="s0">if </span><span class="s1">len(option) == </span><span class="s4">2 </span><span class="s0">or </span><span class="s1">option[</span><span class="s4">2</span><span class="s1">] == </span><span class="s2">&quot; &quot;</span><span class="s1">:</span>
                <span class="s1">return_list.append(option)</span>
            <span class="s0">if </span><span class="s1">option[</span><span class="s4">2</span><span class="s1">:] == short_long.get(option.replace(</span><span class="s2">&quot;-&quot;</span><span class="s1">, </span><span class="s2">&quot;&quot;</span><span class="s1">)):</span>
                <span class="s1">return_list.append(option.replace(</span><span class="s2">&quot; &quot;</span><span class="s1">, </span><span class="s2">&quot;=&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">formatted_action_invocation = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(return_list)</span>
        <span class="s1">action._formatted_action_invocation = formatted_action_invocation  </span><span class="s3"># type: ignore</span>
        <span class="s0">return </span><span class="s1">formatted_action_invocation</span>

    <span class="s0">def </span><span class="s1">_split_lines(self, text, width):</span>
        <span class="s3">&quot;&quot;&quot;Wrap lines after splitting on original newlines. 
 
        This allows to have explicit line breaks in the help text. 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">textwrap</span>

        <span class="s1">lines = []</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">text.splitlines():</span>
            <span class="s1">lines.extend(textwrap.wrap(line.strip(), width))</span>
        <span class="s0">return </span><span class="s1">lines</span>
</pre>
</body>
</html>