<html>
<head>
<title>code.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #c678dd;}
.s1 { color: #abb2bf;}
.s2 { color: #98c379;}
.s3 { color: #5c6370;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
code.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">traceback</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">CO_VARARGS</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">CO_VARKEYWORDS</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">traceback </span><span class="s0">import </span><span class="s1">format_exception_only</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">CodeType</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">FrameType</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">TracebackType</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Generic</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Mapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Pattern</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Set</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>
<span class="s0">from </span><span class="s1">weakref </span><span class="s0">import </span><span class="s1">ref</span>

<span class="s0">import </span><span class="s1">attr</span>
<span class="s0">import </span><span class="s1">pluggy</span>
<span class="s0">import </span><span class="s1">py</span>

<span class="s0">import </span><span class="s1">_pytest</span>
<span class="s0">from </span><span class="s1">_pytest._code.source </span><span class="s0">import </span><span class="s1">findsource</span>
<span class="s0">from </span><span class="s1">_pytest._code.source </span><span class="s0">import </span><span class="s1">getrawcode</span>
<span class="s0">from </span><span class="s1">_pytest._code.source </span><span class="s0">import </span><span class="s1">getstatementrange_ast</span>
<span class="s0">from </span><span class="s1">_pytest._code.source </span><span class="s0">import </span><span class="s1">Source</span>
<span class="s0">from </span><span class="s1">_pytest._io </span><span class="s0">import </span><span class="s1">TerminalWriter</span>
<span class="s0">from </span><span class="s1">_pytest._io.saferepr </span><span class="s0">import </span><span class="s1">safeformat</span>
<span class="s0">from </span><span class="s1">_pytest._io.saferepr </span><span class="s0">import </span><span class="s1">saferepr</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">final</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">get_real_func</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span>
    <span class="s0">from </span><span class="s1">weakref </span><span class="s0">import </span><span class="s1">ReferenceType</span>

    <span class="s1">_TracebackStyle = Literal[</span><span class="s2">&quot;long&quot;</span><span class="s1">, </span><span class="s2">&quot;short&quot;</span><span class="s1">, </span><span class="s2">&quot;line&quot;</span><span class="s1">, </span><span class="s2">&quot;no&quot;</span><span class="s1">, </span><span class="s2">&quot;native&quot;</span><span class="s1">, </span><span class="s2">&quot;value&quot;</span><span class="s1">, </span><span class="s2">&quot;auto&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">Code:</span>
    <span class="s3">&quot;&quot;&quot;Wrapper around Python code objects.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">&quot;raw&quot;</span><span class="s1">,)</span>

    <span class="s0">def </span><span class="s1">__init__(self, obj: CodeType) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.raw = obj</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_function(cls, obj: object) -&gt; </span><span class="s2">&quot;Code&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">cls(getrawcode(obj))</span>

    <span class="s0">def </span><span class="s1">__eq__(self, other):</span>
        <span class="s0">return </span><span class="s1">self.raw == other.raw</span>

    <span class="s3"># Ignore type because of https://github.com/python/mypy/issues/4266.</span>
    <span class="s1">__hash__ = </span><span class="s0">None  </span><span class="s3"># type: ignore</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">firstlineno(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self.raw.co_firstlineno - </span><span class="s4">1</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.raw.co_name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">path(self) -&gt; Union[py.path.local, str]:</span>
        <span class="s3">&quot;&quot;&quot;Return a path object pointing to source code, or an ``str`` in 
        case of ``OSError`` / non-existing file.&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.raw.co_filename:</span>
            <span class="s0">return </span><span class="s2">&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">p = py.path.local(self.raw.co_filename)</span>
            <span class="s3"># maybe don't try this checking</span>
            <span class="s0">if not </span><span class="s1">p.check():</span>
                <span class="s0">raise </span><span class="s1">OSError(</span><span class="s2">&quot;py.path check failed.&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">p</span>
        <span class="s0">except </span><span class="s1">OSError:</span>
            <span class="s3"># XXX maybe try harder like the weird logic</span>
            <span class="s3"># in the standard lib [linecache.updatecache] does?</span>
            <span class="s0">return </span><span class="s1">self.raw.co_filename</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fullsource(self) -&gt; Optional[</span><span class="s2">&quot;Source&quot;</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot;Return a _pytest._code.Source object for the full source file of the code.&quot;&quot;&quot;</span>
        <span class="s1">full, _ = findsource(self.raw)</span>
        <span class="s0">return </span><span class="s1">full</span>

    <span class="s0">def </span><span class="s1">source(self) -&gt; </span><span class="s2">&quot;Source&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return a _pytest._code.Source object for the code object's source only.&quot;&quot;&quot;</span>
        <span class="s3"># return source only for that part of code</span>
        <span class="s0">return </span><span class="s1">Source(self.raw)</span>

    <span class="s0">def </span><span class="s1">getargs(self, var: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Tuple[str, ...]:</span>
        <span class="s3">&quot;&quot;&quot;Return a tuple with the argument names for the code object. 
 
        If 'var' is set True also return the names of the variable and 
        keyword arguments when present. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Handy shortcut for getting args.</span>
        <span class="s1">raw = self.raw</span>
        <span class="s1">argcount = raw.co_argcount</span>
        <span class="s0">if </span><span class="s1">var:</span>
            <span class="s1">argcount += raw.co_flags &amp; CO_VARARGS</span>
            <span class="s1">argcount += raw.co_flags &amp; CO_VARKEYWORDS</span>
        <span class="s0">return </span><span class="s1">raw.co_varnames[:argcount]</span>


<span class="s0">class </span><span class="s1">Frame:</span>
    <span class="s3">&quot;&quot;&quot;Wrapper around a Python frame holding f_locals and f_globals 
    in which expressions can be evaluated.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">&quot;raw&quot;</span><span class="s1">,)</span>

    <span class="s0">def </span><span class="s1">__init__(self, frame: FrameType) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.raw = frame</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">lineno(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self.raw.f_lineno - </span><span class="s4">1</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">f_globals(self) -&gt; Dict[str, Any]:</span>
        <span class="s0">return </span><span class="s1">self.raw.f_globals</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">f_locals(self) -&gt; Dict[str, Any]:</span>
        <span class="s0">return </span><span class="s1">self.raw.f_locals</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">code(self) -&gt; Code:</span>
        <span class="s0">return </span><span class="s1">Code(self.raw.f_code)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">statement(self) -&gt; </span><span class="s2">&quot;Source&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Statement this frame is at.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.code.fullsource </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Source(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.code.fullsource.getstatement(self.lineno)</span>

    <span class="s0">def </span><span class="s1">eval(self, code, **vars):</span>
        <span class="s3">&quot;&quot;&quot;Evaluate 'code' in the frame. 
 
        'vars' are optional additional local variables. 
 
        Returns the result of the evaluation. 
        &quot;&quot;&quot;</span>
        <span class="s1">f_locals = self.f_locals.copy()</span>
        <span class="s1">f_locals.update(vars)</span>
        <span class="s0">return </span><span class="s1">eval(code, self.f_globals, f_locals)</span>

    <span class="s0">def </span><span class="s1">repr(self, object: object) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Return a 'safe' (non-recursive, one-line) string repr for 'object'.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">saferepr(object)</span>

    <span class="s0">def </span><span class="s1">getargs(self, var: bool = </span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Return a list of tuples (name, value) for all arguments. 
 
        If 'var' is set True, also include the variable and keyword arguments 
        when present. 
        &quot;&quot;&quot;</span>
        <span class="s1">retval = []</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">self.code.getargs(var):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">retval.append((arg, self.f_locals[arg]))</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">pass  </span><span class="s3"># this can occur when using Psyco</span>
        <span class="s0">return </span><span class="s1">retval</span>


<span class="s0">class </span><span class="s1">TracebackEntry:</span>
    <span class="s3">&quot;&quot;&quot;A single entry in a Traceback.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s2">&quot;_rawentry&quot;</span><span class="s1">, </span><span class="s2">&quot;_excinfo&quot;</span><span class="s1">, </span><span class="s2">&quot;_repr_style&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">rawentry: TracebackType,</span>
        <span class="s1">excinfo: Optional[</span><span class="s2">&quot;ReferenceType[ExceptionInfo[BaseException]]&quot;</span><span class="s1">] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._rawentry = rawentry</span>
        <span class="s1">self._excinfo = excinfo</span>
        <span class="s1">self._repr_style: Optional[</span><span class="s2">'Literal[&quot;short&quot;, &quot;long&quot;]'</span><span class="s1">] = </span><span class="s0">None</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">lineno(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._rawentry.tb_lineno - </span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">set_repr_style(self, mode: </span><span class="s2">&quot;Literal['short', 'long']&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;short&quot;</span><span class="s1">, </span><span class="s2">&quot;long&quot;</span><span class="s1">)</span>
        <span class="s1">self._repr_style = mode</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">frame(self) -&gt; Frame:</span>
        <span class="s0">return </span><span class="s1">Frame(self._rawentry.tb_frame)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">relline(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self.lineno - self.frame.code.firstlineno</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;TracebackEntry %s:%d&gt;&quot; </span><span class="s1">% (self.frame.code.path, self.lineno + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">statement(self) -&gt; </span><span class="s2">&quot;Source&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;_pytest._code.Source object for the current statement.&quot;&quot;&quot;</span>
        <span class="s1">source = self.frame.code.fullsource</span>
        <span class="s0">assert </span><span class="s1">source </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">source.getstatement(self.lineno)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">path(self) -&gt; Union[py.path.local, str]:</span>
        <span class="s3">&quot;&quot;&quot;Path to the source code.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.frame.code.path</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">locals(self) -&gt; Dict[str, Any]:</span>
        <span class="s3">&quot;&quot;&quot;Locals of underlying frame.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.frame.f_locals</span>

    <span class="s0">def </span><span class="s1">getfirstlinesource(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self.frame.code.firstlineno</span>

    <span class="s0">def </span><span class="s1">getsource(self, astcache=</span><span class="s0">None</span><span class="s1">) -&gt; Optional[</span><span class="s2">&quot;Source&quot;</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot;Return failing source code.&quot;&quot;&quot;</span>
        <span class="s3"># we use the passed in astcache to not reparse asttrees</span>
        <span class="s3"># within exception info printing</span>
        <span class="s1">source = self.frame.code.fullsource</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return None</span>
        <span class="s1">key = astnode = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">astcache </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">key = self.frame.code.path</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">astnode = astcache.get(key, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">start = self.getfirstlinesource()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">astnode, _, end = getstatementrange_ast(</span>
                <span class="s1">self.lineno, source, astnode=astnode</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">SyntaxError:</span>
            <span class="s1">end = self.lineno + </span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">astcache[key] = astnode</span>
        <span class="s0">return </span><span class="s1">source[start:end]</span>

    <span class="s1">source = property(getsource)</span>

    <span class="s0">def </span><span class="s1">ishidden(self) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Return True if the current frame has a var __tracebackhide__ 
        resolving to True. 
 
        If __tracebackhide__ is a callable, it gets called with the 
        ExceptionInfo instance and can decide whether to hide the traceback. 
 
        Mostly for internal use. 
        &quot;&quot;&quot;</span>
        <span class="s1">tbh: Union[bool, Callable[[Optional[ExceptionInfo[BaseException]]], bool]] = (</span>
            <span class="s0">False</span>
        <span class="s1">)</span>
        <span class="s0">for </span><span class="s1">maybe_ns_dct </span><span class="s0">in </span><span class="s1">(self.frame.f_locals, self.frame.f_globals):</span>
            <span class="s3"># in normal cases, f_locals and f_globals are dictionaries</span>
            <span class="s3"># however via `exec(...)` / `eval(...)` they can be other types</span>
            <span class="s3"># (even incorrect types!).</span>
            <span class="s3"># as such, we suppress all exceptions while accessing __tracebackhide__</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">tbh = maybe_ns_dct[</span><span class="s2">&quot;__tracebackhide__&quot;</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">tbh </span><span class="s0">and </span><span class="s1">callable(tbh):</span>
            <span class="s0">return </span><span class="s1">tbh(</span><span class="s0">None if </span><span class="s1">self._excinfo </span><span class="s0">is None else </span><span class="s1">self._excinfo())</span>
        <span class="s0">return </span><span class="s1">tbh</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s1">name = self.frame.code.name</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">line = str(self.statement).lstrip()</span>
        <span class="s0">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">BaseException:</span>
            <span class="s1">line = </span><span class="s2">&quot;???&quot;</span>
        <span class="s3"># This output does not quite match Python's repr for traceback entries,</span>
        <span class="s3"># but changing it to do so would break certain plugins.  See</span>
        <span class="s3"># https://github.com/pytest-dev/pytest/pull/7535/ for details.</span>
        <span class="s0">return </span><span class="s2">&quot;  File %r:%d in %s</span><span class="s5">\n  </span><span class="s2">%s</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">% (</span>
            <span class="s1">str(self.path),</span>
            <span class="s1">self.lineno + </span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">name,</span>
            <span class="s1">line,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;co_name of underlying code.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.frame.code.raw.co_name</span>


<span class="s0">class </span><span class="s1">Traceback(List[TracebackEntry]):</span>
    <span class="s3">&quot;&quot;&quot;Traceback objects encapsulate and offer higher level access to Traceback entries.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">tb: Union[TracebackType, Iterable[TracebackEntry]],</span>
        <span class="s1">excinfo: Optional[</span><span class="s2">&quot;ReferenceType[ExceptionInfo[BaseException]]&quot;</span><span class="s1">] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Initialize from given python traceback object and ExceptionInfo.&quot;&quot;&quot;</span>
        <span class="s1">self._excinfo = excinfo</span>
        <span class="s0">if </span><span class="s1">isinstance(tb, TracebackType):</span>

            <span class="s0">def </span><span class="s1">f(cur: TracebackType) -&gt; Iterable[TracebackEntry]:</span>
                <span class="s1">cur_: Optional[TracebackType] = cur</span>
                <span class="s0">while </span><span class="s1">cur_ </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">TracebackEntry(cur_, excinfo=excinfo)</span>
                    <span class="s1">cur_ = cur_.tb_next</span>

            <span class="s1">super().__init__(f(tb))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">super().__init__(tb)</span>

    <span class="s0">def </span><span class="s1">cut(</span>
        <span class="s1">self,</span>
        <span class="s1">path=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">lineno: Optional[int] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">firstlineno: Optional[int] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">excludepath: Optional[py.path.local] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;Traceback&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return a Traceback instance wrapping part of this Traceback. 
 
        By providing any combination of path, lineno and firstlineno, the 
        first frame to start the to-be-returned traceback is determined. 
 
        This allows cutting the first part of a Traceback instance e.g. 
        for formatting reasons (removing some uninteresting bits that deal 
        with handling of the exception/traceback). 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self:</span>
            <span class="s1">code = x.frame.code</span>
            <span class="s1">codepath = code.path</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">(path </span><span class="s0">is None or </span><span class="s1">codepath == path)</span>
                <span class="s0">and </span><span class="s1">(</span>
                    <span class="s1">excludepath </span><span class="s0">is None</span>
                    <span class="s0">or not </span><span class="s1">isinstance(codepath, py.path.local)</span>
                    <span class="s0">or not </span><span class="s1">codepath.relto(excludepath)</span>
                <span class="s1">)</span>
                <span class="s0">and </span><span class="s1">(lineno </span><span class="s0">is None or </span><span class="s1">x.lineno == lineno)</span>
                <span class="s0">and </span><span class="s1">(firstlineno </span><span class="s0">is None or </span><span class="s1">x.frame.code.firstlineno == firstlineno)</span>
            <span class="s1">):</span>
                <span class="s0">return </span><span class="s1">Traceback(x._rawentry, self._excinfo)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self, key: int) -&gt; TracebackEntry:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self, key: slice) -&gt; </span><span class="s2">&quot;Traceback&quot;</span><span class="s1">:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">__getitem__(self, key: Union[int, slice]) -&gt; Union[TracebackEntry, </span><span class="s2">&quot;Traceback&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">isinstance(key, slice):</span>
            <span class="s0">return </span><span class="s1">self.__class__(super().__getitem__(key))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().__getitem__(key)</span>

    <span class="s0">def </span><span class="s1">filter(</span>
        <span class="s1">self, fn: Callable[[TracebackEntry], bool] = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s0">not </span><span class="s1">x.ishidden()</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;Traceback&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return a Traceback instance with certain items removed 
 
        fn is a function that gets a single argument, a TracebackEntry 
        instance, and should return True when the item should be added 
        to the Traceback, False when not. 
 
        By default this removes all the TracebackEntries which are hidden 
        (see ishidden() above). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Traceback(filter(fn, self), self._excinfo)</span>

    <span class="s0">def </span><span class="s1">getcrashentry(self) -&gt; TracebackEntry:</span>
        <span class="s3">&quot;&quot;&quot;Return last non-hidden traceback entry that lead to the exception of a traceback.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(-</span><span class="s4">1</span><span class="s1">, -len(self) - </span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">entry = self[i]</span>
            <span class="s0">if not </span><span class="s1">entry.ishidden():</span>
                <span class="s0">return </span><span class="s1">entry</span>
        <span class="s0">return </span><span class="s1">self[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">recursionindex(self) -&gt; Optional[int]:</span>
        <span class="s3">&quot;&quot;&quot;Return the index of the frame/TracebackEntry where recursion originates if 
        appropriate, None if no recursion occurred.&quot;&quot;&quot;</span>
        <span class="s1">cache: Dict[Tuple[Any, int, int], List[Dict[str, Any]]] = {}</span>
        <span class="s0">for </span><span class="s1">i, entry </span><span class="s0">in </span><span class="s1">enumerate(self):</span>
            <span class="s3"># id for the code.raw is needed to work around</span>
            <span class="s3"># the strange metaprogramming in the decorator lib from pypi</span>
            <span class="s3"># which generates code objects that have hash/value equality</span>
            <span class="s3"># XXX needs a test</span>
            <span class="s1">key = entry.frame.code.path, id(entry.frame.code.raw), entry.lineno</span>
            <span class="s3"># print &quot;checking for recursion at&quot;, key</span>
            <span class="s1">values = cache.setdefault(key, [])</span>
            <span class="s0">if </span><span class="s1">values:</span>
                <span class="s1">f = entry.frame</span>
                <span class="s1">loc = f.f_locals</span>
                <span class="s0">for </span><span class="s1">otherloc </span><span class="s0">in </span><span class="s1">values:</span>
                    <span class="s0">if </span><span class="s1">f.eval(</span>
                        <span class="s1">co_equal,</span>
                        <span class="s1">__recursioncache_locals_1=loc,</span>
                        <span class="s1">__recursioncache_locals_2=otherloc,</span>
                    <span class="s1">):</span>
                        <span class="s0">return </span><span class="s1">i</span>
            <span class="s1">values.append(entry.frame.f_locals)</span>
        <span class="s0">return None</span>


<span class="s1">co_equal = compile(</span>
    <span class="s2">&quot;__recursioncache_locals_1 == __recursioncache_locals_2&quot;</span><span class="s1">, </span><span class="s2">&quot;?&quot;</span><span class="s1">, </span><span class="s2">&quot;eval&quot;</span>
<span class="s1">)</span>


<span class="s1">_E = TypeVar(</span><span class="s2">&quot;_E&quot;</span><span class="s1">, bound=BaseException, covariant=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@final</span>
<span class="s1">@attr.s(repr=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ExceptionInfo(Generic[_E]):</span>
    <span class="s3">&quot;&quot;&quot;Wraps sys.exc_info() objects and offers help for navigating the traceback.&quot;&quot;&quot;</span>

    <span class="s1">_assert_start_repr = </span><span class="s2">&quot;AssertionError('assert &quot;</span>

    <span class="s1">_excinfo = attr.ib(type=Optional[Tuple[Type[</span><span class="s2">&quot;_E&quot;</span><span class="s1">], </span><span class="s2">&quot;_E&quot;</span><span class="s1">, TracebackType]])</span>
    <span class="s1">_striptext = attr.ib(type=str, default=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">_traceback = attr.ib(type=Optional[Traceback], default=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_exc_info(</span>
        <span class="s1">cls,</span>
        <span class="s1">exc_info: Tuple[Type[_E], _E, TracebackType],</span>
        <span class="s1">exprinfo: Optional[str] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ExceptionInfo[_E]&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return an ExceptionInfo for an existing exc_info tuple. 
 
        .. warning:: 
 
            Experimental API 
 
        :param exprinfo: 
            A text string helping to determine if we should strip 
            ``AssertionError`` from the output. Defaults to the exception 
            message/``__str__()``. 
        &quot;&quot;&quot;</span>
        <span class="s1">_striptext = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">exprinfo </span><span class="s0">is None and </span><span class="s1">isinstance(exc_info[</span><span class="s4">1</span><span class="s1">], AssertionError):</span>
            <span class="s1">exprinfo = getattr(exc_info[</span><span class="s4">1</span><span class="s1">], </span><span class="s2">&quot;msg&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">exprinfo </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">exprinfo = saferepr(exc_info[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">exprinfo </span><span class="s0">and </span><span class="s1">exprinfo.startswith(cls._assert_start_repr):</span>
                <span class="s1">_striptext = </span><span class="s2">&quot;AssertionError: &quot;</span>

        <span class="s0">return </span><span class="s1">cls(exc_info, _striptext)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_current(</span>
        <span class="s1">cls, exprinfo: Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ExceptionInfo[BaseException]&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return an ExceptionInfo matching the current traceback. 
 
        .. warning:: 
 
            Experimental API 
 
        :param exprinfo: 
            A text string helping to determine if we should strip 
            ``AssertionError`` from the output. Defaults to the exception 
            message/``__str__()``. 
        &quot;&quot;&quot;</span>
        <span class="s1">tup = sys.exc_info()</span>
        <span class="s0">assert </span><span class="s1">tup[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">, </span><span class="s2">&quot;no current exception&quot;</span>
        <span class="s0">assert </span><span class="s1">tup[</span><span class="s4">1</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">, </span><span class="s2">&quot;no current exception&quot;</span>
        <span class="s0">assert </span><span class="s1">tup[</span><span class="s4">2</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">, </span><span class="s2">&quot;no current exception&quot;</span>
        <span class="s1">exc_info = (tup[</span><span class="s4">0</span><span class="s1">], tup[</span><span class="s4">1</span><span class="s1">], tup[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">ExceptionInfo.from_exc_info(exc_info, exprinfo)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">for_later(cls) -&gt; </span><span class="s2">&quot;ExceptionInfo[_E]&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Return an unfilled ExceptionInfo.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">fill_unfilled(self, exc_info: Tuple[Type[_E], _E, TracebackType]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Fill an unfilled ExceptionInfo created with ``for_later()``.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self._excinfo </span><span class="s0">is None</span><span class="s1">, </span><span class="s2">&quot;ExceptionInfo was already filled&quot;</span>
        <span class="s1">self._excinfo = exc_info</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">type(self) -&gt; Type[_E]:</span>
        <span class="s3">&quot;&quot;&quot;The exception class.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self._excinfo </span><span class="s0">is not None</span>
        <span class="s1">), </span><span class="s2">&quot;.type can only be used after the context manager exits&quot;</span>
        <span class="s0">return </span><span class="s1">self._excinfo[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">value(self) -&gt; _E:</span>
        <span class="s3">&quot;&quot;&quot;The exception value.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self._excinfo </span><span class="s0">is not None</span>
        <span class="s1">), </span><span class="s2">&quot;.value can only be used after the context manager exits&quot;</span>
        <span class="s0">return </span><span class="s1">self._excinfo[</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">tb(self) -&gt; TracebackType:</span>
        <span class="s3">&quot;&quot;&quot;The exception raw traceback.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self._excinfo </span><span class="s0">is not None</span>
        <span class="s1">), </span><span class="s2">&quot;.tb can only be used after the context manager exits&quot;</span>
        <span class="s0">return </span><span class="s1">self._excinfo[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">typename(self) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;The type name of the exception.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">self._excinfo </span><span class="s0">is not None</span>
        <span class="s1">), </span><span class="s2">&quot;.typename can only be used after the context manager exits&quot;</span>
        <span class="s0">return </span><span class="s1">self.type.__name__</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">traceback(self) -&gt; Traceback:</span>
        <span class="s3">&quot;&quot;&quot;The traceback.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._traceback </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._traceback = Traceback(self.tb, excinfo=ref(self))</span>
        <span class="s0">return </span><span class="s1">self._traceback</span>

    <span class="s1">@traceback.setter</span>
    <span class="s0">def </span><span class="s1">traceback(self, value: Traceback) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._traceback = value</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self._excinfo </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s2">&quot;&lt;ExceptionInfo for raises contextmanager&gt;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;{} {} tblen={}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.__class__.__name__, saferepr(self._excinfo[</span><span class="s4">1</span><span class="s1">]), len(self.traceback)</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">exconly(self, tryshort: bool = </span><span class="s0">False</span><span class="s1">) -&gt; str:</span>
        <span class="s3">&quot;&quot;&quot;Return the exception as a string. 
 
        When 'tryshort' resolves to True, and the exception is a 
        _pytest._code._AssertionError, only the actual exception part of 
        the exception representation is returned (so 'AssertionError: ' is 
        removed from the beginning). 
        &quot;&quot;&quot;</span>
        <span class="s1">lines = format_exception_only(self.type, self.value)</span>
        <span class="s1">text = </span><span class="s2">&quot;&quot;</span><span class="s1">.join(lines)</span>
        <span class="s1">text = text.rstrip()</span>
        <span class="s0">if </span><span class="s1">tryshort:</span>
            <span class="s0">if </span><span class="s1">text.startswith(self._striptext):</span>
                <span class="s1">text = text[len(self._striptext) :]</span>
        <span class="s0">return </span><span class="s1">text</span>

    <span class="s0">def </span><span class="s1">errisinstance(</span>
        <span class="s1">self, exc: Union[Type[BaseException], Tuple[Type[BaseException], ...]]</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s3">&quot;&quot;&quot;Return True if the exception is an instance of exc. 
 
        Consider using ``isinstance(excinfo.value, exc)`` instead. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">isinstance(self.value, exc)</span>

    <span class="s0">def </span><span class="s1">_getreprcrash(self) -&gt; </span><span class="s2">&quot;ReprFileLocation&quot;</span><span class="s1">:</span>
        <span class="s1">exconly = self.exconly(tryshort=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">entry = self.traceback.getcrashentry()</span>
        <span class="s1">path, lineno = entry.frame.code.raw.co_filename, entry.lineno</span>
        <span class="s0">return </span><span class="s1">ReprFileLocation(path, lineno + </span><span class="s4">1</span><span class="s1">, exconly)</span>

    <span class="s0">def </span><span class="s1">getrepr(</span>
        <span class="s1">self,</span>
        <span class="s1">showlocals: bool = </span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">style: </span><span class="s2">&quot;_TracebackStyle&quot; </span><span class="s1">= </span><span class="s2">&quot;long&quot;</span><span class="s1">,</span>
        <span class="s1">abspath: bool = </span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">tbfilter: bool = </span><span class="s0">True</span><span class="s1">,</span>
        <span class="s1">funcargs: bool = </span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">truncate_locals: bool = </span><span class="s0">True</span><span class="s1">,</span>
        <span class="s1">chain: bool = </span><span class="s0">True</span><span class="s1">,</span>
    <span class="s1">) -&gt; Union[</span><span class="s2">&quot;ReprExceptionInfo&quot;</span><span class="s1">, </span><span class="s2">&quot;ExceptionChainRepr&quot;</span><span class="s1">]:</span>
        <span class="s3">&quot;&quot;&quot;Return str()able representation of this exception info. 
 
        :param bool showlocals: 
            Show locals per traceback entry. 
            Ignored if ``style==&quot;native&quot;``. 
 
        :param str style: 
            long|short|no|native|value traceback style. 
 
        :param bool abspath: 
            If paths should be changed to absolute or left unchanged. 
 
        :param bool tbfilter: 
            Hide entries that contain a local variable ``__tracebackhide__==True``. 
            Ignored if ``style==&quot;native&quot;``. 
 
        :param bool funcargs: 
            Show fixtures (&quot;funcargs&quot; for legacy purposes) per traceback entry. 
 
        :param bool truncate_locals: 
            With ``showlocals==True``, make sure locals can be safely represented as strings. 
 
        :param bool chain: 
            If chained exceptions in Python 3 should be shown. 
 
        .. versionchanged:: 3.9 
 
            Added the ``chain`` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">style == </span><span class="s2">&quot;native&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">ReprExceptionInfo(</span>
                <span class="s1">ReprTracebackNative(</span>
                    <span class="s1">traceback.format_exception(</span>
                        <span class="s1">self.type, self.value, self.traceback[</span><span class="s4">0</span><span class="s1">]._rawentry</span>
                    <span class="s1">)</span>
                <span class="s1">),</span>
                <span class="s1">self._getreprcrash(),</span>
            <span class="s1">)</span>

        <span class="s1">fmt = FormattedExcinfo(</span>
            <span class="s1">showlocals=showlocals,</span>
            <span class="s1">style=style,</span>
            <span class="s1">abspath=abspath,</span>
            <span class="s1">tbfilter=tbfilter,</span>
            <span class="s1">funcargs=funcargs,</span>
            <span class="s1">truncate_locals=truncate_locals,</span>
            <span class="s1">chain=chain,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">fmt.repr_excinfo(self)</span>

    <span class="s0">def </span><span class="s1">match(self, regexp: Union[str, Pattern[str]]) -&gt; </span><span class="s2">&quot;Literal[True]&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Check whether the regular expression `regexp` matches the string 
        representation of the exception using :func:`python:re.search`. 
 
        If it matches `True` is returned, otherwise an `AssertionError` is raised. 
        &quot;&quot;&quot;</span>
        <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
        <span class="s1">msg = </span><span class="s2">&quot;Regex pattern {!r} does not match {!r}.&quot;</span>
        <span class="s0">if </span><span class="s1">regexp == str(self.value):</span>
            <span class="s1">msg += </span><span class="s2">&quot; Did you mean to `re.escape()` the regex?&quot;</span>
        <span class="s0">assert </span><span class="s1">re.search(regexp, str(self.value)), msg.format(regexp, str(self.value))</span>
        <span class="s3"># Return True to allow for &quot;assert excinfo.match()&quot;.</span>
        <span class="s0">return True</span>


<span class="s1">@attr.s</span>
<span class="s0">class </span><span class="s1">FormattedExcinfo:</span>
    <span class="s3">&quot;&quot;&quot;Presenting information about failing Functions and Generators.&quot;&quot;&quot;</span>

    <span class="s3"># for traceback entries</span>
    <span class="s1">flow_marker = </span><span class="s2">&quot;&gt;&quot;</span>
    <span class="s1">fail_marker = </span><span class="s2">&quot;E&quot;</span>

    <span class="s1">showlocals = attr.ib(type=bool, default=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">style = attr.ib(type=</span><span class="s2">&quot;_TracebackStyle&quot;</span><span class="s1">, default=</span><span class="s2">&quot;long&quot;</span><span class="s1">)</span>
    <span class="s1">abspath = attr.ib(type=bool, default=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">tbfilter = attr.ib(type=bool, default=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">funcargs = attr.ib(type=bool, default=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">truncate_locals = attr.ib(type=bool, default=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">chain = attr.ib(type=bool, default=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">astcache = attr.ib(default=attr.Factory(dict), init=</span><span class="s0">False</span><span class="s1">, repr=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_getindent(self, source: </span><span class="s2">&quot;Source&quot;</span><span class="s1">) -&gt; int:</span>
        <span class="s3"># Figure out indent for the given source.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">s = str(source.getstatement(len(source) - </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s0">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s0">raise</span>
        <span class="s0">except </span><span class="s1">BaseException:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">s = str(source[-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">KeyboardInterrupt:</span>
                <span class="s0">raise</span>
            <span class="s0">except </span><span class="s1">BaseException:</span>
                <span class="s0">return </span><span class="s4">0</span>
        <span class="s0">return </span><span class="s4">4 </span><span class="s1">+ (len(s) - len(s.lstrip()))</span>

    <span class="s0">def </span><span class="s1">_getentrysource(self, entry: TracebackEntry) -&gt; Optional[</span><span class="s2">&quot;Source&quot;</span><span class="s1">]:</span>
        <span class="s1">source = entry.getsource(self.astcache)</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">source = source.deindent()</span>
        <span class="s0">return </span><span class="s1">source</span>

    <span class="s0">def </span><span class="s1">repr_args(self, entry: TracebackEntry) -&gt; Optional[</span><span class="s2">&quot;ReprFuncArgs&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">self.funcargs:</span>
            <span class="s1">args = []</span>
            <span class="s0">for </span><span class="s1">argname, argvalue </span><span class="s0">in </span><span class="s1">entry.frame.getargs(var=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s1">args.append((argname, saferepr(argvalue)))</span>
            <span class="s0">return </span><span class="s1">ReprFuncArgs(args)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_source(</span>
        <span class="s1">self,</span>
        <span class="s1">source: Optional[</span><span class="s2">&quot;Source&quot;</span><span class="s1">],</span>
        <span class="s1">line_index: int = -</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">excinfo: Optional[ExceptionInfo[BaseException]] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">short: bool = </span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">) -&gt; List[str]:</span>
        <span class="s3">&quot;&quot;&quot;Return formatted and marked up source lines.&quot;&quot;&quot;</span>
        <span class="s1">lines = []</span>
        <span class="s0">if </span><span class="s1">source </span><span class="s0">is None or </span><span class="s1">line_index &gt;= len(source.lines):</span>
            <span class="s1">source = Source(</span><span class="s2">&quot;???&quot;</span><span class="s1">)</span>
            <span class="s1">line_index = </span><span class="s4">0</span>
        <span class="s0">if </span><span class="s1">line_index &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">line_index += len(source)</span>
        <span class="s1">space_prefix = </span><span class="s2">&quot;    &quot;</span>
        <span class="s0">if </span><span class="s1">short:</span>
            <span class="s1">lines.append(space_prefix + source.lines[line_index].strip())</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">source.lines[:line_index]:</span>
                <span class="s1">lines.append(space_prefix + line)</span>
            <span class="s1">lines.append(self.flow_marker + </span><span class="s2">&quot;   &quot; </span><span class="s1">+ source.lines[line_index])</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">source.lines[line_index + </span><span class="s4">1 </span><span class="s1">:]:</span>
                <span class="s1">lines.append(space_prefix + line)</span>
        <span class="s0">if </span><span class="s1">excinfo </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">indent = </span><span class="s4">4 </span><span class="s0">if </span><span class="s1">short </span><span class="s0">else </span><span class="s1">self._getindent(source)</span>
            <span class="s1">lines.extend(self.get_exconly(excinfo, indent=indent, markall=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">get_exconly(</span>
        <span class="s1">self,</span>
        <span class="s1">excinfo: ExceptionInfo[BaseException],</span>
        <span class="s1">indent: int = </span><span class="s4">4</span><span class="s1">,</span>
        <span class="s1">markall: bool = </span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">) -&gt; List[str]:</span>
        <span class="s1">lines = []</span>
        <span class="s1">indentstr = </span><span class="s2">&quot; &quot; </span><span class="s1">* indent</span>
        <span class="s3"># Get the real exception information out.</span>
        <span class="s1">exlines = excinfo.exconly(tryshort=</span><span class="s0">True</span><span class="s1">).split(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s1">failindent = self.fail_marker + indentstr[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">exlines:</span>
            <span class="s1">lines.append(failindent + line)</span>
            <span class="s0">if not </span><span class="s1">markall:</span>
                <span class="s1">failindent = indentstr</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">repr_locals(self, locals: Mapping[str, object]) -&gt; Optional[</span><span class="s2">&quot;ReprLocals&quot;</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">self.showlocals:</span>
            <span class="s1">lines = []</span>
            <span class="s1">keys = [loc </span><span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">locals </span><span class="s0">if </span><span class="s1">loc[</span><span class="s4">0</span><span class="s1">] != </span><span class="s2">&quot;@&quot;</span><span class="s1">]</span>
            <span class="s1">keys.sort()</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">keys:</span>
                <span class="s1">value = locals[name]</span>
                <span class="s0">if </span><span class="s1">name == </span><span class="s2">&quot;__builtins__&quot;</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span><span class="s2">&quot;__builtins__ = &lt;builtins&gt;&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># This formatting could all be handled by the</span>
                    <span class="s3"># _repr() function, which is only reprlib.Repr in</span>
                    <span class="s3"># disguise, so is very configurable.</span>
                    <span class="s0">if </span><span class="s1">self.truncate_locals:</span>
                        <span class="s1">str_repr = saferepr(value)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">str_repr = safeformat(value)</span>
                    <span class="s3"># if len(str_repr) &lt; 70 or not isinstance(value, (list, tuple, dict)):</span>
                    <span class="s1">lines.append(</span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">name</span><span class="s5">:</span><span class="s2">&lt;10</span><span class="s5">} </span><span class="s2">= </span><span class="s5">{</span><span class="s1">str_repr</span><span class="s5">}</span><span class="s2">&quot;</span><span class="s1">)</span>
                    <span class="s3"># else:</span>
                    <span class="s3">#    self._line(&quot;%-10s =\\&quot; % (name,))</span>
                    <span class="s3">#    # XXX</span>
                    <span class="s3">#    pprint.pprint(value, stream=self.excinfowriter)</span>
            <span class="s0">return </span><span class="s1">ReprLocals(lines)</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">repr_traceback_entry(</span>
        <span class="s1">self,</span>
        <span class="s1">entry: TracebackEntry,</span>
        <span class="s1">excinfo: Optional[ExceptionInfo[BaseException]] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ReprEntry&quot;</span><span class="s1">:</span>
        <span class="s1">lines: List[str] = []</span>
        <span class="s1">style = entry._repr_style </span><span class="s0">if </span><span class="s1">entry._repr_style </span><span class="s0">is not None else </span><span class="s1">self.style</span>
        <span class="s0">if </span><span class="s1">style </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;short&quot;</span><span class="s1">, </span><span class="s2">&quot;long&quot;</span><span class="s1">):</span>
            <span class="s1">source = self._getentrysource(entry)</span>
            <span class="s0">if </span><span class="s1">source </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">source = Source(</span><span class="s2">&quot;???&quot;</span><span class="s1">)</span>
                <span class="s1">line_index = </span><span class="s4">0</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">line_index = entry.lineno - entry.getfirstlinesource()</span>
            <span class="s1">short = style == </span><span class="s2">&quot;short&quot;</span>
            <span class="s1">reprargs = self.repr_args(entry) </span><span class="s0">if not </span><span class="s1">short </span><span class="s0">else None</span>
            <span class="s1">s = self.get_source(source, line_index, excinfo, short=short)</span>
            <span class="s1">lines.extend(s)</span>
            <span class="s0">if </span><span class="s1">short:</span>
                <span class="s1">message = </span><span class="s2">&quot;in %s&quot; </span><span class="s1">% (entry.name)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">message = excinfo </span><span class="s0">and </span><span class="s1">excinfo.typename </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>
            <span class="s1">path = self._makepath(entry.path)</span>
            <span class="s1">reprfileloc = ReprFileLocation(path, entry.lineno + </span><span class="s4">1</span><span class="s1">, message)</span>
            <span class="s1">localsrepr = self.repr_locals(entry.locals)</span>
            <span class="s0">return </span><span class="s1">ReprEntry(lines, reprargs, localsrepr, reprfileloc, style)</span>
        <span class="s0">elif </span><span class="s1">style == </span><span class="s2">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">excinfo:</span>
                <span class="s1">lines.extend(str(excinfo.value).split(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">ReprEntry(lines, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">, style)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">excinfo:</span>
                <span class="s1">lines.extend(self.get_exconly(excinfo, indent=</span><span class="s4">4</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">ReprEntry(lines, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">, style)</span>

    <span class="s0">def </span><span class="s1">_makepath(self, path):</span>
        <span class="s0">if not </span><span class="s1">self.abspath:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">np = py.path.local().bestrelpath(path)</span>
            <span class="s0">except </span><span class="s1">OSError:</span>
                <span class="s0">return </span><span class="s1">path</span>
            <span class="s0">if </span><span class="s1">len(np) &lt; len(str(path)):</span>
                <span class="s1">path = np</span>
        <span class="s0">return </span><span class="s1">path</span>

    <span class="s0">def </span><span class="s1">repr_traceback(self, excinfo: ExceptionInfo[BaseException]) -&gt; </span><span class="s2">&quot;ReprTraceback&quot;</span><span class="s1">:</span>
        <span class="s1">traceback = excinfo.traceback</span>
        <span class="s0">if </span><span class="s1">self.tbfilter:</span>
            <span class="s1">traceback = traceback.filter()</span>

        <span class="s0">if </span><span class="s1">isinstance(excinfo.value, RecursionError):</span>
            <span class="s1">traceback, extraline = self._truncate_recursive_traceback(traceback)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">extraline = </span><span class="s0">None</span>

        <span class="s1">last = traceback[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">entries = []</span>
        <span class="s0">if </span><span class="s1">self.style == </span><span class="s2">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s1">reprentry = self.repr_traceback_entry(last, excinfo)</span>
            <span class="s1">entries.append(reprentry)</span>
            <span class="s0">return </span><span class="s1">ReprTraceback(entries, </span><span class="s0">None</span><span class="s1">, style=self.style)</span>

        <span class="s0">for </span><span class="s1">index, entry </span><span class="s0">in </span><span class="s1">enumerate(traceback):</span>
            <span class="s1">einfo = (last == entry) </span><span class="s0">and </span><span class="s1">excinfo </span><span class="s0">or None</span>
            <span class="s1">reprentry = self.repr_traceback_entry(entry, einfo)</span>
            <span class="s1">entries.append(reprentry)</span>
        <span class="s0">return </span><span class="s1">ReprTraceback(entries, extraline, style=self.style)</span>

    <span class="s0">def </span><span class="s1">_truncate_recursive_traceback(</span>
        <span class="s1">self, traceback: Traceback</span>
    <span class="s1">) -&gt; Tuple[Traceback, Optional[str]]:</span>
        <span class="s3">&quot;&quot;&quot;Truncate the given recursive traceback trying to find the starting 
        point of the recursion. 
 
        The detection is done by going through each traceback entry and 
        finding the point in which the locals of the frame are equal to the 
        locals of a previous frame (see ``recursionindex()``). 
 
        Handle the situation where the recursion process might raise an 
        exception (for example comparing numpy arrays using equality raises a 
        TypeError), in which case we do our best to warn the user of the 
        error and show a limited traceback. 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">recursionindex = traceback.recursionindex()</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">max_frames = </span><span class="s4">10</span>
            <span class="s1">extraline: Optional[str] = (</span>
                <span class="s2">&quot;!!! Recursion error detected, but an error occurred locating the origin of recursion.</span><span class="s5">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  The following exception happened when comparing locals in the stack frame:</span><span class="s5">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;    {exc_type}: {exc_msg}</span><span class="s5">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;  Displaying first and last {max_frames} stack frames out of {total}.&quot;</span>
            <span class="s1">).format(</span>
                <span class="s1">exc_type=type(e).__name__,</span>
                <span class="s1">exc_msg=str(e),</span>
                <span class="s1">max_frames=max_frames,</span>
                <span class="s1">total=len(traceback),</span>
            <span class="s1">)</span>
            <span class="s3"># Type ignored because adding two instaces of a List subtype</span>
            <span class="s3"># currently incorrectly has type List instead of the subtype.</span>
            <span class="s1">traceback = traceback[:max_frames] + traceback[-max_frames:]  </span><span class="s3"># type: ignore</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">recursionindex </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">extraline = </span><span class="s2">&quot;!!! Recursion detected (same locals &amp; position)&quot;</span>
                <span class="s1">traceback = traceback[: recursionindex + </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">extraline = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">traceback, extraline</span>

    <span class="s0">def </span><span class="s1">repr_excinfo(</span>
        <span class="s1">self, excinfo: ExceptionInfo[BaseException]</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ExceptionChainRepr&quot;</span><span class="s1">:</span>
        <span class="s1">repr_chain: List[</span>
            <span class="s1">Tuple[ReprTraceback, Optional[ReprFileLocation], Optional[str]]</span>
        <span class="s1">] = []</span>
        <span class="s1">e: Optional[BaseException] = excinfo.value</span>
        <span class="s1">excinfo_: Optional[ExceptionInfo[BaseException]] = excinfo</span>
        <span class="s1">descr = </span><span class="s0">None</span>
        <span class="s1">seen: Set[int] = set()</span>
        <span class="s0">while </span><span class="s1">e </span><span class="s0">is not None and </span><span class="s1">id(e) </span><span class="s0">not in </span><span class="s1">seen:</span>
            <span class="s1">seen.add(id(e))</span>
            <span class="s0">if </span><span class="s1">excinfo_:</span>
                <span class="s1">reprtraceback = self.repr_traceback(excinfo_)</span>
                <span class="s1">reprcrash: Optional[ReprFileLocation] = (</span>
                    <span class="s1">excinfo_._getreprcrash() </span><span class="s0">if </span><span class="s1">self.style != </span><span class="s2">&quot;value&quot; </span><span class="s0">else None</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># Fallback to native repr if the exception doesn't have a traceback:</span>
                <span class="s3"># ExceptionInfo objects require a full traceback to work.</span>
                <span class="s1">reprtraceback = ReprTracebackNative(</span>
                    <span class="s1">traceback.format_exception(type(e), e, </span><span class="s0">None</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">reprcrash = </span><span class="s0">None</span>

            <span class="s1">repr_chain += [(reprtraceback, reprcrash, descr)]</span>
            <span class="s0">if </span><span class="s1">e.__cause__ </span><span class="s0">is not None and </span><span class="s1">self.chain:</span>
                <span class="s1">e = e.__cause__</span>
                <span class="s1">excinfo_ = (</span>
                    <span class="s1">ExceptionInfo((type(e), e, e.__traceback__))</span>
                    <span class="s0">if </span><span class="s1">e.__traceback__</span>
                    <span class="s0">else None</span>
                <span class="s1">)</span>
                <span class="s1">descr = </span><span class="s2">&quot;The above exception was the direct cause of the following exception:&quot;</span>
            <span class="s0">elif </span><span class="s1">(</span>
                <span class="s1">e.__context__ </span><span class="s0">is not None and not </span><span class="s1">e.__suppress_context__ </span><span class="s0">and </span><span class="s1">self.chain</span>
            <span class="s1">):</span>
                <span class="s1">e = e.__context__</span>
                <span class="s1">excinfo_ = (</span>
                    <span class="s1">ExceptionInfo((type(e), e, e.__traceback__))</span>
                    <span class="s0">if </span><span class="s1">e.__traceback__</span>
                    <span class="s0">else None</span>
                <span class="s1">)</span>
                <span class="s1">descr = </span><span class="s2">&quot;During handling of the above exception, another exception occurred:&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">e = </span><span class="s0">None</span>
        <span class="s1">repr_chain.reverse()</span>
        <span class="s0">return </span><span class="s1">ExceptionChainRepr(repr_chain)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TerminalRepr:</span>
    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s3"># FYI this is called from pytest-xdist's serialization of exception</span>
        <span class="s3"># information.</span>
        <span class="s1">io = StringIO()</span>
        <span class="s1">tw = TerminalWriter(file=io)</span>
        <span class="s1">self.toterminal(tw)</span>
        <span class="s0">return </span><span class="s1">io.getvalue().strip()</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;{} instance at {:0x}&gt;&quot;</span><span class="s1">.format(self.__class__, id(self))</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>


<span class="s3"># This class is abstract -- only subclasses are instantiated.</span>
<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ExceptionRepr(TerminalRepr):</span>
    <span class="s3"># Provided by subclasses.</span>
    <span class="s1">reprcrash: Optional[</span><span class="s2">&quot;ReprFileLocation&quot;</span><span class="s1">]</span>
    <span class="s1">reprtraceback: </span><span class="s2">&quot;ReprTraceback&quot;</span>

    <span class="s0">def </span><span class="s1">__attrs_post_init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.sections: List[Tuple[str, str, str]] = []</span>

    <span class="s0">def </span><span class="s1">addsection(self, name: str, content: str, sep: str = </span><span class="s2">&quot;-&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.sections.append((name, content, sep))</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">name, content, sep </span><span class="s0">in </span><span class="s1">self.sections:</span>
            <span class="s1">tw.sep(sep, name)</span>
            <span class="s1">tw.line(content)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ExceptionChainRepr(ExceptionRepr):</span>
    <span class="s1">chain = attr.ib(</span>
        <span class="s1">type=Sequence[</span>
            <span class="s1">Tuple[</span><span class="s2">&quot;ReprTraceback&quot;</span><span class="s1">, Optional[</span><span class="s2">&quot;ReprFileLocation&quot;</span><span class="s1">], Optional[str]]</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__attrs_post_init__(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">super().__attrs_post_init__()</span>
        <span class="s3"># reprcrash and reprtraceback of the outermost (the newest) exception</span>
        <span class="s3"># in the chain.</span>
        <span class="s1">self.reprtraceback = self.chain[-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.reprcrash = self.chain[-</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">self.chain:</span>
            <span class="s1">element[</span><span class="s4">0</span><span class="s1">].toterminal(tw)</span>
            <span class="s0">if </span><span class="s1">element[</span><span class="s4">2</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">tw.line(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">tw.line(element[</span><span class="s4">2</span><span class="s1">], yellow=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">super().toterminal(tw)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprExceptionInfo(ExceptionRepr):</span>
    <span class="s1">reprtraceback = attr.ib(type=</span><span class="s2">&quot;ReprTraceback&quot;</span><span class="s1">)</span>
    <span class="s1">reprcrash = attr.ib(type=</span><span class="s2">&quot;ReprFileLocation&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.reprtraceback.toterminal(tw)</span>
        <span class="s1">super().toterminal(tw)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprTraceback(TerminalRepr):</span>
    <span class="s1">reprentries = attr.ib(type=Sequence[Union[</span><span class="s2">&quot;ReprEntry&quot;</span><span class="s1">, </span><span class="s2">&quot;ReprEntryNative&quot;</span><span class="s1">]])</span>
    <span class="s1">extraline = attr.ib(type=Optional[str])</span>
    <span class="s1">style = attr.ib(type=</span><span class="s2">&quot;_TracebackStyle&quot;</span><span class="s1">)</span>

    <span class="s1">entrysep = </span><span class="s2">&quot;_ &quot;</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># The entries might have different styles.</span>
        <span class="s0">for </span><span class="s1">i, entry </span><span class="s0">in </span><span class="s1">enumerate(self.reprentries):</span>
            <span class="s0">if </span><span class="s1">entry.style == </span><span class="s2">&quot;long&quot;</span><span class="s1">:</span>
                <span class="s1">tw.line(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">entry.toterminal(tw)</span>
            <span class="s0">if </span><span class="s1">i &lt; len(self.reprentries) - </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">next_entry = self.reprentries[i + </span><span class="s4">1</span><span class="s1">]</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">entry.style == </span><span class="s2">&quot;long&quot;</span>
                    <span class="s0">or </span><span class="s1">entry.style == </span><span class="s2">&quot;short&quot;</span>
                    <span class="s0">and </span><span class="s1">next_entry.style == </span><span class="s2">&quot;long&quot;</span>
                <span class="s1">):</span>
                    <span class="s1">tw.sep(self.entrysep)</span>

        <span class="s0">if </span><span class="s1">self.extraline:</span>
            <span class="s1">tw.line(self.extraline)</span>


<span class="s0">class </span><span class="s1">ReprTracebackNative(ReprTraceback):</span>
    <span class="s0">def </span><span class="s1">__init__(self, tblines: Sequence[str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.style = </span><span class="s2">&quot;native&quot;</span>
        <span class="s1">self.reprentries = [ReprEntryNative(tblines)]</span>
        <span class="s1">self.extraline = </span><span class="s0">None</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprEntryNative(TerminalRepr):</span>
    <span class="s1">lines = attr.ib(type=Sequence[str])</span>
    <span class="s1">style: </span><span class="s2">&quot;_TracebackStyle&quot; </span><span class="s1">= </span><span class="s2">&quot;native&quot;</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">tw.write(</span><span class="s2">&quot;&quot;</span><span class="s1">.join(self.lines))</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprEntry(TerminalRepr):</span>
    <span class="s1">lines = attr.ib(type=Sequence[str])</span>
    <span class="s1">reprfuncargs = attr.ib(type=Optional[</span><span class="s2">&quot;ReprFuncArgs&quot;</span><span class="s1">])</span>
    <span class="s1">reprlocals = attr.ib(type=Optional[</span><span class="s2">&quot;ReprLocals&quot;</span><span class="s1">])</span>
    <span class="s1">reprfileloc = attr.ib(type=Optional[</span><span class="s2">&quot;ReprFileLocation&quot;</span><span class="s1">])</span>
    <span class="s1">style = attr.ib(type=</span><span class="s2">&quot;_TracebackStyle&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_write_entry_lines(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Write the source code portions of a list of traceback entries with syntax highlighting. 
 
        Usually entries are lines like these: 
 
            &quot;     x = 1&quot; 
            &quot;&gt;    assert x == 2&quot; 
            &quot;E    assert 1 == 2&quot; 
 
        This function takes care of rendering the &quot;source&quot; portions of it (the lines without 
        the &quot;E&quot; prefix) using syntax highlighting, taking care to not highlighting the &quot;&gt;&quot; 
        character, as doing so might break line continuations. 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">self.lines:</span>
            <span class="s0">return</span>

        <span class="s3"># separate indents and source lines that are not failures: we want to</span>
        <span class="s3"># highlight the code but not the indentation, which may contain markers</span>
        <span class="s3"># such as &quot;&gt;   assert 0&quot;</span>
        <span class="s1">fail_marker = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">FormattedExcinfo.fail_marker</span><span class="s5">}   </span><span class="s2">&quot;</span>
        <span class="s1">indent_size = len(fail_marker)</span>
        <span class="s1">indents: List[str] = []</span>
        <span class="s1">source_lines: List[str] = []</span>
        <span class="s1">failure_lines: List[str] = []</span>
        <span class="s0">for </span><span class="s1">index, line </span><span class="s0">in </span><span class="s1">enumerate(self.lines):</span>
            <span class="s1">is_failure_line = line.startswith(fail_marker)</span>
            <span class="s0">if </span><span class="s1">is_failure_line:</span>
                <span class="s3"># from this point on all lines are considered part of the failure</span>
                <span class="s1">failure_lines.extend(self.lines[index:])</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.style == </span><span class="s2">&quot;value&quot;</span><span class="s1">:</span>
                    <span class="s1">source_lines.append(line)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">indents.append(line[:indent_size])</span>
                    <span class="s1">source_lines.append(line[indent_size:])</span>

        <span class="s1">tw._write_source(source_lines, indents)</span>

        <span class="s3"># failure lines are always completely red and bold</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">failure_lines:</span>
            <span class="s1">tw.line(line, bold=</span><span class="s0">True</span><span class="s1">, red=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.style == </span><span class="s2">&quot;short&quot;</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">self.reprfileloc </span><span class="s0">is not None</span>
            <span class="s1">self.reprfileloc.toterminal(tw)</span>
            <span class="s1">self._write_entry_lines(tw)</span>
            <span class="s0">if </span><span class="s1">self.reprlocals:</span>
                <span class="s1">self.reprlocals.toterminal(tw, indent=</span><span class="s2">&quot; &quot; </span><span class="s1">* </span><span class="s4">8</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">self.reprfuncargs:</span>
            <span class="s1">self.reprfuncargs.toterminal(tw)</span>

        <span class="s1">self._write_entry_lines(tw)</span>

        <span class="s0">if </span><span class="s1">self.reprlocals:</span>
            <span class="s1">tw.line(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.reprlocals.toterminal(tw)</span>
        <span class="s0">if </span><span class="s1">self.reprfileloc:</span>
            <span class="s0">if </span><span class="s1">self.lines:</span>
                <span class="s1">tw.line(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.reprfileloc.toterminal(tw)</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;{}</span><span class="s5">\n</span><span class="s2">{}</span><span class="s5">\n</span><span class="s2">{}&quot;</span><span class="s1">.format(</span>
            <span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">.join(self.lines), self.reprlocals, self.reprfileloc</span>
        <span class="s1">)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprFileLocation(TerminalRepr):</span>
    <span class="s1">path = attr.ib(type=str, converter=str)</span>
    <span class="s1">lineno = attr.ib(type=int)</span>
    <span class="s1">message = attr.ib(type=str)</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># Filename and lineno output for each entry, using an output format</span>
        <span class="s3"># that most editors understand.</span>
        <span class="s1">msg = self.message</span>
        <span class="s1">i = msg.find(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">i != -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">msg = msg[:i]</span>
        <span class="s1">tw.write(self.path, bold=</span><span class="s0">True</span><span class="s1">, red=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tw.line(</span><span class="s2">f&quot;:</span><span class="s5">{</span><span class="s1">self.lineno</span><span class="s5">}</span><span class="s2">: </span><span class="s5">{</span><span class="s1">msg</span><span class="s5">}</span><span class="s2">&quot;</span><span class="s1">)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprLocals(TerminalRepr):</span>
    <span class="s1">lines = attr.ib(type=Sequence[str])</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter, indent=</span><span class="s2">&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.lines:</span>
            <span class="s1">tw.line(indent + line)</span>


<span class="s1">@attr.s(eq=</span><span class="s0">False</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">ReprFuncArgs(TerminalRepr):</span>
    <span class="s1">args = attr.ib(type=Sequence[Tuple[str, object]])</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">self.args:</span>
            <span class="s1">linesofar = </span><span class="s2">&quot;&quot;</span>
            <span class="s0">for </span><span class="s1">name, value </span><span class="s0">in </span><span class="s1">self.args:</span>
                <span class="s1">ns = </span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">name</span><span class="s5">} </span><span class="s2">= </span><span class="s5">{</span><span class="s1">value</span><span class="s5">}</span><span class="s2">&quot;</span>
                <span class="s0">if </span><span class="s1">len(ns) + len(linesofar) + </span><span class="s4">2 </span><span class="s1">&gt; tw.fullwidth:</span>
                    <span class="s0">if </span><span class="s1">linesofar:</span>
                        <span class="s1">tw.line(linesofar)</span>
                    <span class="s1">linesofar = ns</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">linesofar:</span>
                        <span class="s1">linesofar += </span><span class="s2">&quot;, &quot; </span><span class="s1">+ ns</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">linesofar = ns</span>
            <span class="s0">if </span><span class="s1">linesofar:</span>
                <span class="s1">tw.line(linesofar)</span>
            <span class="s1">tw.line(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">getfslineno(obj: object) -&gt; Tuple[Union[str, py.path.local], int]:</span>
    <span class="s3">&quot;&quot;&quot;Return source location (path, lineno) for the given object. 
 
    If the source cannot be determined return (&quot;&quot;, -1). 
 
    The line number is 0-based. 
    &quot;&quot;&quot;</span>
    <span class="s3"># xxx let decorators etc specify a sane ordering</span>
    <span class="s3"># NOTE: this used to be done in _pytest.compat.getfslineno, initially added</span>
    <span class="s3">#       in 6ec13a2b9.  It (&quot;place_as&quot;) appears to be something very custom.</span>
    <span class="s1">obj = get_real_func(obj)</span>
    <span class="s0">if </span><span class="s1">hasattr(obj, </span><span class="s2">&quot;place_as&quot;</span><span class="s1">):</span>
        <span class="s1">obj = obj.place_as  </span><span class="s3"># type: ignore[attr-defined]</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">code = Code.from_function(obj)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">fn = inspect.getsourcefile(obj) </span><span class="s0">or </span><span class="s1">inspect.getfile(obj)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return </span><span class="s2">&quot;&quot;</span><span class="s1">, -</span><span class="s4">1</span>

        <span class="s1">fspath = fn </span><span class="s0">and </span><span class="s1">py.path.local(fn) </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>
        <span class="s1">lineno = -</span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">fspath:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">_, lineno = findsource(obj)</span>
            <span class="s0">except </span><span class="s1">OSError:</span>
                <span class="s0">pass</span>
        <span class="s0">return </span><span class="s1">fspath, lineno</span>

    <span class="s0">return </span><span class="s1">code.path, code.firstlineno</span>


<span class="s3"># Relative paths that we use to filter traceback entries from appearing to the user;</span>
<span class="s3"># see filter_traceback.</span>
<span class="s3"># note: if we need to add more paths than what we have now we should probably use a list</span>
<span class="s3"># for better maintenance.</span>

<span class="s1">_PLUGGY_DIR = Path(pluggy.__file__.rstrip(</span><span class="s2">&quot;oc&quot;</span><span class="s1">))</span>
<span class="s3"># pluggy is either a package or a single module depending on the version</span>
<span class="s0">if </span><span class="s1">_PLUGGY_DIR.name == </span><span class="s2">&quot;__init__.py&quot;</span><span class="s1">:</span>
    <span class="s1">_PLUGGY_DIR = _PLUGGY_DIR.parent</span>
<span class="s1">_PYTEST_DIR = Path(_pytest.__file__).parent</span>
<span class="s1">_PY_DIR = Path(py.__file__).parent</span>


<span class="s0">def </span><span class="s1">filter_traceback(entry: TracebackEntry) -&gt; bool:</span>
    <span class="s3">&quot;&quot;&quot;Return True if a TracebackEntry instance should be included in tracebacks. 
 
    We hide traceback entries of: 
 
    * dynamically generated code (no code to show up for it); 
    * internal traceback from pytest or its internal libraries, py and pluggy. 
    &quot;&quot;&quot;</span>
    <span class="s3"># entry.path might sometimes return a str object when the entry</span>
    <span class="s3"># points to dynamically generated code.</span>
    <span class="s3"># See https://bitbucket.org/pytest-dev/py/issues/71.</span>
    <span class="s1">raw_filename = entry.frame.code.raw.co_filename</span>
    <span class="s1">is_generated = </span><span class="s2">&quot;&lt;&quot; </span><span class="s0">in </span><span class="s1">raw_filename </span><span class="s0">and </span><span class="s2">&quot;&gt;&quot; </span><span class="s0">in </span><span class="s1">raw_filename</span>
    <span class="s0">if </span><span class="s1">is_generated:</span>
        <span class="s0">return False</span>

    <span class="s3"># entry.path might point to a non-existing file, in which case it will</span>
    <span class="s3"># also return a str object. See #1133.</span>
    <span class="s1">p = Path(entry.path)</span>

    <span class="s1">parents = p.parents</span>
    <span class="s0">if </span><span class="s1">_PLUGGY_DIR </span><span class="s0">in </span><span class="s1">parents:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">_PYTEST_DIR </span><span class="s0">in </span><span class="s1">parents:</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">_PY_DIR </span><span class="s0">in </span><span class="s1">parents:</span>
        <span class="s0">return False</span>

    <span class="s0">return True</span>
</pre>
</body>
</html>