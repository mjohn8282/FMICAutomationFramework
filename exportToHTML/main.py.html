<html>
<head>
<title>main.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
main.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Core implementation of the testing process: init, session, runtest loop.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">argparse</span>
<span class="s2">import </span><span class="s1">fnmatch</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">FrozenSet</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Set</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">attr</span>
<span class="s2">import </span><span class="s1">py</span>

<span class="s2">import </span><span class="s1">_pytest._code</span>
<span class="s2">from </span><span class="s1">_pytest </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">Config</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">directory_arg</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">ExitCode</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">hookimpl</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">PytestPluginManager</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">UsageError</span>
<span class="s2">from </span><span class="s1">_pytest.config.argparsing </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">_pytest.fixtures </span><span class="s2">import </span><span class="s1">FixtureManager</span>
<span class="s2">from </span><span class="s1">_pytest.outcomes </span><span class="s2">import </span><span class="s1">exit</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">absolutepath</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">bestrelpath</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">visit</span>
<span class="s2">from </span><span class="s1">_pytest.reports </span><span class="s2">import </span><span class="s1">CollectReport</span>
<span class="s2">from </span><span class="s1">_pytest.reports </span><span class="s2">import </span><span class="s1">TestReport</span>
<span class="s2">from </span><span class="s1">_pytest.runner </span><span class="s2">import </span><span class="s1">collect_one_node</span>
<span class="s2">from </span><span class="s1">_pytest.runner </span><span class="s2">import </span><span class="s1">SetupState</span>


<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Literal</span>


<span class="s2">def </span><span class="s1">pytest_addoption(parser: Parser) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;norecursedirs&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;directory patterns to avoid for recursion&quot;</span><span class="s1">,</span>
        <span class="s1">type=</span><span class="s3">&quot;args&quot;</span><span class="s1">,</span>
        <span class="s1">default=[</span>
            <span class="s3">&quot;*.egg&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;.*&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;_darcs&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;build&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;CVS&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;dist&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;node_modules&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;venv&quot;</span><span class="s1">,</span>
            <span class="s3">&quot;{arch}&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;testpaths&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;directories to search for tests when no files or directories are given in the &quot;</span>
        <span class="s3">&quot;command line.&quot;</span><span class="s1">,</span>
        <span class="s1">type=</span><span class="s3">&quot;args&quot;</span><span class="s1">,</span>
        <span class="s1">default=[],</span>
    <span class="s1">)</span>
    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;general&quot;</span><span class="s1">, </span><span class="s3">&quot;running and selection options&quot;</span><span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;-x&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;--exitfirst&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_const&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;maxfail&quot;</span><span class="s1">,</span>
        <span class="s1">const=</span><span class="s4">1</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;exit instantly on first error or failed test.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;pytest-warnings&quot;</span><span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;-W&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;--pythonwarnings&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;append&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;set which warnings to report, see -W option of python itself.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;filterwarnings&quot;</span><span class="s1">,</span>
        <span class="s1">type=</span><span class="s3">&quot;linelist&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Each line specifies a pattern for &quot;</span>
        <span class="s3">&quot;warnings.filterwarnings. &quot;</span>
        <span class="s3">&quot;Processed after -W/--pythonwarnings.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--maxfail&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;num&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">type=int,</span>
        <span class="s1">dest=</span><span class="s3">&quot;maxfail&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s4">0</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;exit after first num failures or errors.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--strict-config&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;any warnings encountered while parsing the `pytest` section of the configuration file raise errors.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--strict-markers&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;markers not registered in the `markers` section of the configuration file raise errors.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--strict&quot;</span><span class="s1">, action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">, help=</span><span class="s3">&quot;(deprecated) alias to --strict-markers.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;-c&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;file&quot;</span><span class="s1">,</span>
        <span class="s1">type=str,</span>
        <span class="s1">dest=</span><span class="s3">&quot;inifilename&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;load configuration from `file` instead of trying to locate one of the implicit &quot;</span>
        <span class="s3">&quot;configuration files.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--continue-on-collection-errors&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;continue_on_collection_errors&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Force test execution even if collection errors occur.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--rootdir&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;rootdir&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Define root directory for tests. Can be relative path: 'root_dir', './root_dir', &quot;</span>
        <span class="s3">&quot;'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: &quot;</span>
        <span class="s3">&quot;'$HOME/root_dir'.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;collect&quot;</span><span class="s1">, </span><span class="s3">&quot;collection&quot;</span><span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--collectonly&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;--collect-only&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;--co&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;only collect tests, don't execute them.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--pyargs&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;try to interpret all arguments as python packages.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--ignore&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;append&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;path&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;ignore path during collection (multi-allowed).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--ignore-glob&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;append&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;path&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;ignore path pattern during collection (multi-allowed).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--deselect&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;append&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;nodeid_prefix&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;deselect item (via node id prefix) during collection (multi-allowed).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--confcutdir&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;confcutdir&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;dir&quot;</span><span class="s1">,</span>
        <span class="s1">type=functools.partial(directory_arg, optname=</span><span class="s3">&quot;--confcutdir&quot;</span><span class="s1">),</span>
        <span class="s1">help=</span><span class="s3">&quot;only load conftest.py's relative to specified dir.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--noconftest&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;noconftest&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Don't load any conftest.py files.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--keepduplicates&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;--keep-duplicates&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;keepduplicates&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Keep duplicate tests.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--collect-in-virtualenv&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;collect_in_virtualenv&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;Don't ignore tests in a local virtualenv directory&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--import-mode&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s3">&quot;prepend&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s3">&quot;prepend&quot;</span><span class="s1">, </span><span class="s3">&quot;append&quot;</span><span class="s1">, </span><span class="s3">&quot;importlib&quot;</span><span class="s1">],</span>
        <span class="s1">dest=</span><span class="s3">&quot;importmode&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;prepend/append to sys.path when importing test modules and conftest files, &quot;</span>
        <span class="s3">&quot;default is to prepend.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;debugconfig&quot;</span><span class="s1">, </span><span class="s3">&quot;test session debugging and configuration&quot;</span><span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--basetemp&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;basetemp&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type=validate_basetemp,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;dir&quot;</span><span class="s1">,</span>
        <span class="s1">help=(</span>
            <span class="s3">&quot;base temporary directory for this test run.&quot;</span>
            <span class="s3">&quot;(warning: this directory is removed if it exists)&quot;</span>
        <span class="s1">),</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">validate_basetemp(path: str) -&gt; str:</span>
    <span class="s0"># GH 7119</span>
    <span class="s1">msg = </span><span class="s3">&quot;basetemp must not be empty, the current working directory or any parent directory of it&quot;</span>

    <span class="s0"># empty path</span>
    <span class="s2">if not </span><span class="s1">path:</span>
        <span class="s2">raise </span><span class="s1">argparse.ArgumentTypeError(msg)</span>

    <span class="s2">def </span><span class="s1">is_ancestor(base: Path, query: Path) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Return whether query is an ancestor of base.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">base == query:</span>
            <span class="s2">return True</span>
        <span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">base.parents:</span>
            <span class="s2">if </span><span class="s1">parent == query:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s0"># check if path is an ancestor of cwd</span>
    <span class="s2">if </span><span class="s1">is_ancestor(Path.cwd(), Path(path).absolute()):</span>
        <span class="s2">raise </span><span class="s1">argparse.ArgumentTypeError(msg)</span>

    <span class="s0"># check symlinks for ancestors</span>
    <span class="s2">if </span><span class="s1">is_ancestor(Path.cwd().resolve(), Path(path).resolve()):</span>
        <span class="s2">raise </span><span class="s1">argparse.ArgumentTypeError(msg)</span>

    <span class="s2">return </span><span class="s1">path</span>


<span class="s2">def </span><span class="s1">wrap_session(</span>
    <span class="s1">config: Config, doit: Callable[[Config, </span><span class="s3">&quot;Session&quot;</span><span class="s1">], Optional[Union[int, ExitCode]]]</span>
<span class="s1">) -&gt; Union[int, ExitCode]:</span>
    <span class="s0">&quot;&quot;&quot;Skeleton command line program.&quot;&quot;&quot;</span>
    <span class="s1">session = Session.from_config(config)</span>
    <span class="s1">session.exitstatus = ExitCode.OK</span>
    <span class="s1">initstate = </span><span class="s4">0</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">config._do_configure()</span>
            <span class="s1">initstate = </span><span class="s4">1</span>
            <span class="s1">config.hook.pytest_sessionstart(session=session)</span>
            <span class="s1">initstate = </span><span class="s4">2</span>
            <span class="s1">session.exitstatus = doit(config, session) </span><span class="s2">or </span><span class="s4">0</span>
        <span class="s2">except </span><span class="s1">UsageError:</span>
            <span class="s1">session.exitstatus = ExitCode.USAGE_ERROR</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">Failed:</span>
            <span class="s1">session.exitstatus = ExitCode.TESTS_FAILED</span>
        <span class="s2">except </span><span class="s1">(KeyboardInterrupt, exit.Exception):</span>
            <span class="s1">excinfo = _pytest._code.ExceptionInfo.from_current()</span>
            <span class="s1">exitstatus: Union[int, ExitCode] = ExitCode.INTERRUPTED</span>
            <span class="s2">if </span><span class="s1">isinstance(excinfo.value, exit.Exception):</span>
                <span class="s2">if </span><span class="s1">excinfo.value.returncode </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">exitstatus = excinfo.value.returncode</span>
                <span class="s2">if </span><span class="s1">initstate &lt; </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s1">sys.stderr.write(</span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">excinfo.typename</span><span class="s5">}</span><span class="s3">: </span><span class="s5">{</span><span class="s1">excinfo.value.msg</span><span class="s5">}\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">config.hook.pytest_keyboard_interrupt(excinfo=excinfo)</span>
            <span class="s1">session.exitstatus = exitstatus</span>
        <span class="s2">except </span><span class="s1">BaseException:</span>
            <span class="s1">session.exitstatus = ExitCode.INTERNAL_ERROR</span>
            <span class="s1">excinfo = _pytest._code.ExceptionInfo.from_current()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">config.notify_exception(excinfo, config.option)</span>
            <span class="s2">except </span><span class="s1">exit.Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">if </span><span class="s1">exc.returncode </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">session.exitstatus = exc.returncode</span>
                <span class="s1">sys.stderr.write(</span><span class="s3">&quot;{}: {}</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">.format(type(exc).__name__, exc))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(excinfo.value, SystemExit):</span>
                    <span class="s1">sys.stderr.write(</span><span class="s3">&quot;mainloop: caught unexpected SystemExit!</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s0"># Explicitly break reference cycle.</span>
        <span class="s1">excinfo = </span><span class="s2">None  </span><span class="s0"># type: ignore</span>
        <span class="s1">session.startdir.chdir()</span>
        <span class="s2">if </span><span class="s1">initstate &gt;= </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">config.hook.pytest_sessionfinish(</span>
                    <span class="s1">session=session, exitstatus=session.exitstatus</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">exit.Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">if </span><span class="s1">exc.returncode </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">session.exitstatus = exc.returncode</span>
                <span class="s1">sys.stderr.write(</span><span class="s3">&quot;{}: {}</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">.format(type(exc).__name__, exc))</span>
        <span class="s1">config._ensure_unconfigure()</span>
    <span class="s2">return </span><span class="s1">session.exitstatus</span>


<span class="s2">def </span><span class="s1">pytest_cmdline_main(config: Config) -&gt; Union[int, ExitCode]:</span>
    <span class="s2">return </span><span class="s1">wrap_session(config, _main)</span>


<span class="s2">def </span><span class="s1">_main(config: Config, session: </span><span class="s3">&quot;Session&quot;</span><span class="s1">) -&gt; Optional[Union[int, ExitCode]]:</span>
    <span class="s0">&quot;&quot;&quot;Default command line protocol for initialization, session, 
    running tests and reporting.&quot;&quot;&quot;</span>
    <span class="s1">config.hook.pytest_collection(session=session)</span>
    <span class="s1">config.hook.pytest_runtestloop(session=session)</span>

    <span class="s2">if </span><span class="s1">session.testsfailed:</span>
        <span class="s2">return </span><span class="s1">ExitCode.TESTS_FAILED</span>
    <span class="s2">elif </span><span class="s1">session.testscollected == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">ExitCode.NO_TESTS_COLLECTED</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">pytest_collection(session: </span><span class="s3">&quot;Session&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">session.perform_collect()</span>


<span class="s2">def </span><span class="s1">pytest_runtestloop(session: </span><span class="s3">&quot;Session&quot;</span><span class="s1">) -&gt; bool:</span>
    <span class="s2">if </span><span class="s1">session.testsfailed </span><span class="s2">and not </span><span class="s1">session.config.option.continue_on_collection_errors:</span>
        <span class="s2">raise </span><span class="s1">session.Interrupted(</span>
            <span class="s3">&quot;%d error%s during collection&quot;</span>
            <span class="s1">% (session.testsfailed, </span><span class="s3">&quot;s&quot; </span><span class="s2">if </span><span class="s1">session.testsfailed != </span><span class="s4">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">session.config.option.collectonly:</span>
        <span class="s2">return True</span>

    <span class="s2">for </span><span class="s1">i, item </span><span class="s2">in </span><span class="s1">enumerate(session.items):</span>
        <span class="s1">nextitem = session.items[i + </span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">i + </span><span class="s4">1 </span><span class="s1">&lt; len(session.items) </span><span class="s2">else None</span>
        <span class="s1">item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)</span>
        <span class="s2">if </span><span class="s1">session.shouldfail:</span>
            <span class="s2">raise </span><span class="s1">session.Failed(session.shouldfail)</span>
        <span class="s2">if </span><span class="s1">session.shouldstop:</span>
            <span class="s2">raise </span><span class="s1">session.Interrupted(session.shouldstop)</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">_in_venv(path: py.path.local) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;Attempt to detect if ``path`` is the root of a Virtual Environment by 
    checking for the existence of the appropriate activate script.&quot;&quot;&quot;</span>
    <span class="s1">bindir = path.join(</span><span class="s3">&quot;Scripts&quot; </span><span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">&quot;win&quot;</span><span class="s1">) </span><span class="s2">else </span><span class="s3">&quot;bin&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">bindir.isdir():</span>
        <span class="s2">return False</span>
    <span class="s1">activates = (</span>
        <span class="s3">&quot;activate&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;activate.csh&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;activate.fish&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Activate&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Activate.bat&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Activate.ps1&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">any([fname.basename </span><span class="s2">in </span><span class="s1">activates </span><span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">bindir.listdir()])</span>


<span class="s2">def </span><span class="s1">pytest_ignore_collect(path: py.path.local, config: Config) -&gt; Optional[bool]:</span>
    <span class="s1">ignore_paths = config._getconftest_pathlist(</span><span class="s3">&quot;collect_ignore&quot;</span><span class="s1">, path=path.dirpath())</span>
    <span class="s1">ignore_paths = ignore_paths </span><span class="s2">or </span><span class="s1">[]</span>
    <span class="s1">excludeopt = config.getoption(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">excludeopt:</span>
        <span class="s1">ignore_paths.extend([py.path.local(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">excludeopt])</span>

    <span class="s2">if </span><span class="s1">py.path.local(path) </span><span class="s2">in </span><span class="s1">ignore_paths:</span>
        <span class="s2">return True</span>

    <span class="s1">ignore_globs = config._getconftest_pathlist(</span>
        <span class="s3">&quot;collect_ignore_glob&quot;</span><span class="s1">, path=path.dirpath()</span>
    <span class="s1">)</span>
    <span class="s1">ignore_globs = ignore_globs </span><span class="s2">or </span><span class="s1">[]</span>
    <span class="s1">excludeglobopt = config.getoption(</span><span class="s3">&quot;ignore_glob&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">excludeglobopt:</span>
        <span class="s1">ignore_globs.extend([py.path.local(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">excludeglobopt])</span>

    <span class="s2">if </span><span class="s1">any(fnmatch.fnmatch(str(path), str(glob)) </span><span class="s2">for </span><span class="s1">glob </span><span class="s2">in </span><span class="s1">ignore_globs):</span>
        <span class="s2">return True</span>

    <span class="s1">allow_in_venv = config.getoption(</span><span class="s3">&quot;collect_in_virtualenv&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">allow_in_venv </span><span class="s2">and </span><span class="s1">_in_venv(path):</span>
        <span class="s2">return True</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">pytest_collection_modifyitems(items: List[nodes.Item], config: Config) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">deselect_prefixes = tuple(config.getoption(</span><span class="s3">&quot;deselect&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">[])</span>
    <span class="s2">if not </span><span class="s1">deselect_prefixes:</span>
        <span class="s2">return</span>

    <span class="s1">remaining = []</span>
    <span class="s1">deselected = []</span>
    <span class="s2">for </span><span class="s1">colitem </span><span class="s2">in </span><span class="s1">items:</span>
        <span class="s2">if </span><span class="s1">colitem.nodeid.startswith(deselect_prefixes):</span>
            <span class="s1">deselected.append(colitem)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">remaining.append(colitem)</span>

    <span class="s2">if </span><span class="s1">deselected:</span>
        <span class="s1">config.hook.pytest_deselected(items=deselected)</span>
        <span class="s1">items[:] = remaining</span>


<span class="s2">class </span><span class="s1">FSHookProxy:</span>
    <span class="s2">def </span><span class="s1">__init__(self, pm: PytestPluginManager, remove_mods) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.pm = pm</span>
        <span class="s1">self.remove_mods = remove_mods</span>

    <span class="s2">def </span><span class="s1">__getattr__(self, name: str):</span>
        <span class="s1">x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)</span>
        <span class="s1">self.__dict__[name] = x</span>
        <span class="s2">return </span><span class="s1">x</span>


<span class="s2">class </span><span class="s1">Interrupted(KeyboardInterrupt):</span>
    <span class="s0">&quot;&quot;&quot;Signals that the test run was interrupted.&quot;&quot;&quot;</span>

    <span class="s1">__module__ = </span><span class="s3">&quot;builtins&quot;  </span><span class="s0"># For py3.</span>


<span class="s2">class </span><span class="s1">Failed(Exception):</span>
    <span class="s0">&quot;&quot;&quot;Signals a stop as failed test run.&quot;&quot;&quot;</span>


<span class="s1">@attr.s</span>
<span class="s2">class </span><span class="s1">_bestrelpath_cache(Dict[Path, str]):</span>
    <span class="s1">path = attr.ib(type=Path)</span>

    <span class="s2">def </span><span class="s1">__missing__(self, path: Path) -&gt; str:</span>
        <span class="s1">r = bestrelpath(self.path, path)</span>
        <span class="s1">self[path] = r</span>
        <span class="s2">return </span><span class="s1">r</span>


<span class="s1">@final</span>
<span class="s2">class </span><span class="s1">Session(nodes.FSCollector):</span>
    <span class="s1">Interrupted = Interrupted</span>
    <span class="s1">Failed = Failed</span>
    <span class="s0"># Set on the session by runner.pytest_sessionstart.</span>
    <span class="s1">_setupstate: SetupState</span>
    <span class="s0"># Set on the session by fixtures.pytest_sessionstart.</span>
    <span class="s1">_fixturemanager: FixtureManager</span>
    <span class="s1">exitstatus: Union[int, ExitCode]</span>

    <span class="s2">def </span><span class="s1">__init__(self, config: Config) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">config.rootdir, parent=</span><span class="s2">None</span><span class="s1">, config=config, session=self, nodeid=</span><span class="s3">&quot;&quot;</span>
        <span class="s1">)</span>
        <span class="s1">self.testsfailed = </span><span class="s4">0</span>
        <span class="s1">self.testscollected = </span><span class="s4">0</span>
        <span class="s1">self.shouldstop: Union[bool, str] = </span><span class="s2">False</span>
        <span class="s1">self.shouldfail: Union[bool, str] = </span><span class="s2">False</span>
        <span class="s1">self.trace = config.trace.root.get(</span><span class="s3">&quot;collection&quot;</span><span class="s1">)</span>
        <span class="s1">self.startdir = config.invocation_dir</span>
        <span class="s1">self._initialpaths: FrozenSet[py.path.local] = frozenset()</span>

        <span class="s1">self._bestrelpathcache: Dict[Path, str] = _bestrelpath_cache(config.rootpath)</span>

        <span class="s1">self.config.pluginmanager.register(self, name=</span><span class="s3">&quot;session&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_config(cls, config: Config) -&gt; </span><span class="s3">&quot;Session&quot;</span><span class="s1">:</span>
        <span class="s1">session: Session = cls._create(config)</span>
        <span class="s2">return </span><span class="s1">session</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s %s exitstatus=%r testsfailed=%d testscollected=%d&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__name__,</span>
            <span class="s1">self.name,</span>
            <span class="s1">getattr(self, </span><span class="s3">&quot;exitstatus&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;UNSET&gt;&quot;</span><span class="s1">),</span>
            <span class="s1">self.testsfailed,</span>
            <span class="s1">self.testscollected,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_node_location_to_relpath(self, node_path: Path) -&gt; str:</span>
        <span class="s0"># bestrelpath is a quite slow function.</span>
        <span class="s2">return </span><span class="s1">self._bestrelpathcache[node_path]</span>

    <span class="s1">@hookimpl(tryfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_collectstart(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.shouldfail:</span>
            <span class="s2">raise </span><span class="s1">self.Failed(self.shouldfail)</span>
        <span class="s2">if </span><span class="s1">self.shouldstop:</span>
            <span class="s2">raise </span><span class="s1">self.Interrupted(self.shouldstop)</span>

    <span class="s1">@hookimpl(tryfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_runtest_logreport(</span>
        <span class="s1">self, report: Union[TestReport, CollectReport]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">report.failed </span><span class="s2">and not </span><span class="s1">hasattr(report, </span><span class="s3">&quot;wasxfail&quot;</span><span class="s1">):</span>
            <span class="s1">self.testsfailed += </span><span class="s4">1</span>
            <span class="s1">maxfail = self.config.getvalue(</span><span class="s3">&quot;maxfail&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">maxfail </span><span class="s2">and </span><span class="s1">self.testsfailed &gt;= maxfail:</span>
                <span class="s1">self.shouldfail = </span><span class="s3">&quot;stopping after %d failures&quot; </span><span class="s1">% (self.testsfailed)</span>

    <span class="s1">pytest_collectreport = pytest_runtest_logreport</span>

    <span class="s2">def </span><span class="s1">isinitpath(self, path: py.path.local) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self._initialpaths</span>

    <span class="s2">def </span><span class="s1">gethookproxy(self, fspath: py.path.local):</span>
        <span class="s0"># Check if we have the common case of running</span>
        <span class="s0"># hooks with all conftest.py files.</span>
        <span class="s1">pm = self.config.pluginmanager</span>
        <span class="s1">my_conftestmodules = pm._getconftestmodules(</span>
            <span class="s1">fspath, self.config.getoption(</span><span class="s3">&quot;importmode&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">remove_mods = pm._conftest_plugins.difference(my_conftestmodules)</span>
        <span class="s2">if </span><span class="s1">remove_mods:</span>
            <span class="s0"># One or more conftests are not in use at this fspath.</span>
            <span class="s1">proxy = FSHookProxy(pm, remove_mods)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># All plugins are active for this fspath.</span>
            <span class="s1">proxy = self.config.hook</span>
        <span class="s2">return </span><span class="s1">proxy</span>

    <span class="s2">def </span><span class="s1">_recurse(self, direntry: </span><span class="s3">&quot;os.DirEntry[str]&quot;</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">direntry.name == </span><span class="s3">&quot;__pycache__&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s1">path = py.path.local(direntry.path)</span>
        <span class="s1">ihook = self.gethookproxy(path.dirpath())</span>
        <span class="s2">if </span><span class="s1">ihook.pytest_ignore_collect(path=path, config=self.config):</span>
            <span class="s2">return False</span>
        <span class="s1">norecursepatterns = self.config.getini(</span><span class="s3">&quot;norecursedirs&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">any(path.check(fnmatch=pat) </span><span class="s2">for </span><span class="s1">pat </span><span class="s2">in </span><span class="s1">norecursepatterns):</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_collectfile(</span>
        <span class="s1">self, path: py.path.local, handle_dupes: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; Sequence[nodes.Collector]:</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">path.isfile()</span>
        <span class="s1">), </span><span class="s3">&quot;{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">path, path.isdir(), path.exists(), path.islink()</span>
        <span class="s1">)</span>
        <span class="s1">ihook = self.gethookproxy(path)</span>
        <span class="s2">if not </span><span class="s1">self.isinitpath(path):</span>
            <span class="s2">if </span><span class="s1">ihook.pytest_ignore_collect(path=path, config=self.config):</span>
                <span class="s2">return </span><span class="s1">()</span>

        <span class="s2">if </span><span class="s1">handle_dupes:</span>
            <span class="s1">keepduplicates = self.config.getoption(</span><span class="s3">&quot;keepduplicates&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">keepduplicates:</span>
                <span class="s1">duplicate_paths = self.config.pluginmanager._duplicatepaths</span>
                <span class="s2">if </span><span class="s1">path </span><span class="s2">in </span><span class="s1">duplicate_paths:</span>
                    <span class="s2">return </span><span class="s1">()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">duplicate_paths.add(path)</span>

        <span class="s2">return </span><span class="s1">ihook.pytest_collect_file(path=path, parent=self)  </span><span class="s0"># type: ignore[no-any-return]</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">perform_collect(</span>
        <span class="s1">self, args: Optional[Sequence[str]] = ..., genitems: </span><span class="s3">&quot;Literal[True]&quot; </span><span class="s1">= ...</span>
    <span class="s1">) -&gt; Sequence[nodes.Item]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s2">def </span><span class="s1">perform_collect(</span>
        <span class="s1">self, args: Optional[Sequence[str]] = ..., genitems: bool = ...</span>
    <span class="s1">) -&gt; Sequence[Union[nodes.Item, nodes.Collector]]:</span>
        <span class="s1">...</span>

    <span class="s2">def </span><span class="s1">perform_collect(</span>
        <span class="s1">self, args: Optional[Sequence[str]] = </span><span class="s2">None</span><span class="s1">, genitems: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; Sequence[Union[nodes.Item, nodes.Collector]]:</span>
        <span class="s0">&quot;&quot;&quot;Perform the collection phase for this session. 
 
        This is called by the default 
        :func:`pytest_collection &lt;_pytest.hookspec.pytest_collection&gt;` hook 
        implementation; see the documentation of this hook for more details. 
        For testing purposes, it may also be called directly on a fresh 
        ``Session``. 
 
        This function normally recursively expands any collectors collected 
        from the session to their items, and only items are returned. For 
        testing purposes, this may be suppressed by passing ``genitems=False``, 
        in which case the return value contains these collectors unexpanded, 
        and ``session.items`` is empty. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">args = self.config.args</span>

        <span class="s1">self.trace(</span><span class="s3">&quot;perform_collect&quot;</span><span class="s1">, self, args)</span>
        <span class="s1">self.trace.root.indent += </span><span class="s4">1</span>

        <span class="s1">self._notfound: List[Tuple[str, Sequence[nodes.Collector]]] = []</span>
        <span class="s1">self._initial_parts: List[Tuple[py.path.local, List[str]]] = []</span>
        <span class="s1">self.items: List[nodes.Item] = []</span>

        <span class="s1">hook = self.config.hook</span>

        <span class="s1">items: Sequence[Union[nodes.Item, nodes.Collector]] = self.items</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">initialpaths: List[py.path.local] = []</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
                <span class="s1">fspath, parts = resolve_collection_argument(</span>
                    <span class="s1">self.config.invocation_params.dir,</span>
                    <span class="s1">arg,</span>
                    <span class="s1">as_pypath=self.config.option.pyargs,</span>
                <span class="s1">)</span>
                <span class="s1">self._initial_parts.append((fspath, parts))</span>
                <span class="s1">initialpaths.append(fspath)</span>
            <span class="s1">self._initialpaths = frozenset(initialpaths)</span>
            <span class="s1">rep = collect_one_node(self)</span>
            <span class="s1">self.ihook.pytest_collectreport(report=rep)</span>
            <span class="s1">self.trace.root.indent -= </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">self._notfound:</span>
                <span class="s1">errors = []</span>
                <span class="s2">for </span><span class="s1">arg, cols </span><span class="s2">in </span><span class="s1">self._notfound:</span>
                    <span class="s1">line = </span><span class="s3">f&quot;(no name </span><span class="s5">{</span><span class="s1">arg</span><span class="s5">!r} </span><span class="s3">in any of </span><span class="s5">{</span><span class="s1">cols</span><span class="s5">!r}</span><span class="s3">)&quot;</span>
                    <span class="s1">errors.append(</span><span class="s3">f&quot;not found: </span><span class="s5">{</span><span class="s1">arg</span><span class="s5">}\n{</span><span class="s1">line</span><span class="s5">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">UsageError(*errors)</span>
            <span class="s2">if not </span><span class="s1">genitems:</span>
                <span class="s1">items = rep.result</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">rep.passed:</span>
                    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">rep.result:</span>
                        <span class="s1">self.items.extend(self.genitems(node))</span>

            <span class="s1">self.config.pluginmanager.check_pending()</span>
            <span class="s1">hook.pytest_collection_modifyitems(</span>
                <span class="s1">session=self, config=self.config, items=items</span>
            <span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">hook.pytest_collection_finish(session=self)</span>

        <span class="s1">self.testscollected = len(items)</span>
        <span class="s2">return </span><span class="s1">items</span>

    <span class="s2">def </span><span class="s1">collect(self) -&gt; Iterator[Union[nodes.Item, nodes.Collector]]:</span>
        <span class="s2">from </span><span class="s1">_pytest.python </span><span class="s2">import </span><span class="s1">Package</span>

        <span class="s0"># Keep track of any collected nodes in here, so we don't duplicate fixtures.</span>
        <span class="s1">node_cache1: Dict[py.path.local, Sequence[nodes.Collector]] = {}</span>
        <span class="s1">node_cache2: Dict[</span>
            <span class="s1">Tuple[Type[nodes.Collector], py.path.local], nodes.Collector</span>
        <span class="s1">] = ({})</span>

        <span class="s0"># Keep track of any collected collectors in matchnodes paths, so they</span>
        <span class="s0"># are not collected more than once.</span>
        <span class="s1">matchnodes_cache: Dict[Tuple[Type[nodes.Collector], str], CollectReport] = ({})</span>

        <span class="s0"># Dirnames of pkgs with dunder-init files.</span>
        <span class="s1">pkg_roots: Dict[str, Package] = {}</span>

        <span class="s2">for </span><span class="s1">argpath, names </span><span class="s2">in </span><span class="s1">self._initial_parts:</span>
            <span class="s1">self.trace(</span><span class="s3">&quot;processing argument&quot;</span><span class="s1">, (argpath, names))</span>
            <span class="s1">self.trace.root.indent += </span><span class="s4">1</span>

            <span class="s0"># Start with a Session root, and delve to argpath item (dir or file)</span>
            <span class="s0"># and stack all Packages found on the way.</span>
            <span class="s0"># No point in finding packages when collecting doctests.</span>
            <span class="s2">if not </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;doctestmodules&quot;</span><span class="s1">, </span><span class="s2">False</span><span class="s1">):</span>
                <span class="s1">pm = self.config.pluginmanager</span>
                <span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">reversed(argpath.parts()):</span>
                    <span class="s2">if </span><span class="s1">pm._confcutdir </span><span class="s2">and </span><span class="s1">pm._confcutdir.relto(parent):</span>
                        <span class="s2">break</span>

                    <span class="s2">if </span><span class="s1">parent.isdir():</span>
                        <span class="s1">pkginit = parent.join(</span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">pkginit.isfile() </span><span class="s2">and </span><span class="s1">pkginit </span><span class="s2">not in </span><span class="s1">node_cache1:</span>
                            <span class="s1">col = self._collectfile(pkginit, handle_dupes=</span><span class="s2">False</span><span class="s1">)</span>
                            <span class="s2">if </span><span class="s1">col:</span>
                                <span class="s2">if </span><span class="s1">isinstance(col[</span><span class="s4">0</span><span class="s1">], Package):</span>
                                    <span class="s1">pkg_roots[str(parent)] = col[</span><span class="s4">0</span><span class="s1">]</span>
                                <span class="s1">node_cache1[col[</span><span class="s4">0</span><span class="s1">].fspath] = [col[</span><span class="s4">0</span><span class="s1">]]</span>

            <span class="s0"># If it's a directory argument, recurse and look for any Subpackages.</span>
            <span class="s0"># Let the Package collector deal with subnodes, don't collect here.</span>
            <span class="s2">if </span><span class="s1">argpath.check(dir=</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s2">assert not </span><span class="s1">names, </span><span class="s3">&quot;invalid arg {!r}&quot;</span><span class="s1">.format((argpath, names))</span>

                <span class="s1">seen_dirs: Set[py.path.local] = set()</span>
                <span class="s2">for </span><span class="s1">direntry </span><span class="s2">in </span><span class="s1">visit(str(argpath), self._recurse):</span>
                    <span class="s2">if not </span><span class="s1">direntry.is_file():</span>
                        <span class="s2">continue</span>

                    <span class="s1">path = py.path.local(direntry.path)</span>
                    <span class="s1">dirpath = path.dirpath()</span>

                    <span class="s2">if </span><span class="s1">dirpath </span><span class="s2">not in </span><span class="s1">seen_dirs:</span>
                        <span class="s0"># Collect packages first.</span>
                        <span class="s1">seen_dirs.add(dirpath)</span>
                        <span class="s1">pkginit = dirpath.join(</span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">pkginit.exists():</span>
                            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._collectfile(pkginit):</span>
                                <span class="s2">yield </span><span class="s1">x</span>
                                <span class="s2">if </span><span class="s1">isinstance(x, Package):</span>
                                    <span class="s1">pkg_roots[str(dirpath)] = x</span>
                    <span class="s2">if </span><span class="s1">str(dirpath) </span><span class="s2">in </span><span class="s1">pkg_roots:</span>
                        <span class="s0"># Do not collect packages here.</span>
                        <span class="s2">continue</span>

                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._collectfile(path):</span>
                        <span class="s1">key = (type(x), x.fspath)</span>
                        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">node_cache2:</span>
                            <span class="s2">yield </span><span class="s1">node_cache2[key]</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">node_cache2[key] = x</span>
                            <span class="s2">yield </span><span class="s1">x</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">argpath.check(file=</span><span class="s4">1</span><span class="s1">)</span>

                <span class="s2">if </span><span class="s1">argpath </span><span class="s2">in </span><span class="s1">node_cache1:</span>
                    <span class="s1">col = node_cache1[argpath]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">collect_root = pkg_roots.get(argpath.dirname, self)</span>
                    <span class="s1">col = collect_root._collectfile(argpath, handle_dupes=</span><span class="s2">False</span><span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">col:</span>
                        <span class="s1">node_cache1[argpath] = col</span>

                <span class="s1">matching = []</span>
                <span class="s1">work: List[</span>
                    <span class="s1">Tuple[Sequence[Union[nodes.Item, nodes.Collector]], Sequence[str]]</span>
                <span class="s1">] = [(col, names)]</span>
                <span class="s2">while </span><span class="s1">work:</span>
                    <span class="s1">self.trace(</span><span class="s3">&quot;matchnodes&quot;</span><span class="s1">, col, names)</span>
                    <span class="s1">self.trace.root.indent += </span><span class="s4">1</span>

                    <span class="s1">matchnodes, matchnames = work.pop()</span>
                    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">matchnodes:</span>
                        <span class="s2">if not </span><span class="s1">matchnames:</span>
                            <span class="s1">matching.append(node)</span>
                            <span class="s2">continue</span>
                        <span class="s2">if not </span><span class="s1">isinstance(node, nodes.Collector):</span>
                            <span class="s2">continue</span>
                        <span class="s1">key = (type(node), node.nodeid)</span>
                        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">matchnodes_cache:</span>
                            <span class="s1">rep = matchnodes_cache[key]</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">rep = collect_one_node(node)</span>
                            <span class="s1">matchnodes_cache[key] = rep</span>
                        <span class="s2">if </span><span class="s1">rep.passed:</span>
                            <span class="s1">submatchnodes = []</span>
                            <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">rep.result:</span>
                                <span class="s0"># TODO: Remove parametrized workaround once collection structure contains</span>
                                <span class="s0"># parametrization.</span>
                                <span class="s2">if </span><span class="s1">(</span>
                                    <span class="s1">r.name == matchnames[</span><span class="s4">0</span><span class="s1">]</span>
                                    <span class="s2">or </span><span class="s1">r.name.split(</span><span class="s3">&quot;[&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] == matchnames[</span><span class="s4">0</span><span class="s1">]</span>
                                <span class="s1">):</span>
                                    <span class="s1">submatchnodes.append(r)</span>
                            <span class="s2">if </span><span class="s1">submatchnodes:</span>
                                <span class="s1">work.append((submatchnodes, matchnames[</span><span class="s4">1</span><span class="s1">:]))</span>
                            <span class="s0"># XXX Accept IDs that don't have &quot;()&quot; for class instances.</span>
                            <span class="s2">elif </span><span class="s1">len(rep.result) == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">rep.result[</span><span class="s4">0</span><span class="s1">].name == </span><span class="s3">&quot;()&quot;</span><span class="s1">:</span>
                                <span class="s1">work.append((rep.result, matchnames))</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s0"># Report collection failures here to avoid failing to run some test</span>
                            <span class="s0"># specified in the command line because the module could not be</span>
                            <span class="s0"># imported (#134).</span>
                            <span class="s1">node.ihook.pytest_collectreport(report=rep)</span>

                    <span class="s1">self.trace(</span><span class="s3">&quot;matchnodes finished -&gt; &quot;</span><span class="s1">, len(matching), </span><span class="s3">&quot;nodes&quot;</span><span class="s1">)</span>
                    <span class="s1">self.trace.root.indent -= </span><span class="s4">1</span>

                <span class="s2">if not </span><span class="s1">matching:</span>
                    <span class="s1">report_arg = </span><span class="s3">&quot;::&quot;</span><span class="s1">.join((str(argpath), *names))</span>
                    <span class="s1">self._notfound.append((report_arg, col))</span>
                    <span class="s2">continue</span>

                <span class="s0"># If __init__.py was the only file requested, then the matched</span>
                <span class="s0"># node will be the corresponding Package (by default), and the</span>
                <span class="s0"># first yielded item will be the __init__ Module itself, so</span>
                <span class="s0"># just use that. If this special case isn't taken, then all the</span>
                <span class="s0"># files in the package will be yielded.</span>
                <span class="s2">if </span><span class="s1">argpath.basename == </span><span class="s3">&quot;__init__.py&quot; </span><span class="s2">and </span><span class="s1">isinstance(</span>
                    <span class="s1">matching[</span><span class="s4">0</span><span class="s1">], Package</span>
                <span class="s1">):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s2">yield </span><span class="s1">next(iter(matching[</span><span class="s4">0</span><span class="s1">].collect()))</span>
                    <span class="s2">except </span><span class="s1">StopIteration:</span>
                        <span class="s0"># The package collects nothing with only an __init__.py</span>
                        <span class="s0"># file in it, which gets ignored by the default</span>
                        <span class="s0"># &quot;python_files&quot; option.</span>
                        <span class="s2">pass</span>
                    <span class="s2">continue</span>

                <span class="s2">yield from </span><span class="s1">matching</span>

            <span class="s1">self.trace.root.indent -= </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">genitems(</span>
        <span class="s1">self, node: Union[nodes.Item, nodes.Collector]</span>
    <span class="s1">) -&gt; Iterator[nodes.Item]:</span>
        <span class="s1">self.trace(</span><span class="s3">&quot;genitems&quot;</span><span class="s1">, node)</span>
        <span class="s2">if </span><span class="s1">isinstance(node, nodes.Item):</span>
            <span class="s1">node.ihook.pytest_itemcollected(item=node)</span>
            <span class="s2">yield </span><span class="s1">node</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(node, nodes.Collector)</span>
            <span class="s1">rep = collect_one_node(node)</span>
            <span class="s2">if </span><span class="s1">rep.passed:</span>
                <span class="s2">for </span><span class="s1">subnode </span><span class="s2">in </span><span class="s1">rep.result:</span>
                    <span class="s2">yield from </span><span class="s1">self.genitems(subnode)</span>
            <span class="s1">node.ihook.pytest_collectreport(report=rep)</span>


<span class="s2">def </span><span class="s1">search_pypath(module_name: str) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Search sys.path for the given a dotted module name, and return its file system path.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">spec = importlib.util.find_spec(module_name)</span>
    <span class="s0"># AttributeError: looks like package module, but actually filename</span>
    <span class="s0"># ImportError: module does not exist</span>
    <span class="s0"># ValueError: not a module name</span>
    <span class="s2">except </span><span class="s1">(AttributeError, ImportError, ValueError):</span>
        <span class="s2">return </span><span class="s1">module_name</span>
    <span class="s2">if </span><span class="s1">spec </span><span class="s2">is None or </span><span class="s1">spec.origin </span><span class="s2">is None or </span><span class="s1">spec.origin == </span><span class="s3">&quot;namespace&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">module_name</span>
    <span class="s2">elif </span><span class="s1">spec.submodule_search_locations:</span>
        <span class="s2">return </span><span class="s1">os.path.dirname(spec.origin)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">spec.origin</span>


<span class="s2">def </span><span class="s1">resolve_collection_argument(</span>
    <span class="s1">invocation_path: Path, arg: str, *, as_pypath: bool = </span><span class="s2">False</span>
<span class="s1">) -&gt; Tuple[py.path.local, List[str]]:</span>
    <span class="s0">&quot;&quot;&quot;Parse path arguments optionally containing selection parts and return (fspath, names). 
 
    Command-line arguments can point to files and/or directories, and optionally contain 
    parts for specific tests selection, for example: 
 
        &quot;pkg/tests/test_foo.py::TestClass::test_foo&quot; 
 
    This function ensures the path exists, and returns a tuple: 
 
        (py.path.path(&quot;/full/path/to/pkg/tests/test_foo.py&quot;), [&quot;TestClass&quot;, &quot;test_foo&quot;]) 
 
    When as_pypath is True, expects that the command-line argument actually contains 
    module paths instead of file-system paths: 
 
        &quot;pkg.tests.test_foo::TestClass::test_foo&quot; 
 
    In which case we search sys.path for a matching module, and then return the *path* to the 
    found module. 
 
    If the path doesn't exist, raise UsageError. 
    If the path is a directory and selection parts are present, raise UsageError. 
    &quot;&quot;&quot;</span>
    <span class="s1">strpath, *parts = str(arg).split(</span><span class="s3">&quot;::&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">as_pypath:</span>
        <span class="s1">strpath = search_pypath(strpath)</span>
    <span class="s1">fspath = invocation_path / strpath</span>
    <span class="s1">fspath = absolutepath(fspath)</span>
    <span class="s2">if not </span><span class="s1">fspath.exists():</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;module or package not found: {arg} (missing __init__.py?)&quot;</span>
            <span class="s2">if </span><span class="s1">as_pypath</span>
            <span class="s2">else </span><span class="s3">&quot;file or directory not found: {arg}&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">UsageError(msg.format(arg=arg))</span>
    <span class="s2">if </span><span class="s1">parts </span><span class="s2">and </span><span class="s1">fspath.is_dir():</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;package argument cannot contain :: selection parts: {arg}&quot;</span>
            <span class="s2">if </span><span class="s1">as_pypath</span>
            <span class="s2">else </span><span class="s3">&quot;directory argument cannot contain :: selection parts: {arg}&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">UsageError(msg.format(arg=arg))</span>
    <span class="s2">return </span><span class="s1">py.path.local(str(fspath)), parts</span>
</pre>
</body>
</html>