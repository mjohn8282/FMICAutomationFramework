<html>
<head>
<title>pipreqs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pipreqs.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python</span>
<span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0">&quot;&quot;&quot;pipreqs - Generate pip requirements.txt file based on imports 
 
Usage: 
    pipreqs [options] [&lt;path&gt;] 
 
Arguments: 
    &lt;path&gt;                The path to the directory containing the application 
                          files for which a requirements file should be 
                          generated (defaults to the current working 
                          directory). 
 
Options: 
    --use-local           Use ONLY local package info instead of querying PyPI. 
    --pypi-server &lt;url&gt;   Use custom PyPi server. 
    --proxy &lt;url&gt;         Use Proxy, parameter will be passed to requests 
                          library. You can also just set the environments 
                          parameter in your terminal: 
                          $ export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot; 
                          $ export HTTPS_PROXY=&quot;https://10.10.1.10:1080&quot; 
    --debug               Print debug information. 
    --ignore &lt;dirs&gt;...    Ignore extra directories, each separated by a comma. 
    --no-follow-links     Do not follow symbolic links in the project 
    --encoding &lt;charset&gt;  Use encoding parameter for file open 
    --savepath &lt;file&gt;     Save the list of requirements in the given file 
    --print               Output the list of requirements in the standard 
                          output. 
    --force               Overwrite existing requirements.txt 
    --diff &lt;file&gt;         Compare modules in requirements.txt to project 
                          imports. 
    --clean &lt;file&gt;        Clean up requirements.txt by removing modules 
                          that are not imported in project. 
    --no-pin              Omit version of output packages. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">print_function, absolute_import</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">codecs</span>
<span class="s2">import </span><span class="s1">ast</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">from </span><span class="s1">docopt </span><span class="s2">import </span><span class="s1">docopt</span>
<span class="s2">import </span><span class="s1">requests</span>
<span class="s2">from </span><span class="s1">yarg </span><span class="s2">import </span><span class="s1">json2package</span>
<span class="s2">from </span><span class="s1">yarg.exceptions </span><span class="s2">import </span><span class="s1">HTTPError</span>

<span class="s2">from </span><span class="s1">pipreqs </span><span class="s2">import </span><span class="s1">__version__</span>

<span class="s1">REGEXP = [</span>
    <span class="s1">re.compile(</span><span class="s3">r'^import (.+)$'</span><span class="s1">),</span>
    <span class="s1">re.compile(</span><span class="s3">r'^from ((?!\.+).*?) import (?:.*)$'</span><span class="s1">)</span>
<span class="s1">]</span>

<span class="s2">if </span><span class="s1">sys.version_info[</span><span class="s4">0</span><span class="s1">] &gt; </span><span class="s4">2</span><span class="s1">:</span>
    <span class="s1">open_func = open</span>
    <span class="s1">py2 = </span><span class="s2">False</span>
<span class="s2">else</span><span class="s1">:</span>
    <span class="s1">open_func = codecs.open</span>
    <span class="s1">py2 = </span><span class="s2">True</span>
    <span class="s1">py2_exclude = [</span><span class="s3">&quot;concurrent&quot;</span><span class="s1">, </span><span class="s3">&quot;concurrent.futures&quot;</span><span class="s1">]</span>


<span class="s1">@contextmanager</span>
<span class="s2">def </span><span class="s1">_open(filename=</span><span class="s2">None</span><span class="s1">, mode=</span><span class="s3">'r'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Open a file or ``sys.stdout`` depending on the provided filename. 
 
    Args: 
        filename (str): The path to the file that should be opened. If 
            ``None`` or ``'-'``, ``sys.stdout`` or ``sys.stdin`` is 
            returned depending on the desired mode. Defaults to ``None``. 
        mode (str): The mode that should be used to open the file. 
 
    Yields: 
        A file handle. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">filename </span><span class="s2">or </span><span class="s1">filename == </span><span class="s3">'-'</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">mode </span><span class="s2">or </span><span class="s3">'r' </span><span class="s2">in </span><span class="s1">mode:</span>
            <span class="s1">file = sys.stdin</span>
        <span class="s2">elif </span><span class="s3">'w' </span><span class="s2">in </span><span class="s1">mode:</span>
            <span class="s1">file = sys.stdout</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Invalid mode for file: {}'</span><span class="s1">.format(mode))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">file = open(filename, mode)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">file</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">file </span><span class="s2">not in </span><span class="s1">(sys.stdin, sys.stdout):</span>
            <span class="s1">file.close()</span>


<span class="s2">def </span><span class="s1">get_all_imports(</span>
        <span class="s1">path, encoding=</span><span class="s2">None</span><span class="s1">, extra_ignore_dirs=</span><span class="s2">None</span><span class="s1">, follow_links=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s1">imports = set()</span>
    <span class="s1">raw_imports = set()</span>
    <span class="s1">candidates = []</span>
    <span class="s1">ignore_errors = </span><span class="s2">False</span>
    <span class="s1">ignore_dirs = [</span><span class="s3">&quot;.hg&quot;</span><span class="s1">, </span><span class="s3">&quot;.svn&quot;</span><span class="s1">, </span><span class="s3">&quot;.git&quot;</span><span class="s1">, </span><span class="s3">&quot;.tox&quot;</span><span class="s1">, </span><span class="s3">&quot;__pycache__&quot;</span><span class="s1">, </span><span class="s3">&quot;env&quot;</span><span class="s1">, </span><span class="s3">&quot;venv&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">extra_ignore_dirs:</span>
        <span class="s1">ignore_dirs_parsed = []</span>
        <span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">extra_ignore_dirs:</span>
            <span class="s1">ignore_dirs_parsed.append(os.path.basename(os.path.realpath(e)))</span>
        <span class="s1">ignore_dirs.extend(ignore_dirs_parsed)</span>

    <span class="s1">walk = os.walk(path, followlinks=follow_links)</span>
    <span class="s2">for </span><span class="s1">root, dirs, files </span><span class="s2">in </span><span class="s1">walk:</span>
        <span class="s1">dirs[:] = [d </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dirs </span><span class="s2">if </span><span class="s1">d </span><span class="s2">not in </span><span class="s1">ignore_dirs]</span>

        <span class="s1">candidates.append(os.path.basename(root))</span>
        <span class="s1">files = [fn </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">files </span><span class="s2">if </span><span class="s1">os.path.splitext(fn)[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">&quot;.py&quot;</span><span class="s1">]</span>

        <span class="s1">candidates += [os.path.splitext(fn)[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">files]</span>
        <span class="s2">for </span><span class="s1">file_name </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s1">file_name = os.path.join(root, file_name)</span>
            <span class="s2">with </span><span class="s1">open_func(file_name, </span><span class="s3">&quot;r&quot;</span><span class="s1">, encoding=encoding) </span><span class="s2">as </span><span class="s1">f:</span>
                <span class="s1">contents = f.read()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">tree = ast.parse(contents)</span>
                <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">ast.walk(tree):</span>
                    <span class="s2">if </span><span class="s1">isinstance(node, ast.Import):</span>
                        <span class="s2">for </span><span class="s1">subnode </span><span class="s2">in </span><span class="s1">node.names:</span>
                            <span class="s1">raw_imports.add(subnode.name)</span>
                    <span class="s2">elif </span><span class="s1">isinstance(node, ast.ImportFrom):</span>
                        <span class="s1">raw_imports.add(node.module)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">if </span><span class="s1">ignore_errors:</span>
                    <span class="s1">traceback.print_exc(exc)</span>
                    <span class="s1">logging.warn(</span><span class="s3">&quot;Failed on file: %s&quot; </span><span class="s1">% file_name)</span>
                    <span class="s2">continue</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">logging.error(</span><span class="s3">&quot;Failed on file: %s&quot; </span><span class="s1">% file_name)</span>
                    <span class="s2">raise </span><span class="s1">exc</span>

    <span class="s0"># Clean up imports</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">raw_imports </span><span class="s2">if </span><span class="s1">n]:</span>
        <span class="s0"># Sanity check: Name could have been None if the import</span>
        <span class="s0"># statement was as ``from . import X``</span>
        <span class="s0"># Cleanup: We only want to first part of the import.</span>
        <span class="s0"># Ex: from django.conf --&gt; django.conf. But we only want django</span>
        <span class="s0"># as an import.</span>
        <span class="s1">cleaned_name, _, _ = name.partition(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s1">imports.add(cleaned_name)</span>

    <span class="s1">packages = imports - (set(candidates) &amp; imports)</span>
    <span class="s1">logging.debug(</span><span class="s3">'Found packages: {0}'</span><span class="s1">.format(packages))</span>

    <span class="s2">with </span><span class="s1">open(join(</span><span class="s3">&quot;stdlib&quot;</span><span class="s1">), </span><span class="s3">&quot;r&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">data = {x.strip() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">f}</span>

    <span class="s1">data = {x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data </span><span class="s2">if </span><span class="s1">x </span><span class="s2">not in </span><span class="s1">py2_exclude} </span><span class="s2">if </span><span class="s1">py2 </span><span class="s2">else </span><span class="s1">data</span>
    <span class="s2">return </span><span class="s1">list(packages - data)</span>


<span class="s2">def </span><span class="s1">filter_line(l):</span>
    <span class="s2">return </span><span class="s1">len(l) &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">l[</span><span class="s4">0</span><span class="s1">] != </span><span class="s3">&quot;#&quot;</span>


<span class="s2">def </span><span class="s1">generate_requirements_file(path, imports):</span>
    <span class="s2">with </span><span class="s1">_open(path, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">out_file:</span>
        <span class="s1">logging.debug(</span><span class="s3">'Writing {num} requirements: {imports} to {file}'</span><span class="s1">.format(</span>
            <span class="s1">num=len(imports),</span>
            <span class="s1">file=path,</span>
            <span class="s1">imports=</span><span class="s3">&quot;, &quot;</span><span class="s1">.join([x[</span><span class="s3">'name'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">imports])</span>
        <span class="s1">))</span>
        <span class="s1">fmt = </span><span class="s3">'{name}=={version}'</span>
        <span class="s1">out_file.write(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">.join(</span>
            <span class="s1">fmt.format(**item) </span><span class="s2">if </span><span class="s1">item[</span><span class="s3">'version'</span><span class="s1">] </span><span class="s2">else </span><span class="s3">'{name}'</span><span class="s1">.format(**item)</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">imports) + </span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">output_requirements(imports):</span>
    <span class="s1">generate_requirements_file(</span><span class="s3">'-'</span><span class="s1">, imports)</span>


<span class="s2">def </span><span class="s1">get_imports_info(</span>
        <span class="s1">imports, pypi_server=</span><span class="s3">&quot;https://pypi.python.org/pypi/&quot;</span><span class="s1">, proxy=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">result = []</span>

    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">imports:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">response = requests.get(</span>
                <span class="s3">&quot;{0}{1}/json&quot;</span><span class="s1">.format(pypi_server, item), proxies=proxy)</span>
            <span class="s2">if </span><span class="s1">response.status_code == </span><span class="s4">200</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">hasattr(response.content, </span><span class="s3">'decode'</span><span class="s1">):</span>
                    <span class="s1">data = json2package(response.content.decode())</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">data = json2package(response.content)</span>
            <span class="s2">elif </span><span class="s1">response.status_code &gt;= </span><span class="s4">300</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">HTTPError(status_code=response.status_code,</span>
                                <span class="s1">reason=response.reason)</span>
        <span class="s2">except </span><span class="s1">HTTPError:</span>
            <span class="s1">logging.debug(</span>
                <span class="s3">'Package %s does not exist or network problems'</span><span class="s1">, item)</span>
            <span class="s2">continue</span>
        <span class="s1">result.append({</span><span class="s3">'name'</span><span class="s1">: item, </span><span class="s3">'version'</span><span class="s1">: data.latest_release_id})</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">get_locally_installed_packages(encoding=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">packages = {}</span>
    <span class="s1">ignore = [</span><span class="s3">&quot;tests&quot;</span><span class="s1">, </span><span class="s3">&quot;_tests&quot;</span><span class="s1">, </span><span class="s3">&quot;egg&quot;</span><span class="s1">, </span><span class="s3">&quot;EGG&quot;</span><span class="s1">, </span><span class="s3">&quot;info&quot;</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">sys.path:</span>
        <span class="s2">for </span><span class="s1">root, dirs, files </span><span class="s2">in </span><span class="s1">os.walk(path):</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">files:</span>
                <span class="s2">if </span><span class="s3">&quot;top_level&quot; </span><span class="s2">in </span><span class="s1">item:</span>
                    <span class="s1">item = os.path.join(root, item)</span>
                    <span class="s2">with </span><span class="s1">open_func(item, </span><span class="s3">&quot;r&quot;</span><span class="s1">, encoding=encoding) </span><span class="s2">as </span><span class="s1">f:</span>
                        <span class="s1">package = root.split(os.sep)[-</span><span class="s4">1</span><span class="s1">].split(</span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">package_import = f.read().strip().split(</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
                        <span class="s2">except</span><span class="s1">:  </span><span class="s0"># NOQA</span>
                            <span class="s0"># TODO: What errors do we intend to suppress here?</span>
                            <span class="s2">continue</span>
                        <span class="s2">for </span><span class="s1">i_item </span><span class="s2">in </span><span class="s1">package_import:</span>
                            <span class="s2">if </span><span class="s1">((i_item </span><span class="s2">not in </span><span class="s1">ignore) </span><span class="s2">and</span>
                                    <span class="s1">(package[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">ignore)):</span>
                                <span class="s1">version = </span><span class="s2">None</span>
                                <span class="s2">if </span><span class="s1">len(package) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                                    <span class="s1">version = package[</span><span class="s4">1</span><span class="s1">].replace(</span>
                                        <span class="s3">&quot;.dist&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;.egg&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

                                <span class="s1">packages[i_item] = {</span>
                                    <span class="s3">'version'</span><span class="s1">: version,</span>
                                    <span class="s3">'name'</span><span class="s1">: package[</span><span class="s4">0</span><span class="s1">]</span>
                                <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">packages</span>


<span class="s2">def </span><span class="s1">get_import_local(imports, encoding=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">local = get_locally_installed_packages()</span>
    <span class="s1">result = []</span>
    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">imports:</span>
        <span class="s2">if </span><span class="s1">item.lower() </span><span class="s2">in </span><span class="s1">local:</span>
            <span class="s1">result.append(local[item.lower()])</span>

    <span class="s0"># removing duplicates of package/version</span>
    <span class="s1">result_unique = [</span>
        <span class="s1">dict(t)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">set([</span>
            <span class="s1">tuple(d.items()) </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">result</span>
        <span class="s1">])</span>
    <span class="s1">]</span>

    <span class="s2">return </span><span class="s1">result_unique</span>


<span class="s2">def </span><span class="s1">get_pkg_names(pkgs):</span>
    <span class="s0">&quot;&quot;&quot;Get PyPI package names from a list of imports. 
 
    Args: 
        pkgs (List[str]): List of import names. 
 
    Returns: 
        List[str]: The corresponding PyPI package names. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">result = set()</span>
    <span class="s2">with </span><span class="s1">open(join(</span><span class="s3">&quot;mapping&quot;</span><span class="s1">), </span><span class="s3">&quot;r&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
        <span class="s1">data = dict(x.strip().split(</span><span class="s3">&quot;:&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">f)</span>
    <span class="s2">for </span><span class="s1">pkg </span><span class="s2">in </span><span class="s1">pkgs:</span>
        <span class="s0"># Look up the mapped requirement. If a mapping isn't found,</span>
        <span class="s0"># simply use the package name.</span>
        <span class="s1">result.add(data.get(pkg, pkg))</span>
    <span class="s0"># Return a sorted list for backward compatibility.</span>
    <span class="s2">return </span><span class="s1">sorted(result, key=</span><span class="s2">lambda </span><span class="s1">s: s.lower())</span>


<span class="s2">def </span><span class="s1">get_name_without_alias(name):</span>
    <span class="s2">if </span><span class="s3">&quot;import &quot; </span><span class="s2">in </span><span class="s1">name:</span>
        <span class="s1">match = REGEXP[</span><span class="s4">0</span><span class="s1">].match(name.strip())</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">name = match.groups(</span><span class="s4">0</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">name.partition(</span><span class="s3">' as '</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].partition(</span><span class="s3">'.'</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">].strip()</span>


<span class="s2">def </span><span class="s1">join(f):</span>
    <span class="s2">return </span><span class="s1">os.path.join(os.path.dirname(__file__), f)</span>


<span class="s2">def </span><span class="s1">parse_requirements(file_):</span>
    <span class="s0">&quot;&quot;&quot;Parse a requirements formatted file. 
 
    Traverse a string until a delimiter is detected, then split at said 
    delimiter, get module name by element index, create a dict consisting of 
    module:version, and add dict to list of parsed modules. 
 
    Args: 
        file_: File to parse. 
 
    Raises: 
        OSerror: If there's any issues accessing the file. 
 
    Returns: 
        tuple: The contents of the file, excluding comments. 
    &quot;&quot;&quot;</span>
    <span class="s1">modules = []</span>
    <span class="s0"># For the dependency identifier specification, see</span>
    <span class="s0"># https://www.python.org/dev/peps/pep-0508/#complete-grammar</span>
    <span class="s1">delim = [</span><span class="s3">&quot;&lt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;=&quot;</span><span class="s1">, </span><span class="s3">&quot;!&quot;</span><span class="s1">, </span><span class="s3">&quot;~&quot;</span><span class="s1">]</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">f = open_func(file_, </span><span class="s3">&quot;r&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">OSError:</span>
        <span class="s1">logging.error(</span><span class="s3">&quot;Failed on file: {}&quot;</span><span class="s1">.format(file_))</span>
        <span class="s2">raise</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">data = [x.strip() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">f.readlines() </span><span class="s2">if </span><span class="s1">x != </span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">]</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">f.close()</span>

    <span class="s1">data = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data </span><span class="s2">if </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">].isalpha()]</span>

    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data:</span>
        <span class="s0"># Check for modules w/o a specifier.</span>
        <span class="s2">if not </span><span class="s1">any([y </span><span class="s2">in </span><span class="s1">x </span><span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">delim]):</span>
            <span class="s1">modules.append({</span><span class="s3">&quot;name&quot;</span><span class="s1">: x, </span><span class="s3">&quot;version&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">})</span>
        <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">x:</span>
            <span class="s2">if </span><span class="s1">y </span><span class="s2">in </span><span class="s1">delim:</span>
                <span class="s1">module = x.split(y)</span>
                <span class="s1">module_name = module[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">module_version = module[-</span><span class="s4">1</span><span class="s1">].replace(</span><span class="s3">&quot;=&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">module = {</span><span class="s3">&quot;name&quot;</span><span class="s1">: module_name, </span><span class="s3">&quot;version&quot;</span><span class="s1">: module_version}</span>

                <span class="s2">if </span><span class="s1">module </span><span class="s2">not in </span><span class="s1">modules:</span>
                    <span class="s1">modules.append(module)</span>

                <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">modules</span>


<span class="s2">def </span><span class="s1">compare_modules(file_, imports):</span>
    <span class="s0">&quot;&quot;&quot;Compare modules in a file to imported modules in a project. 
 
    Args: 
        file_ (str): File to parse for modules to be compared. 
        imports (tuple): Modules being imported in the project. 
 
    Returns: 
        tuple: The modules not imported in the project, but do exist in the 
               specified file. 
    &quot;&quot;&quot;</span>
    <span class="s1">modules = parse_requirements(file_)</span>

    <span class="s1">imports = [imports[i][</span><span class="s3">&quot;name&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(imports))]</span>
    <span class="s1">modules = [modules[i][</span><span class="s3">&quot;name&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(modules))]</span>
    <span class="s1">modules_not_imported = set(modules) - set(imports)</span>

    <span class="s2">return </span><span class="s1">modules_not_imported</span>


<span class="s2">def </span><span class="s1">diff(file_, imports):</span>
    <span class="s3">&quot;&quot;&quot;Display the difference between modules in a file and imported modules.&quot;&quot;&quot;  </span><span class="s0"># NOQA</span>
    <span class="s1">modules_not_imported = compare_modules(file_, imports)</span>

    <span class="s1">logging.info(</span>
        <span class="s3">&quot;The following modules are in {} but do not seem to be imported: &quot;</span>
        <span class="s3">&quot;{}&quot;</span><span class="s1">.format(file_, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">modules_not_imported)))</span>


<span class="s2">def </span><span class="s1">clean(file_, imports):</span>
    <span class="s0">&quot;&quot;&quot;Remove modules that aren't imported in project from file.&quot;&quot;&quot;</span>
    <span class="s1">modules_not_imported = compare_modules(file_, imports)</span>
    <span class="s1">re_remove = re.compile(</span><span class="s3">&quot;|&quot;</span><span class="s1">.join(modules_not_imported))</span>
    <span class="s1">to_write = []</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">f = open_func(file_, </span><span class="s3">&quot;r+&quot;</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">OSError:</span>
        <span class="s1">logging.error(</span><span class="s3">&quot;Failed on file: {}&quot;</span><span class="s1">.format(file_))</span>
        <span class="s2">raise</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">f.readlines():</span>
                <span class="s2">if </span><span class="s1">re_remove.match(i) </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">to_write.append(i)</span>
            <span class="s1">f.seek(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">f.truncate()</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">to_write:</span>
                <span class="s1">f.write(i)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">f.close()</span>

    <span class="s1">logging.info(</span><span class="s3">&quot;Successfully cleaned up requirements in &quot; </span><span class="s1">+ file_)</span>


<span class="s2">def </span><span class="s1">init(args):</span>
    <span class="s1">encoding = args.get(</span><span class="s3">'--encoding'</span><span class="s1">)</span>
    <span class="s1">extra_ignore_dirs = args.get(</span><span class="s3">'--ignore'</span><span class="s1">)</span>
    <span class="s1">follow_links = </span><span class="s2">not </span><span class="s1">args.get(</span><span class="s3">'--no-follow-links'</span><span class="s1">)</span>
    <span class="s1">input_path = args[</span><span class="s3">'&lt;path&gt;'</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">input_path </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">input_path = os.path.abspath(os.curdir)</span>

    <span class="s2">if </span><span class="s1">extra_ignore_dirs:</span>
        <span class="s1">extra_ignore_dirs = extra_ignore_dirs.split(</span><span class="s3">','</span><span class="s1">)</span>

    <span class="s1">candidates = get_all_imports(input_path,</span>
                                 <span class="s1">encoding=encoding,</span>
                                 <span class="s1">extra_ignore_dirs=extra_ignore_dirs,</span>
                                 <span class="s1">follow_links=follow_links)</span>
    <span class="s1">candidates = get_pkg_names(candidates)</span>
    <span class="s1">logging.debug(</span><span class="s3">&quot;Found imports: &quot; </span><span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(candidates))</span>
    <span class="s1">pypi_server = </span><span class="s3">&quot;https://pypi.python.org/pypi/&quot;</span>
    <span class="s1">proxy = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--pypi-server&quot;</span><span class="s1">]:</span>
        <span class="s1">pypi_server = args[</span><span class="s3">&quot;--pypi-server&quot;</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--proxy&quot;</span><span class="s1">]:</span>
        <span class="s1">proxy = {</span><span class="s3">'http'</span><span class="s1">: args[</span><span class="s3">&quot;--proxy&quot;</span><span class="s1">], </span><span class="s3">'https'</span><span class="s1">: args[</span><span class="s3">&quot;--proxy&quot;</span><span class="s1">]}</span>

    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--use-local&quot;</span><span class="s1">]:</span>
        <span class="s1">logging.debug(</span>
            <span class="s3">&quot;Getting package information ONLY from local installation.&quot;</span><span class="s1">)</span>
        <span class="s1">imports = get_import_local(candidates, encoding=encoding)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">logging.debug(</span><span class="s3">&quot;Getting packages information from Local/PyPI&quot;</span><span class="s1">)</span>
        <span class="s1">local = get_import_local(candidates, encoding=encoding)</span>
        <span class="s0"># Get packages that were not found locally</span>
        <span class="s1">difference = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">candidates</span>
                      <span class="s2">if </span><span class="s1">x.lower() </span><span class="s2">not in </span><span class="s1">[z[</span><span class="s3">'name'</span><span class="s1">].lower() </span><span class="s2">for </span><span class="s1">z </span><span class="s2">in </span><span class="s1">local]]</span>
        <span class="s1">imports = local + get_imports_info(difference,</span>
                                           <span class="s1">proxy=proxy,</span>
                                           <span class="s1">pypi_server=pypi_server)</span>

    <span class="s1">path = (args[</span><span class="s3">&quot;--savepath&quot;</span><span class="s1">] </span><span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--savepath&quot;</span><span class="s1">] </span><span class="s2">else</span>
            <span class="s1">os.path.join(input_path, </span><span class="s3">&quot;requirements.txt&quot;</span><span class="s1">))</span>

    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--diff&quot;</span><span class="s1">]:</span>
        <span class="s1">diff(args[</span><span class="s3">&quot;--diff&quot;</span><span class="s1">], imports)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--clean&quot;</span><span class="s1">]:</span>
        <span class="s1">clean(args[</span><span class="s3">&quot;--clean&quot;</span><span class="s1">], imports)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">args[</span><span class="s3">&quot;--print&quot;</span><span class="s1">]</span>
            <span class="s2">and not </span><span class="s1">args[</span><span class="s3">&quot;--savepath&quot;</span><span class="s1">]</span>
            <span class="s2">and not </span><span class="s1">args[</span><span class="s3">&quot;--force&quot;</span><span class="s1">]</span>
            <span class="s2">and </span><span class="s1">os.path.exists(path)):</span>
        <span class="s1">logging.warning(</span><span class="s3">&quot;Requirements.txt already exists, &quot;</span>
                        <span class="s3">&quot;use --force to overwrite it&quot;</span><span class="s1">)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">args.get(</span><span class="s3">'--no-pin'</span><span class="s1">):</span>
        <span class="s1">imports = [{</span><span class="s3">'name'</span><span class="s1">: item[</span><span class="s3">&quot;name&quot;</span><span class="s1">], </span><span class="s3">'version'</span><span class="s1">: </span><span class="s3">''</span><span class="s1">} </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">imports]</span>

    <span class="s2">if </span><span class="s1">args[</span><span class="s3">&quot;--print&quot;</span><span class="s1">]:</span>
        <span class="s1">output_requirements(imports)</span>
        <span class="s1">logging.info(</span><span class="s3">&quot;Successfully output requirements&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">generate_requirements_file(path, imports)</span>
        <span class="s1">logging.info(</span><span class="s3">&quot;Successfully saved requirements file in &quot; </span><span class="s1">+ path)</span>


<span class="s2">def </span><span class="s1">main():  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">args = docopt(__doc__, version=__version__)</span>
    <span class="s1">log_level = logging.DEBUG </span><span class="s2">if </span><span class="s1">args[</span><span class="s3">'--debug'</span><span class="s1">] </span><span class="s2">else </span><span class="s1">logging.INFO</span>
    <span class="s1">logging.basicConfig(level=log_level, format=</span><span class="s3">'%(levelname)s: %(message)s'</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">init(args)</span>
    <span class="s2">except </span><span class="s1">KeyboardInterrupt:</span>
        <span class="s1">sys.exit(</span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s1">main()  </span><span class="s0"># pragma: no cover</span>
</pre>
</body>
</html>