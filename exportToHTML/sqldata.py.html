<html>
<head>
<title>sqldata.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #d19a66;}
.s4 { color: #98c379;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sqldata.py</font>
</center></td></tr></table>
<pre><span class="s0"># Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0"># For details: https://github.com/nedbat/coveragepy/blob/master/NOTICE.txt</span>

<span class="s0">&quot;&quot;&quot;Sqlite coverage data.&quot;&quot;&quot;</span>

<span class="s0"># TODO: factor out dataop debugging to a wrapper class?</span>
<span class="s0"># TODO: make sure all dataop debugging is in place somehow</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">glob</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sqlite3</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">zlib</span>

<span class="s2">from </span><span class="s1">coverage </span><span class="s2">import </span><span class="s1">env</span>
<span class="s2">from </span><span class="s1">coverage.backward </span><span class="s2">import </span><span class="s1">get_thread_id, iitems, to_bytes, to_string</span>
<span class="s2">from </span><span class="s1">coverage.debug </span><span class="s2">import </span><span class="s1">NoDebugging, SimpleReprMixin, clipped_repr</span>
<span class="s2">from </span><span class="s1">coverage.files </span><span class="s2">import </span><span class="s1">PathAliases</span>
<span class="s2">from </span><span class="s1">coverage.misc </span><span class="s2">import </span><span class="s1">CoverageException, contract, file_be_gone, filename_suffix, isolate_module</span>
<span class="s2">from </span><span class="s1">coverage.numbits </span><span class="s2">import </span><span class="s1">numbits_to_nums, numbits_union, nums_to_numbits</span>
<span class="s2">from </span><span class="s1">coverage.version </span><span class="s2">import </span><span class="s1">__version__</span>

<span class="s1">os = isolate_module(os)</span>

<span class="s0"># If you change the schema, increment the SCHEMA_VERSION, and update the</span>
<span class="s0"># docs in docs/dbschema.rst also.</span>

<span class="s1">SCHEMA_VERSION = </span><span class="s3">7</span>

<span class="s0"># Schema versions:</span>
<span class="s0"># 1: Released in 5.0a2</span>
<span class="s0"># 2: Added contexts in 5.0a3.</span>
<span class="s0"># 3: Replaced line table with line_map table.</span>
<span class="s0"># 4: Changed line_map.bitmap to line_map.numbits.</span>
<span class="s0"># 5: Added foreign key declarations.</span>
<span class="s0"># 6: Key-value in meta.</span>
<span class="s0"># 7: line_map -&gt; line_bits</span>

<span class="s1">SCHEMA = </span><span class="s4">&quot;&quot;&quot;</span><span class="s5">\ 
</span><span class="s4">CREATE TABLE coverage_schema ( 
    -- One row, to record the version of the schema in this db. 
    version integer 
); 
 
CREATE TABLE meta ( 
    -- Key-value pairs, to record metadata about the data 
    key text, 
    value text, 
    unique (key) 
    -- Keys: 
    --  'has_arcs' boolean      -- Is this data recording branches? 
    --  'sys_argv' text         -- The coverage command line that recorded the data. 
    --  'version' text          -- The version of coverage.py that made the file. 
    --  'when' text             -- Datetime when the file was created. 
); 
 
CREATE TABLE file ( 
    -- A row per file measured. 
    id integer primary key, 
    path text, 
    unique (path) 
); 
 
CREATE TABLE context ( 
    -- A row per context measured. 
    id integer primary key, 
    context text, 
    unique (context) 
); 
 
CREATE TABLE line_bits ( 
    -- If recording lines, a row per context per file executed. 
    -- All of the line numbers for that file/context are in one numbits. 
    file_id integer,            -- foreign key to `file`. 
    context_id integer,         -- foreign key to `context`. 
    numbits blob,               -- see the numbits functions in coverage.numbits 
    foreign key (file_id) references file (id), 
    foreign key (context_id) references context (id), 
    unique (file_id, context_id) 
); 
 
CREATE TABLE arc ( 
    -- If recording branches, a row per context per from/to line transition executed. 
    file_id integer,            -- foreign key to `file`. 
    context_id integer,         -- foreign key to `context`. 
    fromno integer,             -- line number jumped from. 
    tono integer,               -- line number jumped to. 
    foreign key (file_id) references file (id), 
    foreign key (context_id) references context (id), 
    unique (file_id, context_id, fromno, tono) 
); 
 
CREATE TABLE tracer ( 
    -- A row per file indicating the tracer used for that file. 
    file_id integer primary key, 
    tracer text, 
    foreign key (file_id) references file (id) 
); 
&quot;&quot;&quot;</span>

<span class="s2">class </span><span class="s1">CoverageData(SimpleReprMixin):</span>
    <span class="s0">&quot;&quot;&quot;Manages collected coverage data, including file storage. 
 
    This class is the public supported API to the data that coverage.py 
    collects during program execution.  It includes information about what code 
    was executed. It does not include information from the analysis phase, to 
    determine what lines could have been executed, or what lines were not 
    executed. 
 
    .. note:: 
 
        The data file is currently a SQLite database file, with a 
        :ref:`documented schema &lt;dbschema&gt;`. The schema is subject to change 
        though, so be careful about querying it directly. Use this API if you 
        can to isolate yourself from changes. 
 
    There are a number of kinds of data that can be collected: 
 
    * **lines**: the line numbers of source lines that were executed. 
      These are always available. 
 
    * **arcs**: pairs of source and destination line numbers for transitions 
      between source lines.  These are only available if branch coverage was 
      used. 
 
    * **file tracer names**: the module names of the file tracer plugins that 
      handled each file in the data. 
 
    Lines, arcs, and file tracer names are stored for each source file. File 
    names in this API are case-sensitive, even on platforms with 
    case-insensitive file systems. 
 
    A data file either stores lines, or arcs, but not both. 
 
    A data file is associated with the data when the :class:`CoverageData` 
    is created, using the parameters `basename`, `suffix`, and `no_disk`. The 
    base name can be queried with :meth:`base_filename`, and the actual file 
    name being used is available from :meth:`data_filename`. 
 
    To read an existing coverage.py data file, use :meth:`read`.  You can then 
    access the line, arc, or file tracer data with :meth:`lines`, :meth:`arcs`, 
    or :meth:`file_tracer`. 
 
    The :meth:`has_arcs` method indicates whether arc data is available.  You 
    can get a set of the files in the data with :meth:`measured_files`.  As 
    with most Python containers, you can determine if there is any data at all 
    by using this object as a boolean value. 
 
    The contexts for each line in a file can be read with 
    :meth:`contexts_by_lineno`. 
 
    To limit querying to certain contexts, use :meth:`set_query_context` or 
    :meth:`set_query_contexts`. These will narrow the focus of subsequent 
    :meth:`lines`, :meth:`arcs`, and :meth:`contexts_by_lineno` calls. The set 
    of all measured context names can be retrieved with 
    :meth:`measured_contexts`. 
 
    Most data files will be created by coverage.py itself, but you can use 
    methods here to create data files if you like.  The :meth:`add_lines`, 
    :meth:`add_arcs`, and :meth:`add_file_tracers` methods add data, in ways 
    that are convenient for coverage.py. 
 
    To record data for contexts, use :meth:`set_context` to set a context to 
    be used for subsequent :meth:`add_lines` and :meth:`add_arcs` calls. 
 
    To add a source file without any measured data, use :meth:`touch_file`, 
    or :meth:`touch_files` for a list of such files. 
 
    Write the data to its file with :meth:`write`. 
 
    You can clear the data in memory with :meth:`erase`.  Two data collections 
    can be combined by using :meth:`update` on one :class:`CoverageData`, 
    passing it the other. 
 
    Data in a :class:`CoverageData` can be serialized and deserialized with 
    :meth:`dumps` and :meth:`loads`. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, basename=</span><span class="s2">None</span><span class="s1">, suffix=</span><span class="s2">None</span><span class="s1">, no_disk=</span><span class="s2">False</span><span class="s1">, warn=</span><span class="s2">None</span><span class="s1">, debug=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a :class:`CoverageData` object to hold coverage-measured data. 
 
        Arguments: 
            basename (str): the base name of the data file, defaulting to 
                &quot;.coverage&quot;. 
            suffix (str or bool): has the same meaning as the `data_suffix` 
                argument to :class:`coverage.Coverage`. 
            no_disk (bool): if True, keep all data in memory, and don't 
                write any disk file. 
            warn: a warning callback function, accepting a warning message 
                argument. 
            debug: a `DebugControl` object (optional) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._no_disk = no_disk</span>
        <span class="s1">self._basename = os.path.abspath(basename </span><span class="s2">or </span><span class="s4">&quot;.coverage&quot;</span><span class="s1">)</span>
        <span class="s1">self._suffix = suffix</span>
        <span class="s1">self._warn = warn</span>
        <span class="s1">self._debug = debug </span><span class="s2">or </span><span class="s1">NoDebugging()</span>

        <span class="s1">self._choose_filename()</span>
        <span class="s1">self._file_map = {}</span>
        <span class="s0"># Maps thread ids to SqliteDb objects.</span>
        <span class="s1">self._dbs = {}</span>
        <span class="s1">self._pid = os.getpid()</span>

        <span class="s0"># Are we in sync with the data file?</span>
        <span class="s1">self._have_used = </span><span class="s2">False</span>

        <span class="s1">self._has_lines = </span><span class="s2">False</span>
        <span class="s1">self._has_arcs = </span><span class="s2">False</span>

        <span class="s1">self._current_context = </span><span class="s2">None</span>
        <span class="s1">self._current_context_id = </span><span class="s2">None</span>
        <span class="s1">self._query_context_ids = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_choose_filename(self):</span>
        <span class="s0">&quot;&quot;&quot;Set self._filename based on inited attributes.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._no_disk:</span>
            <span class="s1">self._filename = </span><span class="s4">&quot;:memory:&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._filename = self._basename</span>
            <span class="s1">suffix = filename_suffix(self._suffix)</span>
            <span class="s2">if </span><span class="s1">suffix:</span>
                <span class="s1">self._filename += </span><span class="s4">&quot;.&quot; </span><span class="s1">+ suffix</span>

    <span class="s2">def </span><span class="s1">_reset(self):</span>
        <span class="s0">&quot;&quot;&quot;Reset our attributes.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._dbs:</span>
            <span class="s2">for </span><span class="s1">db </span><span class="s2">in </span><span class="s1">self._dbs.values():</span>
                <span class="s1">db.close()</span>
        <span class="s1">self._dbs = {}</span>
        <span class="s1">self._file_map = {}</span>
        <span class="s1">self._have_used = </span><span class="s2">False</span>
        <span class="s1">self._current_context_id = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_create_db(self):</span>
        <span class="s0">&quot;&quot;&quot;Create a db file that doesn't exist yet. 
 
        Initializes the schema and certain metadata. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Creating data file {!r}&quot;</span><span class="s1">.format(self._filename))</span>
        <span class="s1">self._dbs[get_thread_id()] = db = SqliteDb(self._filename, self._debug)</span>
        <span class="s2">with </span><span class="s1">db:</span>
            <span class="s1">db.executescript(SCHEMA)</span>
            <span class="s1">db.execute(</span><span class="s4">&quot;insert into coverage_schema (version) values (?)&quot;</span><span class="s1">, (SCHEMA_VERSION,))</span>
            <span class="s1">db.executemany(</span>
                <span class="s4">&quot;insert into meta (key, value) values (?, ?)&quot;</span><span class="s1">,</span>
                <span class="s1">[</span>
                    <span class="s1">(</span><span class="s4">'sys_argv'</span><span class="s1">, str(getattr(sys, </span><span class="s4">'argv'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">))),</span>
                    <span class="s1">(</span><span class="s4">'version'</span><span class="s1">, __version__),</span>
                    <span class="s1">(</span><span class="s4">'when'</span><span class="s1">, datetime.datetime.now().strftime(</span><span class="s4">'%Y-%m-%d %H:%M:%S'</span><span class="s1">)),</span>
                <span class="s1">]</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_open_db(self):</span>
        <span class="s0">&quot;&quot;&quot;Open an existing db file, and read its metadata.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Opening data file {!r}&quot;</span><span class="s1">.format(self._filename))</span>
        <span class="s1">self._dbs[get_thread_id()] = SqliteDb(self._filename, self._debug)</span>
        <span class="s1">self._read_db()</span>

    <span class="s2">def </span><span class="s1">_read_db(self):</span>
        <span class="s0">&quot;&quot;&quot;Read the metadata from a database so that we are ready to use it.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._dbs[get_thread_id()] </span><span class="s2">as </span><span class="s1">db:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">schema_version, = db.execute_one(</span><span class="s4">&quot;select version from coverage_schema&quot;</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">raise </span><span class="s1">CoverageException(</span>
                    <span class="s4">&quot;Data file {!r} doesn't seem to be a coverage data file: {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">self._filename, exc</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">schema_version != SCHEMA_VERSION:</span>
                    <span class="s2">raise </span><span class="s1">CoverageException(</span>
                        <span class="s4">&quot;Couldn't use data file {!r}: wrong schema: {} instead of {}&quot;</span><span class="s1">.format(</span>
                            <span class="s1">self._filename, schema_version, SCHEMA_VERSION</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>

            <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">db.execute(</span><span class="s4">&quot;select value from meta where key = 'has_arcs'&quot;</span><span class="s1">):</span>
                <span class="s1">self._has_arcs = bool(int(row[</span><span class="s3">0</span><span class="s1">]))</span>
                <span class="s1">self._has_lines = </span><span class="s2">not </span><span class="s1">self._has_arcs</span>

            <span class="s2">for </span><span class="s1">path, file_id </span><span class="s2">in </span><span class="s1">db.execute(</span><span class="s4">&quot;select path, id from file&quot;</span><span class="s1">):</span>
                <span class="s1">self._file_map[path] = file_id</span>

    <span class="s2">def </span><span class="s1">_connect(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the SqliteDb object to use.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">get_thread_id() </span><span class="s2">not in </span><span class="s1">self._dbs:</span>
            <span class="s2">if </span><span class="s1">os.path.exists(self._filename):</span>
                <span class="s1">self._open_db()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._create_db()</span>
        <span class="s2">return </span><span class="s1">self._dbs[get_thread_id()]</span>

    <span class="s2">def </span><span class="s1">__nonzero__(self):</span>
        <span class="s2">if </span><span class="s1">(get_thread_id() </span><span class="s2">not in </span><span class="s1">self._dbs </span><span class="s2">and not </span><span class="s1">os.path.exists(self._filename)):</span>
            <span class="s2">return False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
                <span class="s1">rows = con.execute(</span><span class="s4">&quot;select * from file limit 1&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">bool(list(rows))</span>
        <span class="s2">except </span><span class="s1">CoverageException:</span>
            <span class="s2">return False</span>

    <span class="s1">__bool__ = __nonzero__</span>

    <span class="s1">@contract(returns=</span><span class="s4">'bytes'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">dumps(self):</span>
        <span class="s0">&quot;&quot;&quot;Serialize the current data to a byte string. 
 
        The format of the serialized data is not documented. It is only 
        suitable for use with :meth:`loads` in the same version of 
        coverage.py. 
 
        Returns: 
            A byte string of serialized data. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Dumping data from data file {!r}&quot;</span><span class="s1">.format(self._filename))</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s2">return </span><span class="s4">b'z' </span><span class="s1">+ zlib.compress(to_bytes(con.dump()))</span>

    <span class="s1">@contract(data=</span><span class="s4">'bytes'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">loads(self, data):</span>
        <span class="s0">&quot;&quot;&quot;Deserialize data from :meth:`dumps` 
 
        Use with a newly-created empty :class:`CoverageData` object.  It's 
        undefined what happens if the object already has data in it. 
 
        Arguments: 
            data: A byte string of serialized data produced by :meth:`dumps`. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Loading data into data file {!r}&quot;</span><span class="s1">.format(self._filename))</span>
        <span class="s2">if </span><span class="s1">data[:</span><span class="s3">1</span><span class="s1">] != </span><span class="s4">b'z'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span>
                <span class="s4">&quot;Unrecognized serialization: {!r} (head of {} bytes)&quot;</span><span class="s1">.format(data[:</span><span class="s3">40</span><span class="s1">], len(data))</span>
                <span class="s1">)</span>
        <span class="s1">script = to_string(zlib.decompress(data[</span><span class="s3">1</span><span class="s1">:]))</span>
        <span class="s1">self._dbs[get_thread_id()] = db = SqliteDb(self._filename, self._debug)</span>
        <span class="s2">with </span><span class="s1">db:</span>
            <span class="s1">db.executescript(script)</span>
        <span class="s1">self._read_db()</span>
        <span class="s1">self._have_used = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_file_id(self, filename, add=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the file id for `filename`. 
 
        If filename is not in the database yet, add it if `add` is True. 
        If `add` is not True, return None. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">filename </span><span class="s2">not in </span><span class="s1">self._file_map:</span>
            <span class="s2">if </span><span class="s1">add:</span>
                <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
                    <span class="s1">cur = con.execute(</span><span class="s4">&quot;insert or replace into file (path) values (?)&quot;</span><span class="s1">, (filename,))</span>
                    <span class="s1">self._file_map[filename] = cur.lastrowid</span>
        <span class="s2">return </span><span class="s1">self._file_map.get(filename)</span>

    <span class="s2">def </span><span class="s1">_context_id(self, context):</span>
        <span class="s0">&quot;&quot;&quot;Get the id for a context.&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">context </span><span class="s2">is not None</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">row = con.execute_one(</span><span class="s4">&quot;select id from context where context = ?&quot;</span><span class="s1">, (context,))</span>
            <span class="s2">if </span><span class="s1">row </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">row[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">set_context(self, context):</span>
        <span class="s0">&quot;&quot;&quot;Set the current context for future :meth:`add_lines` etc. 
 
        `context` is a str, the name of the context to use for the next data 
        additions.  The context persists until the next :meth:`set_context`. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Setting context: %r&quot; </span><span class="s1">% (context,))</span>
        <span class="s1">self._current_context = context</span>
        <span class="s1">self._current_context_id = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_set_context_id(self):</span>
        <span class="s0">&quot;&quot;&quot;Use the _current_context to set _current_context_id.&quot;&quot;&quot;</span>
        <span class="s1">context = self._current_context </span><span class="s2">or </span><span class="s4">&quot;&quot;</span>
        <span class="s1">context_id = self._context_id(context)</span>
        <span class="s2">if </span><span class="s1">context_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._current_context_id = context_id</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
                <span class="s1">cur = con.execute(</span><span class="s4">&quot;insert into context (context) values (?)&quot;</span><span class="s1">, (context,))</span>
                <span class="s1">self._current_context_id = cur.lastrowid</span>

    <span class="s2">def </span><span class="s1">base_filename(self):</span>
        <span class="s0">&quot;&quot;&quot;The base filename for storing data. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._basename</span>

    <span class="s2">def </span><span class="s1">data_filename(self):</span>
        <span class="s0">&quot;&quot;&quot;Where is the data stored? 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filename</span>

    <span class="s2">def </span><span class="s1">add_lines(self, line_data):</span>
        <span class="s0">&quot;&quot;&quot;Add measured line data. 
 
        `line_data` is a dictionary mapping file names to dictionaries:: 
 
            { filename: { lineno: None, ... }, ...} 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Adding lines: %d files, %d lines total&quot; </span><span class="s1">% (</span>
                <span class="s1">len(line_data), sum(len(lines) </span><span class="s2">for </span><span class="s1">lines </span><span class="s2">in </span><span class="s1">line_data.values())</span>
            <span class="s1">))</span>
        <span class="s1">self._start_using()</span>
        <span class="s1">self._choose_lines_or_arcs(lines=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">line_data:</span>
            <span class="s2">return</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">self._set_context_id()</span>
            <span class="s2">for </span><span class="s1">filename, linenos </span><span class="s2">in </span><span class="s1">iitems(line_data):</span>
                <span class="s1">linemap = nums_to_numbits(linenos)</span>
                <span class="s1">file_id = self._file_id(filename, add=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">query = </span><span class="s4">&quot;select numbits from line_bits where file_id = ? and context_id = ?&quot;</span>
                <span class="s1">existing = list(con.execute(query, (file_id, self._current_context_id)))</span>
                <span class="s2">if </span><span class="s1">existing:</span>
                    <span class="s1">linemap = numbits_union(linemap, existing[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">])</span>

                <span class="s1">con.execute(</span>
                    <span class="s4">&quot;insert or replace into line_bits &quot;</span>
                    <span class="s4">&quot; (file_id, context_id, numbits) values (?, ?, ?)&quot;</span><span class="s1">,</span>
                    <span class="s1">(file_id, self._current_context_id, linemap),</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_arcs(self, arc_data):</span>
        <span class="s0">&quot;&quot;&quot;Add measured arc data. 
 
        `arc_data` is a dictionary mapping file names to dictionaries:: 
 
            { filename: { (l1,l2): None, ... }, ...} 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Adding arcs: %d files, %d arcs total&quot; </span><span class="s1">% (</span>
                <span class="s1">len(arc_data), sum(len(arcs) </span><span class="s2">for </span><span class="s1">arcs </span><span class="s2">in </span><span class="s1">arc_data.values())</span>
            <span class="s1">))</span>
        <span class="s1">self._start_using()</span>
        <span class="s1">self._choose_lines_or_arcs(arcs=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">arc_data:</span>
            <span class="s2">return</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">self._set_context_id()</span>
            <span class="s2">for </span><span class="s1">filename, arcs </span><span class="s2">in </span><span class="s1">iitems(arc_data):</span>
                <span class="s1">file_id = self._file_id(filename, add=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">data = [(file_id, self._current_context_id, fromno, tono) </span><span class="s2">for </span><span class="s1">fromno, tono </span><span class="s2">in </span><span class="s1">arcs]</span>
                <span class="s1">con.executemany(</span>
                    <span class="s4">&quot;insert or ignore into arc &quot;</span>
                    <span class="s4">&quot;(file_id, context_id, fromno, tono) values (?, ?, ?, ?)&quot;</span><span class="s1">,</span>
                    <span class="s1">data,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_choose_lines_or_arcs(self, lines=</span><span class="s2">False</span><span class="s1">, arcs=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Force the data file to choose between lines and arcs.&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">lines </span><span class="s2">or </span><span class="s1">arcs</span>
        <span class="s2">assert not </span><span class="s1">(lines </span><span class="s2">and </span><span class="s1">arcs)</span>
        <span class="s2">if </span><span class="s1">lines </span><span class="s2">and </span><span class="s1">self._has_arcs:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Can't add line measurements to existing branch data&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">arcs </span><span class="s2">and </span><span class="s1">self._has_lines:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Can't add branch measurements to existing line data&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self._has_arcs </span><span class="s2">and not </span><span class="s1">self._has_lines:</span>
            <span class="s1">self._has_lines = lines</span>
            <span class="s1">self._has_arcs = arcs</span>
            <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
                <span class="s1">con.execute(</span>
                    <span class="s4">&quot;insert into meta (key, value) values (?, ?)&quot;</span><span class="s1">,</span>
                    <span class="s1">(</span><span class="s4">'has_arcs'</span><span class="s1">, str(int(arcs)))</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_file_tracers(self, file_tracers):</span>
        <span class="s0">&quot;&quot;&quot;Add per-file plugin information. 
 
        `file_tracers` is { filename: plugin_name, ... } 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Adding file tracers: %d files&quot; </span><span class="s1">% (len(file_tracers),))</span>
        <span class="s2">if not </span><span class="s1">file_tracers:</span>
            <span class="s2">return</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s2">for </span><span class="s1">filename, plugin_name </span><span class="s2">in </span><span class="s1">iitems(file_tracers):</span>
                <span class="s1">file_id = self._file_id(filename)</span>
                <span class="s2">if </span><span class="s1">file_id </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">CoverageException(</span>
                        <span class="s4">&quot;Can't add file tracer data for unmeasured file '%s'&quot; </span><span class="s1">% (filename,)</span>
                    <span class="s1">)</span>

                <span class="s1">existing_plugin = self.file_tracer(filename)</span>
                <span class="s2">if </span><span class="s1">existing_plugin:</span>
                    <span class="s2">if </span><span class="s1">existing_plugin != plugin_name:</span>
                        <span class="s2">raise </span><span class="s1">CoverageException(</span>
                            <span class="s4">&quot;Conflicting file tracer name for '%s': %r vs %r&quot; </span><span class="s1">% (</span>
                                <span class="s1">filename, existing_plugin, plugin_name,</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">plugin_name:</span>
                    <span class="s1">con.execute(</span>
                        <span class="s4">&quot;insert into tracer (file_id, tracer) values (?, ?)&quot;</span><span class="s1">,</span>
                        <span class="s1">(file_id, plugin_name)</span>
                    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">touch_file(self, filename, plugin_name=</span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Ensure that `filename` appears in the data, empty if needed. 
 
        `plugin_name` is the name of the plugin responsible for this file. It is used 
        to associate the right filereporter, etc. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.touch_files([filename], plugin_name)</span>

    <span class="s2">def </span><span class="s1">touch_files(self, filenames, plugin_name=</span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Ensure that `filenames` appear in the data, empty if needed. 
 
        `plugin_name` is the name of the plugin responsible for these files. It is used 
        to associate the right filereporter, etc. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Touching %r&quot; </span><span class="s1">% (filenames,))</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect(): </span><span class="s0"># Use this to get one transaction.</span>
            <span class="s2">if not </span><span class="s1">self._has_arcs </span><span class="s2">and not </span><span class="s1">self._has_lines:</span>
                <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Can't touch files in an empty CoverageData&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
                <span class="s1">self._file_id(filename, add=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">plugin_name:</span>
                    <span class="s0"># Set the tracer for this file</span>
                    <span class="s1">self.add_file_tracers({filename: plugin_name})</span>

    <span class="s2">def </span><span class="s1">update(self, other_data, aliases=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Update this data with data from several other :class:`CoverageData` instances. 
 
        If `aliases` is provided, it's a `PathAliases` object that is used to 
        re-map paths to match the local machine's. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataop'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Updating with data from %r&quot; </span><span class="s1">% (</span>
                <span class="s1">getattr(other_data, </span><span class="s4">'_filename'</span><span class="s1">, </span><span class="s4">'???'</span><span class="s1">),</span>
            <span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._has_lines </span><span class="s2">and </span><span class="s1">other_data._has_arcs:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Can't combine arc data with line data&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._has_arcs </span><span class="s2">and </span><span class="s1">other_data._has_lines:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Can't combine line data with arc data&quot;</span><span class="s1">)</span>

        <span class="s1">aliases = aliases </span><span class="s2">or </span><span class="s1">PathAliases()</span>

        <span class="s0"># Force the database we're writing to to exist before we start nesting</span>
        <span class="s0"># contexts.</span>
        <span class="s1">self._start_using()</span>

        <span class="s0"># Collector for all arcs, lines and tracers</span>
        <span class="s1">other_data.read()</span>
        <span class="s2">with </span><span class="s1">other_data._connect() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s0"># Get files data.</span>
            <span class="s1">cur = conn.execute(</span><span class="s4">'select path from file'</span><span class="s1">)</span>
            <span class="s1">files = {path: aliases.map(path) </span><span class="s2">for </span><span class="s1">(path,) </span><span class="s2">in </span><span class="s1">cur}</span>
            <span class="s1">cur.close()</span>

            <span class="s0"># Get contexts data.</span>
            <span class="s1">cur = conn.execute(</span><span class="s4">'select context from context'</span><span class="s1">)</span>
            <span class="s1">contexts = [context </span><span class="s2">for </span><span class="s1">(context,) </span><span class="s2">in </span><span class="s1">cur]</span>
            <span class="s1">cur.close()</span>

            <span class="s0"># Get arc data.</span>
            <span class="s1">cur = conn.execute(</span>
                <span class="s4">'select file.path, context.context, arc.fromno, arc.tono '</span>
                <span class="s4">'from arc '</span>
                <span class="s4">'inner join file on file.id = arc.file_id '</span>
                <span class="s4">'inner join context on context.id = arc.context_id'</span>
            <span class="s1">)</span>
            <span class="s1">arcs = [(files[path], context, fromno, tono) </span><span class="s2">for </span><span class="s1">(path, context, fromno, tono) </span><span class="s2">in </span><span class="s1">cur]</span>
            <span class="s1">cur.close()</span>

            <span class="s0"># Get line data.</span>
            <span class="s1">cur = conn.execute(</span>
                <span class="s4">'select file.path, context.context, line_bits.numbits '</span>
                <span class="s4">'from line_bits '</span>
                <span class="s4">'inner join file on file.id = line_bits.file_id '</span>
                <span class="s4">'inner join context on context.id = line_bits.context_id'</span>
                <span class="s1">)</span>
            <span class="s1">lines = {</span>
                <span class="s1">(files[path], context): numbits</span>
                <span class="s2">for </span><span class="s1">(path, context, numbits) </span><span class="s2">in </span><span class="s1">cur</span>
                <span class="s1">}</span>
            <span class="s1">cur.close()</span>

            <span class="s0"># Get tracer data.</span>
            <span class="s1">cur = conn.execute(</span>
                <span class="s4">'select file.path, tracer '</span>
                <span class="s4">'from tracer '</span>
                <span class="s4">'inner join file on file.id = tracer.file_id'</span>
            <span class="s1">)</span>
            <span class="s1">tracers = {files[path]: tracer </span><span class="s2">for </span><span class="s1">(path, tracer) </span><span class="s2">in </span><span class="s1">cur}</span>
            <span class="s1">cur.close()</span>

        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">conn:</span>
            <span class="s1">conn.con.isolation_level = </span><span class="s4">'IMMEDIATE'</span>

            <span class="s0"># Get all tracers in the DB. Files not in the tracers are assumed</span>
            <span class="s0"># to have an empty string tracer. Since Sqlite does not support</span>
            <span class="s0"># full outer joins, we have to make two queries to fill the</span>
            <span class="s0"># dictionary.</span>
            <span class="s1">this_tracers = {path: </span><span class="s4">'' </span><span class="s2">for </span><span class="s1">path, </span><span class="s2">in </span><span class="s1">conn.execute(</span><span class="s4">'select path from file'</span><span class="s1">)}</span>
            <span class="s1">this_tracers.update({</span>
                <span class="s1">aliases.map(path): tracer</span>
                <span class="s2">for </span><span class="s1">path, tracer </span><span class="s2">in </span><span class="s1">conn.execute(</span>
                    <span class="s4">'select file.path, tracer from tracer '</span>
                    <span class="s4">'inner join file on file.id = tracer.file_id'</span>
                <span class="s1">)</span>
            <span class="s1">})</span>

            <span class="s0"># Create all file and context rows in the DB.</span>
            <span class="s1">conn.executemany(</span>
                <span class="s4">'insert or ignore into file (path) values (?)'</span><span class="s1">,</span>
                <span class="s1">((file,) </span><span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files.values())</span>
            <span class="s1">)</span>
            <span class="s1">file_ids = {</span>
                <span class="s1">path: id</span>
                <span class="s2">for </span><span class="s1">id, path </span><span class="s2">in </span><span class="s1">conn.execute(</span><span class="s4">'select id, path from file'</span><span class="s1">)</span>
            <span class="s1">}</span>
            <span class="s1">conn.executemany(</span>
                <span class="s4">'insert or ignore into context (context) values (?)'</span><span class="s1">,</span>
                <span class="s1">((context,) </span><span class="s2">for </span><span class="s1">context </span><span class="s2">in </span><span class="s1">contexts)</span>
            <span class="s1">)</span>
            <span class="s1">context_ids = {</span>
                <span class="s1">context: id</span>
                <span class="s2">for </span><span class="s1">id, context </span><span class="s2">in </span><span class="s1">conn.execute(</span><span class="s4">'select id, context from context'</span><span class="s1">)</span>
            <span class="s1">}</span>

            <span class="s0"># Prepare tracers and fail, if a conflict is found.</span>
            <span class="s0"># tracer_paths is used to ensure consistency over the tracer data</span>
            <span class="s0"># and tracer_map tracks the tracers to be inserted.</span>
            <span class="s1">tracer_map = {}</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">files.values():</span>
                <span class="s1">this_tracer = this_tracers.get(path)</span>
                <span class="s1">other_tracer = tracers.get(path, </span><span class="s4">''</span><span class="s1">)</span>
                <span class="s0"># If there is no tracer, there is always the None tracer.</span>
                <span class="s2">if </span><span class="s1">this_tracer </span><span class="s2">is not None and </span><span class="s1">this_tracer != other_tracer:</span>
                    <span class="s2">raise </span><span class="s1">CoverageException(</span>
                        <span class="s4">&quot;Conflicting file tracer name for '%s': %r vs %r&quot; </span><span class="s1">% (</span>
                            <span class="s1">path, this_tracer, other_tracer</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">tracer_map[path] = other_tracer</span>

            <span class="s0"># Prepare arc and line rows to be inserted by converting the file</span>
            <span class="s0"># and context strings with integer ids. Then use the efficient</span>
            <span class="s0"># `executemany()` to insert all rows at once.</span>
            <span class="s1">arc_rows = (</span>
                <span class="s1">(file_ids[file], context_ids[context], fromno, tono)</span>
                <span class="s2">for </span><span class="s1">file, context, fromno, tono </span><span class="s2">in </span><span class="s1">arcs</span>
            <span class="s1">)</span>

            <span class="s0"># Get line data.</span>
            <span class="s1">cur = conn.execute(</span>
                <span class="s4">'select file.path, context.context, line_bits.numbits '</span>
                <span class="s4">'from line_bits '</span>
                <span class="s4">'inner join file on file.id = line_bits.file_id '</span>
                <span class="s4">'inner join context on context.id = line_bits.context_id'</span>
                <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">path, context, numbits </span><span class="s2">in </span><span class="s1">cur:</span>
                <span class="s1">key = (aliases.map(path), context)</span>
                <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">lines:</span>
                    <span class="s1">numbits = numbits_union(lines[key], numbits)</span>
                <span class="s1">lines[key] = numbits</span>
            <span class="s1">cur.close()</span>

            <span class="s2">if </span><span class="s1">arcs:</span>
                <span class="s1">self._choose_lines_or_arcs(arcs=</span><span class="s2">True</span><span class="s1">)</span>

                <span class="s0"># Write the combined data.</span>
                <span class="s1">conn.executemany(</span>
                    <span class="s4">'insert or ignore into arc '</span>
                    <span class="s4">'(file_id, context_id, fromno, tono) values (?, ?, ?, ?)'</span><span class="s1">,</span>
                    <span class="s1">arc_rows</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">lines:</span>
                <span class="s1">self._choose_lines_or_arcs(lines=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">conn.execute(</span><span class="s4">&quot;delete from line_bits&quot;</span><span class="s1">)</span>
                <span class="s1">conn.executemany(</span>
                    <span class="s4">&quot;insert into line_bits &quot;</span>
                    <span class="s4">&quot;(file_id, context_id, numbits) values (?, ?, ?)&quot;</span><span class="s1">,</span>
                    <span class="s1">[</span>
                        <span class="s1">(file_ids[file], context_ids[context], numbits)</span>
                        <span class="s2">for </span><span class="s1">(file, context), numbits </span><span class="s2">in </span><span class="s1">lines.items()</span>
                    <span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s1">conn.executemany(</span>
                <span class="s4">'insert or ignore into tracer (file_id, tracer) values (?, ?)'</span><span class="s1">,</span>
                <span class="s1">((file_ids[filename], tracer) </span><span class="s2">for </span><span class="s1">filename, tracer </span><span class="s2">in </span><span class="s1">tracer_map.items())</span>
            <span class="s1">)</span>

        <span class="s0"># Update all internal cache data.</span>
        <span class="s1">self._reset()</span>
        <span class="s1">self.read()</span>

    <span class="s2">def </span><span class="s1">erase(self, parallel=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Erase the data in this object. 
 
        If `parallel` is true, then also deletes data files created from the 
        basename by parallel-mode. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._reset()</span>
        <span class="s2">if </span><span class="s1">self._no_disk:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s4">&quot;Erasing data file {!r}&quot;</span><span class="s1">.format(self._filename))</span>
        <span class="s1">file_be_gone(self._filename)</span>
        <span class="s2">if </span><span class="s1">parallel:</span>
            <span class="s1">data_dir, local = os.path.split(self._filename)</span>
            <span class="s1">localdot = local + </span><span class="s4">'.*'</span>
            <span class="s1">pattern = os.path.join(os.path.abspath(data_dir), localdot)</span>
            <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">glob.glob(pattern):</span>
                <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s4">'dataio'</span><span class="s1">):</span>
                    <span class="s1">self._debug.write(</span><span class="s4">&quot;Erasing parallel data file {!r}&quot;</span><span class="s1">.format(filename))</span>
                <span class="s1">file_be_gone(filename)</span>

    <span class="s2">def </span><span class="s1">read(self):</span>
        <span class="s0">&quot;&quot;&quot;Start using an existing data file.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._connect():       </span><span class="s0"># TODO: doesn't look right</span>
            <span class="s1">self._have_used = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">write(self):</span>
        <span class="s0">&quot;&quot;&quot;Ensure the data is written to the data file.&quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_start_using(self):</span>
        <span class="s0">&quot;&quot;&quot;Call this before using the database at all.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._pid != os.getpid():</span>
            <span class="s0"># Looks like we forked! Have to start a new data file.</span>
            <span class="s1">self._reset()</span>
            <span class="s1">self._choose_filename()</span>
            <span class="s1">self._pid = os.getpid()</span>
        <span class="s2">if not </span><span class="s1">self._have_used:</span>
            <span class="s1">self.erase()</span>
        <span class="s1">self._have_used = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">has_arcs(self):</span>
        <span class="s0">&quot;&quot;&quot;Does the database have arcs (True) or lines (False).&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self._has_arcs)</span>

    <span class="s2">def </span><span class="s1">measured_files(self):</span>
        <span class="s0">&quot;&quot;&quot;A set of all files that had been measured.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">set(self._file_map)</span>

    <span class="s2">def </span><span class="s1">measured_contexts(self):</span>
        <span class="s0">&quot;&quot;&quot;A set of all contexts that have been measured. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">contexts = {row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">con.execute(</span><span class="s4">&quot;select distinct(context) from context&quot;</span><span class="s1">)}</span>
        <span class="s2">return </span><span class="s1">contexts</span>

    <span class="s2">def </span><span class="s1">file_tracer(self, filename):</span>
        <span class="s0">&quot;&quot;&quot;Get the plugin name of the file tracer for a file. 
 
        Returns the name of the plugin that handles this file.  If the file was 
        measured, but didn't use a plugin, then &quot;&quot; is returned.  If the file 
        was not measured, then None is returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">file_id = self._file_id(filename)</span>
            <span class="s2">if </span><span class="s1">file_id </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s1">row = con.execute_one(</span><span class="s4">&quot;select tracer from tracer where file_id = ?&quot;</span><span class="s1">, (file_id,))</span>
            <span class="s2">if </span><span class="s1">row </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">or </span><span class="s4">&quot;&quot;</span>
            <span class="s2">return </span><span class="s4">&quot;&quot;   </span><span class="s0"># File was measured, but no tracer associated.</span>

    <span class="s2">def </span><span class="s1">set_query_context(self, context):</span>
        <span class="s0">&quot;&quot;&quot;Set a context for subsequent querying. 
 
        The next :meth:`lines`, :meth:`arcs`, or :meth:`contexts_by_lineno` 
        calls will be limited to only one context.  `context` is a string which 
        must match a context exactly.  If it does not, no exception is raised, 
        but queries will return no data. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">cur = con.execute(</span><span class="s4">&quot;select id from context where context = ?&quot;</span><span class="s1">, (context,))</span>
            <span class="s1">self._query_context_ids = [row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">cur.fetchall()]</span>

    <span class="s2">def </span><span class="s1">set_query_contexts(self, contexts):</span>
        <span class="s0">&quot;&quot;&quot;Set a number of contexts for subsequent querying. 
 
        The next :meth:`lines`, :meth:`arcs`, or :meth:`contexts_by_lineno` 
        calls will be limited to the specified contexts.  `contexts` is a list 
        of Python regular expressions.  Contexts will be matched using 
        :func:`re.search &lt;python:re.search&gt;`.  Data will be included in query 
        results if they are part of any of the contexts matched. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">if </span><span class="s1">contexts:</span>
            <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
                <span class="s1">context_clause = </span><span class="s4">' or '</span><span class="s1">.join([</span><span class="s4">'context regexp ?'</span><span class="s1">] * len(contexts))</span>
                <span class="s1">cur = con.execute(</span><span class="s4">&quot;select id from context where &quot; </span><span class="s1">+ context_clause, contexts)</span>
                <span class="s1">self._query_context_ids = [row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">cur.fetchall()]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._query_context_ids = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">lines(self, filename):</span>
        <span class="s0">&quot;&quot;&quot;Get the list of lines executed for a file. 
 
        If the file was not measured, returns None.  A file might be measured, 
        and have no lines executed, in which case an empty list is returned. 
 
        If the file was executed, returns a list of integers, the line numbers 
        executed in the file. The list is in no particular order. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">if </span><span class="s1">self.has_arcs():</span>
            <span class="s1">arcs = self.arcs(filename)</span>
            <span class="s2">if </span><span class="s1">arcs </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">all_lines = itertools.chain.from_iterable(arcs)</span>
                <span class="s2">return </span><span class="s1">list({l </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">all_lines </span><span class="s2">if </span><span class="s1">l &gt; </span><span class="s3">0</span><span class="s1">})</span>

        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">file_id = self._file_id(filename)</span>
            <span class="s2">if </span><span class="s1">file_id </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">query = </span><span class="s4">&quot;select numbits from line_bits where file_id = ?&quot;</span>
                <span class="s1">data = [file_id]</span>
                <span class="s2">if </span><span class="s1">self._query_context_ids </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ids_array = </span><span class="s4">', '</span><span class="s1">.join(</span><span class="s4">'?' </span><span class="s1">* len(self._query_context_ids))</span>
                    <span class="s1">query += </span><span class="s4">&quot; and context_id in (&quot; </span><span class="s1">+ ids_array + </span><span class="s4">&quot;)&quot;</span>
                    <span class="s1">data += self._query_context_ids</span>
                <span class="s1">bitmaps = list(con.execute(query, data))</span>
                <span class="s1">nums = set()</span>
                <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">bitmaps:</span>
                    <span class="s1">nums.update(numbits_to_nums(row[</span><span class="s3">0</span><span class="s1">]))</span>
                <span class="s2">return </span><span class="s1">list(nums)</span>

    <span class="s2">def </span><span class="s1">arcs(self, filename):</span>
        <span class="s0">&quot;&quot;&quot;Get the list of arcs executed for a file. 
 
        If the file was not measured, returns None.  A file might be measured, 
        and have no arcs executed, in which case an empty list is returned. 
 
        If the file was executed, returns a list of 2-tuples of integers. Each 
        pair is a starting line number and an ending line number for a 
        transition from one line to another. The list is in no particular 
        order. 
 
        Negative numbers have special meaning.  If the starting line number is 
        -N, it represents an entry to the code object that starts at line N. 
        If the ending ling number is -N, it's an exit from the code object that 
        starts at line N. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">file_id = self._file_id(filename)</span>
            <span class="s2">if </span><span class="s1">file_id </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">query = </span><span class="s4">&quot;select distinct fromno, tono from arc where file_id = ?&quot;</span>
                <span class="s1">data = [file_id]</span>
                <span class="s2">if </span><span class="s1">self._query_context_ids </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ids_array = </span><span class="s4">', '</span><span class="s1">.join(</span><span class="s4">'?' </span><span class="s1">* len(self._query_context_ids))</span>
                    <span class="s1">query += </span><span class="s4">&quot; and context_id in (&quot; </span><span class="s1">+ ids_array + </span><span class="s4">&quot;)&quot;</span>
                    <span class="s1">data += self._query_context_ids</span>
                <span class="s1">arcs = con.execute(query, data)</span>
                <span class="s2">return </span><span class="s1">list(arcs)</span>

    <span class="s2">def </span><span class="s1">contexts_by_lineno(self, filename):</span>
        <span class="s0">&quot;&quot;&quot;Get the contexts for each line in a file. 
 
        Returns: 
            A dict mapping line numbers to a list of context names. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">lineno_contexts_map = collections.defaultdict(list)</span>
        <span class="s1">self._start_using()</span>
        <span class="s2">with </span><span class="s1">self._connect() </span><span class="s2">as </span><span class="s1">con:</span>
            <span class="s1">file_id = self._file_id(filename)</span>
            <span class="s2">if </span><span class="s1">file_id </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">lineno_contexts_map</span>
            <span class="s2">if </span><span class="s1">self.has_arcs():</span>
                <span class="s1">query = (</span>
                    <span class="s4">&quot;select arc.fromno, arc.tono, context.context &quot;</span>
                    <span class="s4">&quot;from arc, context &quot;</span>
                    <span class="s4">&quot;where arc.file_id = ? and arc.context_id = context.id&quot;</span>
                <span class="s1">)</span>
                <span class="s1">data = [file_id]</span>
                <span class="s2">if </span><span class="s1">self._query_context_ids </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ids_array = </span><span class="s4">', '</span><span class="s1">.join(</span><span class="s4">'?' </span><span class="s1">* len(self._query_context_ids))</span>
                    <span class="s1">query += </span><span class="s4">&quot; and arc.context_id in (&quot; </span><span class="s1">+ ids_array + </span><span class="s4">&quot;)&quot;</span>
                    <span class="s1">data += self._query_context_ids</span>
                <span class="s2">for </span><span class="s1">fromno, tono, context </span><span class="s2">in </span><span class="s1">con.execute(query, data):</span>
                    <span class="s2">if </span><span class="s1">context </span><span class="s2">not in </span><span class="s1">lineno_contexts_map[fromno]:</span>
                        <span class="s1">lineno_contexts_map[fromno].append(context)</span>
                    <span class="s2">if </span><span class="s1">context </span><span class="s2">not in </span><span class="s1">lineno_contexts_map[tono]:</span>
                        <span class="s1">lineno_contexts_map[tono].append(context)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">query = (</span>
                    <span class="s4">&quot;select l.numbits, c.context from line_bits l, context c &quot;</span>
                    <span class="s4">&quot;where l.context_id = c.id &quot;</span>
                    <span class="s4">&quot;and file_id = ?&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">data = [file_id]</span>
                <span class="s2">if </span><span class="s1">self._query_context_ids </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ids_array = </span><span class="s4">', '</span><span class="s1">.join(</span><span class="s4">'?' </span><span class="s1">* len(self._query_context_ids))</span>
                    <span class="s1">query += </span><span class="s4">&quot; and l.context_id in (&quot; </span><span class="s1">+ ids_array + </span><span class="s4">&quot;)&quot;</span>
                    <span class="s1">data += self._query_context_ids</span>
                <span class="s2">for </span><span class="s1">numbits, context </span><span class="s2">in </span><span class="s1">con.execute(query, data):</span>
                    <span class="s2">for </span><span class="s1">lineno </span><span class="s2">in </span><span class="s1">numbits_to_nums(numbits):</span>
                        <span class="s1">lineno_contexts_map[lineno].append(context)</span>
        <span class="s2">return </span><span class="s1">lineno_contexts_map</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">sys_info(cls):</span>
        <span class="s0">&quot;&quot;&quot;Our information for `Coverage.sys_info`. 
 
        Returns a list of (key, value) pairs. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">SqliteDb(</span><span class="s4">&quot;:memory:&quot;</span><span class="s1">, debug=NoDebugging()) </span><span class="s2">as </span><span class="s1">db:</span>
            <span class="s1">temp_store = [row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">db.execute(</span><span class="s4">&quot;pragma temp_store&quot;</span><span class="s1">)]</span>
            <span class="s1">compile_options = [row[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">db.execute(</span><span class="s4">&quot;pragma compile_options&quot;</span><span class="s1">)]</span>

        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s4">'sqlite3_version'</span><span class="s1">, sqlite3.version),</span>
            <span class="s1">(</span><span class="s4">'sqlite3_sqlite_version'</span><span class="s1">, sqlite3.sqlite_version),</span>
            <span class="s1">(</span><span class="s4">'sqlite3_temp_store'</span><span class="s1">, temp_store),</span>
            <span class="s1">(</span><span class="s4">'sqlite3_compile_options'</span><span class="s1">, compile_options),</span>
        <span class="s1">]</span>


<span class="s2">class </span><span class="s1">SqliteDb(SimpleReprMixin):</span>
    <span class="s0">&quot;&quot;&quot;A simple abstraction over a SQLite database. 
 
    Use as a context manager, then you can use it like a 
    :class:`python:sqlite3.Connection` object:: 
 
        with SqliteDb(filename, debug_control) as db: 
            db.execute(&quot;insert into schema (version) values (?)&quot;, (SCHEMA_VERSION,)) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self, filename, debug):</span>
        <span class="s1">self.debug = debug </span><span class="s2">if </span><span class="s1">debug.should(</span><span class="s4">'sql'</span><span class="s1">) </span><span class="s2">else None</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.nest = </span><span class="s3">0</span>
        <span class="s1">self.con = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_connect(self):</span>
        <span class="s0">&quot;&quot;&quot;Connect to the db and do universal initialization.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.con </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s0"># SQLite on Windows on py2 won't open a file if the filename argument</span>
        <span class="s0"># has non-ascii characters in it.  Opening a relative file name avoids</span>
        <span class="s0"># a problem if the current directory has non-ascii.</span>
        <span class="s1">filename = self.filename</span>
        <span class="s2">if </span><span class="s1">env.WINDOWS </span><span class="s2">and </span><span class="s1">env.PY2:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">filename = os.path.relpath(self.filename)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s0"># ValueError can be raised under Windows when os.getcwd() returns a</span>
                <span class="s0"># folder from a different drive than the drive of self.filename in</span>
                <span class="s0"># which case we keep the original value of self.filename unchanged,</span>
                <span class="s0"># hoping that we won't face the non-ascii directory problem.</span>
                <span class="s2">pass</span>

        <span class="s0"># It can happen that Python switches threads while the tracer writes</span>
        <span class="s0"># data. The second thread will also try to write to the data,</span>
        <span class="s0"># effectively causing a nested context. However, given the idempotent</span>
        <span class="s0"># nature of the tracer operations, sharing a connection among threads</span>
        <span class="s0"># is not a problem.</span>
        <span class="s2">if </span><span class="s1">self.debug:</span>
            <span class="s1">self.debug.write(</span><span class="s4">&quot;Connecting to {!r}&quot;</span><span class="s1">.format(self.filename))</span>
        <span class="s1">self.con = sqlite3.connect(filename, check_same_thread=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.con.create_function(</span><span class="s4">'REGEXP'</span><span class="s1">, </span><span class="s3">2</span><span class="s1">, _regexp)</span>

        <span class="s0"># This pragma makes writing faster. It disables rollbacks, but we never need them.</span>
        <span class="s0"># PyPy needs the .close() calls here, or sqlite gets twisted up:</span>
        <span class="s0"># https://bitbucket.org/pypy/pypy/issues/2872/default-isolation-mode-is-different-on</span>
        <span class="s1">self.execute(</span><span class="s4">&quot;pragma journal_mode=off&quot;</span><span class="s1">).close()</span>
        <span class="s0"># This pragma makes writing faster.</span>
        <span class="s1">self.execute(</span><span class="s4">&quot;pragma synchronous=off&quot;</span><span class="s1">).close()</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s0">&quot;&quot;&quot;If needed, close the connection.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.con </span><span class="s2">is not None and </span><span class="s1">self.filename != </span><span class="s4">&quot;:memory:&quot;</span><span class="s1">:</span>
            <span class="s1">self.con.close()</span>
            <span class="s1">self.con = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">if </span><span class="s1">self.nest == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self._connect()</span>
            <span class="s1">self.con.__enter__()</span>
        <span class="s1">self.nest += </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self, exc_type, exc_value, traceback):</span>
        <span class="s1">self.nest -= </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">self.nest == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.con.__exit__(exc_type, exc_value, traceback)</span>
                <span class="s1">self.close()</span>
            <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">if </span><span class="s1">self.debug:</span>
                    <span class="s1">self.debug.write(</span><span class="s4">&quot;EXCEPTION from __exit__: {}&quot;</span><span class="s1">.format(exc))</span>
                <span class="s2">raise</span>

    <span class="s2">def </span><span class="s1">execute(self, sql, parameters=()):</span>
        <span class="s0">&quot;&quot;&quot;Same as :meth:`python:sqlite3.Connection.execute`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.debug:</span>
            <span class="s1">tail = </span><span class="s4">&quot; with {!r}&quot;</span><span class="s1">.format(parameters) </span><span class="s2">if </span><span class="s1">parameters </span><span class="s2">else </span><span class="s4">&quot;&quot;</span>
            <span class="s1">self.debug.write(</span><span class="s4">&quot;Executing {!r}{}&quot;</span><span class="s1">.format(sql, tail))</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.con.execute(sql, parameters)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s0"># In some cases, an error might happen that isn't really an</span>
                <span class="s0"># error.  Try again immediately.</span>
                <span class="s0"># https://github.com/nedbat/coveragepy/issues/1010</span>
                <span class="s2">return </span><span class="s1">self.con.execute(sql, parameters)</span>
        <span class="s2">except </span><span class="s1">sqlite3.Error </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">msg = str(exc)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># `execute` is the first thing we do with the database, so try</span>
                <span class="s0"># hard to provide useful hints if something goes wrong now.</span>
                <span class="s2">with </span><span class="s1">open(self.filename, </span><span class="s4">&quot;rb&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">bad_file:</span>
                    <span class="s1">cov4_sig = </span><span class="s4">b&quot;!coverage.py: This is a private format&quot;</span>
                    <span class="s2">if </span><span class="s1">bad_file.read(len(cov4_sig)) == cov4_sig:</span>
                        <span class="s1">msg = (</span>
                            <span class="s4">&quot;Looks like a coverage 4.x data file. &quot;</span>
                            <span class="s4">&quot;Are you mixing versions of coverage?&quot;</span>
                        <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s2">pass</span>
            <span class="s2">if </span><span class="s1">self.debug:</span>
                <span class="s1">self.debug.write(</span><span class="s4">&quot;EXCEPTION from execute: {}&quot;</span><span class="s1">.format(msg))</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Couldn't use data file {!r}: {}&quot;</span><span class="s1">.format(self.filename, msg))</span>

    <span class="s2">def </span><span class="s1">execute_one(self, sql, parameters=()):</span>
        <span class="s0">&quot;&quot;&quot;Execute a statement and return the one row that results. 
 
        This is like execute(sql, parameters).fetchone(), except it is 
        correct in reading the entire result set.  This will raise an 
        exception if more than one row results. 
 
        Returns a row, or None if there were no rows. 
        &quot;&quot;&quot;</span>
        <span class="s1">rows = list(self.execute(sql, parameters))</span>
        <span class="s2">if </span><span class="s1">len(rows) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">elif </span><span class="s1">len(rows) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">rows[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span><span class="s4">&quot;Sql {!r} shouldn't return {} rows&quot;</span><span class="s1">.format(sql, len(rows)))</span>

    <span class="s2">def </span><span class="s1">executemany(self, sql, data):</span>
        <span class="s0">&quot;&quot;&quot;Same as :meth:`python:sqlite3.Connection.executemany`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.debug:</span>
            <span class="s1">data = list(data)</span>
            <span class="s1">self.debug.write(</span><span class="s4">&quot;Executing many {!r} with {} rows&quot;</span><span class="s1">.format(sql, len(data)))</span>
        <span class="s2">return </span><span class="s1">self.con.executemany(sql, data)</span>

    <span class="s2">def </span><span class="s1">executescript(self, script):</span>
        <span class="s0">&quot;&quot;&quot;Same as :meth:`python:sqlite3.Connection.executescript`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.debug:</span>
            <span class="s1">self.debug.write(</span><span class="s4">&quot;Executing script with {} chars: {}&quot;</span><span class="s1">.format(</span>
                <span class="s1">len(script), clipped_repr(script, </span><span class="s3">100</span><span class="s1">),</span>
            <span class="s1">))</span>
        <span class="s1">self.con.executescript(script)</span>

    <span class="s2">def </span><span class="s1">dump(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a multi-line string, the SQL dump of the database.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">.join(self.con.iterdump())</span>


<span class="s2">def </span><span class="s1">_regexp(text, pattern):</span>
    <span class="s0">&quot;&quot;&quot;A regexp function for SQLite.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">re.search(text, pattern) </span><span class="s2">is not None</span>
</pre>
</body>
</html>