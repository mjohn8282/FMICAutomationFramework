<html>
<head>
<title>scoped_nodes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #d19a66;}
.s4 { color: #98c379;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scoped_nodes.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;</span>
<span class="s0"># Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2011, 2013-2015 Google, Inc.</span>
<span class="s0"># Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2013 Phil Schaf &lt;flying-sheep@web.de&gt;</span>
<span class="s0"># Copyright (c) 2014 Eevee (Alex Munroe) &lt;amunroe@yelp.com&gt;</span>
<span class="s0"># Copyright (c) 2015-2016 Florian Bruhin &lt;me@the-compiler.org&gt;</span>
<span class="s0"># Copyright (c) 2015-2016 Ceridwen &lt;ceridwenv@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2015 Rene Zhang &lt;rz99@cornell.edu&gt;</span>
<span class="s0"># Copyright (c) 2015 Philip Lorenz &lt;philip@bithub.de&gt;</span>
<span class="s0"># Copyright (c) 2016-2017 Derek Gustafson &lt;degustaf@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2017 Łukasz Rogalski &lt;rogalski.91@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 David Euresti &lt;david@dropbox.com&gt;</span>
<span class="s0"># Copyright (c) 2018-2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Ville Skyttä &lt;ville.skytta@iki.fi&gt;</span>
<span class="s0"># Copyright (c) 2018 Anthony Sottile &lt;asottile@umich.edu&gt;</span>
<span class="s0"># Copyright (c) 2018 HoverHell &lt;hoverhell@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Peter de Blanc &lt;peter@standard.ai&gt;</span>
<span class="s0"># Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Tim Martin &lt;tim@asymptotic.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;</span>

<span class="s0"># Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html</span>
<span class="s0"># For details: https://github.com/PyCQA/astroid/blob/master/LICENSE</span>


<span class="s0">&quot;&quot;&quot; 
This module contains the classes for &quot;scoped&quot; node, i.e. which are opening a 
new local scope in the language definition : Module, ClassDef, FunctionDef (and 
Lambda, GeneratorExp, DictComp and SetComp to some extent). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">builtins</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List, Optional</span>

<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">bases</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">context </span><span class="s2">as </span><span class="s1">contextmod</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">decorators </span><span class="s2">as </span><span class="s1">decorators_mod</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">exceptions, manager, mixins, node_classes, util</span>
<span class="s2">from </span><span class="s1">astroid.interpreter </span><span class="s2">import </span><span class="s1">dunder_lookup, objectmodel</span>

<span class="s1">PY39 = sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s1">, </span><span class="s3">9</span><span class="s1">)</span>

<span class="s1">BUILTINS = builtins.__name__</span>
<span class="s1">ITER_METHODS = (</span><span class="s4">&quot;__iter__&quot;</span><span class="s1">, </span><span class="s4">&quot;__getitem__&quot;</span><span class="s1">)</span>
<span class="s1">EXCEPTION_BASE_CLASSES = frozenset({</span><span class="s4">&quot;Exception&quot;</span><span class="s1">, </span><span class="s4">&quot;BaseException&quot;</span><span class="s1">})</span>
<span class="s1">objects = util.lazy_import(</span><span class="s4">&quot;objects&quot;</span><span class="s1">)</span>
<span class="s1">BUILTIN_DESCRIPTORS = frozenset(</span>
    <span class="s1">{</span><span class="s4">&quot;classmethod&quot;</span><span class="s1">, </span><span class="s4">&quot;staticmethod&quot;</span><span class="s1">, </span><span class="s4">&quot;builtins.classmethod&quot;</span><span class="s1">, </span><span class="s4">&quot;builtins.staticmethod&quot;</span><span class="s1">}</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_c3_merge(sequences, cls, context):</span>
    <span class="s0">&quot;&quot;&quot;Merges MROs in *sequences* to a single MRO using the C3 algorithm. 
 
    Adapted from http://www.python.org/download/releases/2.3/mro/. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">result = []</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">sequences = [s </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">sequences </span><span class="s2">if </span><span class="s1">s]  </span><span class="s0"># purge empty sequences</span>
        <span class="s2">if not </span><span class="s1">sequences:</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">for </span><span class="s1">s1 </span><span class="s2">in </span><span class="s1">sequences:  </span><span class="s0"># find merge candidates among seq heads</span>
            <span class="s1">candidate = s1[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">s2 </span><span class="s2">in </span><span class="s1">sequences:</span>
                <span class="s2">if </span><span class="s1">candidate </span><span class="s2">in </span><span class="s1">s2[</span><span class="s3">1</span><span class="s1">:]:</span>
                    <span class="s1">candidate = </span><span class="s2">None</span>
                    <span class="s2">break  </span><span class="s0"># reject the current head, it appears later</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s2">if not </span><span class="s1">candidate:</span>
            <span class="s0"># Show all the remaining bases, which were considered as</span>
            <span class="s0"># candidates for the next mro sequence.</span>
            <span class="s2">raise </span><span class="s1">exceptions.InconsistentMroError(</span>
                <span class="s1">message=</span><span class="s4">&quot;Cannot create a consistent method resolution order &quot;</span>
                <span class="s4">&quot;for MROs {mros} of class {cls!r}.&quot;</span><span class="s1">,</span>
                <span class="s1">mros=sequences,</span>
                <span class="s1">cls=cls,</span>
                <span class="s1">context=context,</span>
            <span class="s1">)</span>

        <span class="s1">result.append(candidate)</span>
        <span class="s0"># remove the chosen candidate</span>
        <span class="s2">for </span><span class="s1">seq </span><span class="s2">in </span><span class="s1">sequences:</span>
            <span class="s2">if </span><span class="s1">seq[</span><span class="s3">0</span><span class="s1">] == candidate:</span>
                <span class="s2">del </span><span class="s1">seq[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">clean_typing_generic_mro(sequences: List[List[</span><span class="s4">&quot;ClassDef&quot;</span><span class="s1">]]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;A class can inherit from typing.Generic directly, as base, 
    and as base of bases. The merged MRO must however only contain the last entry. 
    To prepare for _c3_merge, remove some typing.Generic entries from 
    sequences if multiple are present. 
 
    This method will check if Generic is in inferred_bases and also 
    part of bases_mro. If true, remove it from inferred_bases 
    as well as its entry the bases_mro. 
 
    Format sequences: [[self]] + bases_mro + [inferred_bases] 
    &quot;&quot;&quot;</span>
    <span class="s1">bases_mro = sequences[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">inferred_bases = sequences[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0"># Check if Generic is part of inferred_bases</span>
    <span class="s2">for </span><span class="s1">i, base </span><span class="s2">in </span><span class="s1">enumerate(inferred_bases):</span>
        <span class="s2">if </span><span class="s1">base.qname() == </span><span class="s4">&quot;typing.Generic&quot;</span><span class="s1">:</span>
            <span class="s1">position_in_inferred_bases = i</span>
            <span class="s2">break</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s0"># Check if also part of bases_mro</span>
    <span class="s0"># Ignore entry for typing.Generic</span>
    <span class="s2">for </span><span class="s1">i, seq </span><span class="s2">in </span><span class="s1">enumerate(bases_mro):</span>
        <span class="s2">if </span><span class="s1">i == position_in_inferred_bases:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">any(base.qname() == </span><span class="s4">&quot;typing.Generic&quot; </span><span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">seq):</span>
            <span class="s2">break</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s0"># Found multiple Generics in mro, remove entry from inferred_bases</span>
    <span class="s0"># and the corresponding one from bases_mro</span>
    <span class="s1">inferred_bases.pop(position_in_inferred_bases)</span>
    <span class="s1">bases_mro.pop(position_in_inferred_bases)</span>


<span class="s2">def </span><span class="s1">clean_duplicates_mro(sequences, cls, context):</span>
    <span class="s2">for </span><span class="s1">sequence </span><span class="s2">in </span><span class="s1">sequences:</span>
        <span class="s1">names = [</span>
            <span class="s1">(node.lineno, node.qname()) </span><span class="s2">if </span><span class="s1">node.name </span><span class="s2">else None for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">sequence</span>
        <span class="s1">]</span>
        <span class="s1">last_index = dict(map(reversed, enumerate(names)))</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">and </span><span class="s1">names[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">is not None and </span><span class="s1">last_index[names[</span><span class="s3">0</span><span class="s1">]] != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">exceptions.DuplicateBasesError(</span>
                <span class="s1">message=</span><span class="s4">&quot;Duplicates found in MROs {mros} for {cls!r}.&quot;</span><span class="s1">,</span>
                <span class="s1">mros=sequences,</span>
                <span class="s1">cls=cls,</span>
                <span class="s1">context=context,</span>
            <span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">[</span>
            <span class="s1">node</span>
            <span class="s2">for </span><span class="s1">i, (node, name) </span><span class="s2">in </span><span class="s1">enumerate(zip(sequence, names))</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">is None or </span><span class="s1">last_index[name] == i</span>
        <span class="s1">]</span>


<span class="s2">def </span><span class="s1">function_to_method(n, klass):</span>
    <span class="s2">if </span><span class="s1">isinstance(n, FunctionDef):</span>
        <span class="s2">if </span><span class="s1">n.type == </span><span class="s4">&quot;classmethod&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bases.BoundMethod(n, klass)</span>
        <span class="s2">if </span><span class="s1">n.type == </span><span class="s4">&quot;property&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">n</span>
        <span class="s2">if </span><span class="s1">n.type != </span><span class="s4">&quot;staticmethod&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bases.UnboundMethod(n)</span>
    <span class="s2">return </span><span class="s1">n</span>


<span class="s1">MANAGER = manager.AstroidManager()</span>


<span class="s2">def </span><span class="s1">builtin_lookup(name):</span>
    <span class="s0">&quot;&quot;&quot;lookup a name into the builtin module 
    return the list of matching statements and the astroid for the builtin 
    module 
    &quot;&quot;&quot;</span>
    <span class="s1">builtin_astroid = MANAGER.ast_from_module(builtins)</span>
    <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;__dict__&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">builtin_astroid, ()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">stmts = builtin_astroid.locals[name]</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
        <span class="s1">stmts = ()</span>
    <span class="s2">return </span><span class="s1">builtin_astroid, stmts</span>


<span class="s0"># TODO move this Mixin to mixins.py; problem: 'FunctionDef' in _scope_lookup</span>
<span class="s2">class </span><span class="s1">LocalsDictNodeNG(node_classes.LookupMixIn, node_classes.NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;this class provides locals handling common to Module, FunctionDef 
    and ClassDef nodes, including a dict like interface for direct access 
    to locals information 
    &quot;&quot;&quot;</span>

    <span class="s0"># attributes below are set by the builder module or by raw factories</span>

    <span class="s1">locals = {}</span>
    <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining the local. 
 
    :type: dict(str, NodeNG) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">qname(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the 'qualified' name of the node. 
 
        For example: module.name, module.class.name ... 
 
        :returns: The qualified name. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member; github.com/pycqa/astroid/issues/278</span>
        <span class="s2">if </span><span class="s1">self.parent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.name</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">self.parent.frame().qname()</span><span class="s5">}</span><span class="s4">.</span><span class="s5">{</span><span class="s1">self.name</span><span class="s5">}</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">frame(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent frame node. 
 
        A frame node is a :class:`Module`, :class:`FunctionDef`, 
        or :class:`ClassDef`. 
 
        :returns: The first parent frame node. 
        :rtype: Module or FunctionDef or ClassDef 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">scope(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent node defining a new scope. 
 
        :returns: The first parent scope node. 
        :rtype: Module or FunctionDef or ClassDef or Lambda or GenExpr 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_scope_lookup(self, node, name, offset=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;XXX method for interfacing the scope lookup&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">stmts = node._filter_stmts(self.locals[name], self, offset)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">stmts = ()</span>
        <span class="s2">if </span><span class="s1">stmts:</span>
            <span class="s2">return </span><span class="s1">self, stmts</span>
        <span class="s2">if </span><span class="s1">self.parent:  </span><span class="s0"># i.e. not Module</span>
            <span class="s0"># nested scope: if parent scope is a function, that's fine</span>
            <span class="s0"># else jump to the module</span>
            <span class="s1">pscope = self.parent.scope()</span>
            <span class="s2">if not </span><span class="s1">pscope.is_function:</span>
                <span class="s1">pscope = pscope.root()</span>
            <span class="s2">return </span><span class="s1">pscope.scope_lookup(node, name)</span>
        <span class="s2">return </span><span class="s1">builtin_lookup(name)  </span><span class="s0"># Module</span>

    <span class="s2">def </span><span class="s1">set_local(self, name, stmt):</span>
        <span class="s0">&quot;&quot;&quot;Define that the given name is declared in the given statement node. 
 
        .. seealso:: :meth:`scope` 
 
        :param name: The name that is being defined. 
        :type name: str 
 
        :param stmt: The statement that defines the given name. 
        :type stmt: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s0"># assert not stmt in self.locals.get(name, ()), (self, stmt)</span>
        <span class="s1">self.locals.setdefault(name, []).append(stmt)</span>

    <span class="s1">__setitem__ = set_local</span>

    <span class="s2">def </span><span class="s1">_append_node(self, child):</span>
        <span class="s0">&quot;&quot;&quot;append a child, linking it in the tree&quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member; depending by the class</span>
        <span class="s0"># which uses the current class as a mixin or base class.</span>
        <span class="s0"># It's rewritten in 2.0, so it makes no sense for now</span>
        <span class="s0"># to spend development time on it.</span>
        <span class="s1">self.body.append(child)</span>
        <span class="s1">child.parent = self</span>

    <span class="s2">def </span><span class="s1">add_local_node(self, child_node, name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Append a child that should alter the locals of this scope node. 
 
        :param child_node: The child node that will alter locals. 
        :type child_node: NodeNG 
 
        :param name: The name of the local that will be altered by 
            the given child node. 
        :type name: str or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name != </span><span class="s4">&quot;__class__&quot;</span><span class="s1">:</span>
            <span class="s0"># add __class__ node as a child will cause infinite recursion later!</span>
            <span class="s1">self._append_node(child_node)</span>
        <span class="s1">self.set_local(name </span><span class="s2">or </span><span class="s1">child_node.name, child_node)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self, item):</span>
        <span class="s0">&quot;&quot;&quot;The first node the defines the given local. 
 
        :param item: The name of the locally defined object. 
        :type item: str 
 
        :raises KeyError: If the name is not defined. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.locals[item][</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over the names of locals defined in this scoped node. 
 
        :returns: The names of the defined locals. 
        :rtype: iterable(str) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">iter(self.keys())</span>

    <span class="s2">def </span><span class="s1">keys(self):</span>
        <span class="s0">&quot;&quot;&quot;The names of locals defined in this scoped node. 
 
        :returns: The names of the defined locals. 
        :rtype: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.locals.keys())</span>

    <span class="s2">def </span><span class="s1">values(self):</span>
        <span class="s0">&quot;&quot;&quot;The nodes that define the locals in this scoped node. 
 
        :returns: The nodes that define locals. 
        :rtype: list(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self[key] </span><span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self.keys()]</span>

    <span class="s2">def </span><span class="s1">items(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the names of the locals and the node that defines the local. 
 
        :returns: The names of locals and their associated node. 
        :rtype: list(tuple(str, NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(zip(self.keys(), self.values()))</span>

    <span class="s2">def </span><span class="s1">__contains__(self, name):</span>
        <span class="s0">&quot;&quot;&quot;Check if a local is defined in this scope. 
 
        :param name: The name of the local to check for. 
        :type name: str 
 
        :returns: True if this node has a local of the given name, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.locals</span>


<span class="s2">class </span><span class="s1">Module(LocalsDictNodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Module` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('import astroid') 
    &gt;&gt;&gt; node 
    &lt;Import l.1 at 0x7f23b2e4e5c0&gt; 
    &gt;&gt;&gt; node.parent 
    &lt;Module l.0 at 0x7f23b2e4eda0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">,)</span>

    <span class="s1">fromlineno = </span><span class="s3">0</span>
    <span class="s4">&quot;&quot;&quot;The first line that this node appears on in the source code. 
 
    :type: int or None 
    &quot;&quot;&quot;</span>
    <span class="s1">lineno = </span><span class="s3">0</span>
    <span class="s4">&quot;&quot;&quot;The line that this node appears on in the source code. 
 
    :type: int or None 
    &quot;&quot;&quot;</span>

    <span class="s0"># attributes below are set by the builder module or by raw factories</span>

    <span class="s1">file = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The path to the file that this ast has been extracted from. 
 
    This will be ``None`` when the representation has been built from a 
    built-in module. 
 
    :type: str or None 
    &quot;&quot;&quot;</span>
    <span class="s1">file_bytes = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The string/bytes that this ast was built from. 
 
    :type: str or bytes or None 
    &quot;&quot;&quot;</span>
    <span class="s1">file_encoding = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The encoding of the source file. 
 
    This is used to get unicode out of a source file. 
    Python 2 only. 
 
    :type: str or None 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The name of the module. 
 
    :type: str or None 
    &quot;&quot;&quot;</span>
    <span class="s1">pure_python = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Whether the ast was built from source. 
 
    :type: bool or None 
    &quot;&quot;&quot;</span>
    <span class="s1">package = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Whether the node represents a package or a module. 
 
    :type: bool or None 
    &quot;&quot;&quot;</span>
    <span class="s1">globals = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;A map of the name of a global variable to the node defining the global. 
 
    :type: dict(str, NodeNG) 
    &quot;&quot;&quot;</span>

    <span class="s0"># Future imports</span>
    <span class="s1">future_imports = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The imports from ``__future__``. 
 
    :type: set(str) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">special_attributes = objectmodel.ModuleModel()</span>
    <span class="s4">&quot;&quot;&quot;The names of special attributes that this module has. 
 
    :type: objectmodel.ModuleModel 
    &quot;&quot;&quot;</span>

    <span class="s0"># names of module attributes available through the global scope</span>
    <span class="s1">scope_attrs = {</span><span class="s4">&quot;__name__&quot;</span><span class="s1">, </span><span class="s4">&quot;__doc__&quot;</span><span class="s1">, </span><span class="s4">&quot;__file__&quot;</span><span class="s1">, </span><span class="s4">&quot;__path__&quot;</span><span class="s1">, </span><span class="s4">&quot;__package__&quot;</span><span class="s1">}</span>
    <span class="s4">&quot;&quot;&quot;The names of module attributes available through the global scope. 
 
    :type: str(str) 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span>
        <span class="s4">&quot;name&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;doc&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;file&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;path&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;package&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;pure_python&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;future_imports&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">, </span><span class="s4">&quot;globals&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">name,</span>
        <span class="s1">doc,</span>
        <span class="s1">file=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">path: Optional[List[str]] = </span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">package=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">parent=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">pure_python=</span><span class="s2">True</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name of the module. 
        :type name: str 
 
        :param doc: The module docstring. 
        :type doc: str 
 
        :param file: The path to the file that this ast has been extracted from. 
        :type file: str or None 
 
        :param path: 
        :type path: Optional[List[str]] 
 
        :param package: Whether the node represents a package or a module. 
        :type package: bool or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
 
        :param pure_python: Whether the ast was built from source. 
        :type pure_python: bool or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.doc = doc</span>
        <span class="s1">self.file = file</span>
        <span class="s1">self.path = path</span>
        <span class="s1">self.package = package</span>
        <span class="s1">self.parent = parent</span>
        <span class="s1">self.pure_python = pure_python</span>
        <span class="s1">self.locals = self.globals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining the local. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.body = []</span>
        <span class="s4">&quot;&quot;&quot;The contents of the module. 
 
        :type: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.future_imports = set()</span>

    <span class="s0"># pylint: enable=redefined-builtin</span>

    <span class="s2">def </span><span class="s1">postinit(self, body=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param body: The contents of the module. 
        :type body: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.body = body</span>

    <span class="s2">def </span><span class="s1">_get_stream(self):</span>
        <span class="s2">if </span><span class="s1">self.file_bytes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">io.BytesIO(self.file_bytes)</span>
        <span class="s2">if </span><span class="s1">self.file </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># pylint: disable=consider-using-with</span>
            <span class="s1">stream = open(self.file, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">stream</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">stream(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a stream to the underlying file or bytes. 
 
        :type: file or io.BytesIO or None 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_stream()</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from where this node starts to where this node ends. 
 
        :param lineno: Unused. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to. 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fromlineno, self.tolineno</span>

    <span class="s2">def </span><span class="s1">scope_lookup(self, node, name, offset=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Lookup where the given variable is assigned. 
 
        :param node: The node to look for assignments up to. 
            Any assignments after the given node are ignored. 
        :type node: NodeNG 
 
        :param name: The name of the variable to find assignments for. 
        :type name: str 
 
        :param offset: The line offset to filter statements up to. 
        :type offset: int 
 
        :returns: This scope node and the list of assignments associated to the 
            given name according to the scope where it has been found (locals, 
            globals or builtin). 
        :rtype: tuple(str, list(NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.scope_attrs </span><span class="s2">and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.locals:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self, self.getattr(name)</span>
            <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
                <span class="s2">return </span><span class="s1">self, ()</span>
        <span class="s2">return </span><span class="s1">self._scope_lookup(node, name, offset)</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.module&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">display_type(self):</span>
        <span class="s0">&quot;&quot;&quot;A human readable type of this node. 
 
        :returns: The type of this node. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;Module&quot;</span>

    <span class="s2">def </span><span class="s1">getattr(self, name, context=</span><span class="s2">None</span><span class="s1">, ignore_locals=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">name:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self, attribute=name, context=context</span>
            <span class="s1">)</span>

        <span class="s1">result = []</span>
        <span class="s1">name_in_locals = name </span><span class="s2">in </span><span class="s1">self.locals</span>

        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.special_attributes </span><span class="s2">and not </span><span class="s1">ignore_locals </span><span class="s2">and not </span><span class="s1">name_in_locals:</span>
            <span class="s1">result = [self.special_attributes.lookup(name)]</span>
        <span class="s2">elif not </span><span class="s1">ignore_locals </span><span class="s2">and </span><span class="s1">name_in_locals:</span>
            <span class="s1">result = self.locals[name]</span>
        <span class="s2">elif </span><span class="s1">self.package:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">result = [self.import_module(name, relative_only=</span><span class="s2">True</span><span class="s1">)]</span>
            <span class="s2">except </span><span class="s1">(exceptions.AstroidBuildingError, SyntaxError) </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                    <span class="s1">target=self, attribute=name, context=context</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
        <span class="s1">result = [n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">result </span><span class="s2">if not </span><span class="s1">isinstance(n, node_classes.DelName)]</span>
        <span class="s2">if </span><span class="s1">result:</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
            <span class="s1">target=self, attribute=name, context=context</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">igetattr(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Infer the possible values of the given variable. 
 
        :param name: The name of the variable to infer. 
        :type name: str 
 
        :returns: The inferred possible values. 
        :rtype: iterable(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s0"># set lookup name since this is necessary to infer on import nodes for</span>
        <span class="s0"># instance</span>
        <span class="s1">context = contextmod.copy_context(context)</span>
        <span class="s1">context.lookupname = name</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bases._infer_stmts(self.getattr(name, context), context, frame=self)</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError </span><span class="s2">as </span><span class="s1">error:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s1">error.message, target=self, attribute=name, context=context</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">error</span>

    <span class="s2">def </span><span class="s1">fully_defined(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if this module has been build from a .py file. 
 
        If so, the module contains a complete representation, 
        including the code. 
 
        :returns: True if the module has been built from a .py file. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.file </span><span class="s2">is not None and </span><span class="s1">self.file.endswith(</span><span class="s4">&quot;.py&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">statement(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent node, including self, marked as statement node. 
 
        :returns: The first parent statement. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">previous_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The previous sibling statement. 
 
        :returns: The previous sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">next_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The next sibling statement node. 
 
        :returns: The next sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>

    <span class="s1">_absolute_import_activated = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">absolute_import_activated(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether :pep:`328` absolute import behaviour has been enabled. 
 
        :returns: True if :pep:`328` has been enabled, False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._absolute_import_activated</span>

    <span class="s2">def </span><span class="s1">import_module(self, modname, relative_only=</span><span class="s2">False</span><span class="s1">, level=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the ast for a given module as if imported from this module. 
 
        :param modname: The name of the module to &quot;import&quot;. 
        :type modname: str 
 
        :param relative_only: Whether to only consider relative imports. 
        :type relative_only: bool 
 
        :param level: The level of relative import. 
        :type level: int or None 
 
        :returns: The imported module ast. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">relative_only </span><span class="s2">and </span><span class="s1">level </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">level = </span><span class="s3">0</span>
        <span class="s1">absmodname = self.relative_to_absolute_name(modname, level)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">MANAGER.ast_from_module_name(absmodname)</span>
        <span class="s2">except </span><span class="s1">exceptions.AstroidBuildingError:</span>
            <span class="s0"># we only want to import a sub module or package of this module,</span>
            <span class="s0"># skip here</span>
            <span class="s2">if </span><span class="s1">relative_only:</span>
                <span class="s2">raise</span>
        <span class="s2">return </span><span class="s1">MANAGER.ast_from_module_name(modname)</span>

    <span class="s2">def </span><span class="s1">relative_to_absolute_name(self, modname, level):</span>
        <span class="s0">&quot;&quot;&quot;Get the absolute module name for a relative import. 
 
        The relative import can be implicit or explicit. 
 
        :param modname: The module name to convert. 
        :type modname: str 
 
        :param level: The level of relative import. 
        :type level: int 
 
        :returns: The absolute module name. 
        :rtype: str 
 
        :raises TooManyLevelsError: When the relative import refers to a 
            module too far above this one. 
        &quot;&quot;&quot;</span>
        <span class="s0"># XXX this returns non sens when called on an absolute import</span>
        <span class="s0"># like 'pylint.checkers.astroid.utils'</span>
        <span class="s0"># XXX doesn't return absolute name if self.name isn't absolute name</span>
        <span class="s2">if </span><span class="s1">self.absolute_import_activated() </span><span class="s2">and </span><span class="s1">level </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">modname</span>
        <span class="s2">if </span><span class="s1">level:</span>
            <span class="s2">if </span><span class="s1">self.package:</span>
                <span class="s1">level = level - </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">level </span><span class="s2">and </span><span class="s1">self.name.count(</span><span class="s4">&quot;.&quot;</span><span class="s1">) &lt; level:</span>
                <span class="s2">raise </span><span class="s1">exceptions.TooManyLevelsError(level=level, name=self.name)</span>

            <span class="s1">package_name = self.name.rsplit(</span><span class="s4">&quot;.&quot;</span><span class="s1">, level)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">self.package:</span>
            <span class="s1">package_name = self.name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">package_name = self.name.rsplit(</span><span class="s4">&quot;.&quot;</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">package_name:</span>
            <span class="s2">if not </span><span class="s1">modname:</span>
                <span class="s2">return </span><span class="s1">package_name</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">package_name</span><span class="s5">}</span><span class="s4">.</span><span class="s5">{</span><span class="s1">modname</span><span class="s5">}</span><span class="s4">&quot;</span>
        <span class="s2">return </span><span class="s1">modname</span>

    <span class="s2">def </span><span class="s1">wildcard_import_names(self):</span>
        <span class="s0">&quot;&quot;&quot;The list of imported names when this module is 'wildcard imported'. 
 
        It doesn't include the '__builtins__' name which is added by the 
        current CPython implementation of wildcard imports. 
 
        :returns: The list of imported names. 
        :rtype: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s0"># We separate the different steps of lookup in try/excepts</span>
        <span class="s0"># to avoid catching too many Exceptions</span>
        <span class="s1">default = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.keys() </span><span class="s2">if not </span><span class="s1">name.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">)]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">all_values = self[</span><span class="s4">&quot;__all__&quot;</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">return </span><span class="s1">default</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">explicit = next(all_values.assigned_stmts())</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">default</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># not an assignment node</span>
            <span class="s0"># XXX infer?</span>
            <span class="s2">return </span><span class="s1">default</span>

        <span class="s0"># Try our best to detect the exported name.</span>
        <span class="s1">inferred = []</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">explicit = next(explicit.infer())</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">default</span>
        <span class="s2">if not </span><span class="s1">isinstance(explicit, (node_classes.Tuple, node_classes.List)):</span>
            <span class="s2">return </span><span class="s1">default</span>

        <span class="s1">str_const = </span><span class="s2">lambda </span><span class="s1">node: (</span>
            <span class="s1">isinstance(node, node_classes.Const) </span><span class="s2">and </span><span class="s1">isinstance(node.value, str)</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">explicit.elts:</span>
            <span class="s2">if </span><span class="s1">str_const(node):</span>
                <span class="s1">inferred.append(node.value)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">inferred_node = next(node.infer())</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">str_const(inferred_node):</span>
                    <span class="s1">inferred.append(inferred_node.value)</span>
        <span class="s2">return </span><span class="s1">inferred</span>

    <span class="s2">def </span><span class="s1">public_names(self):</span>
        <span class="s0">&quot;&quot;&quot;The list of the names that are publicly available in this module. 
 
        :returns: The list of publc names. 
        :rtype: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.keys() </span><span class="s2">if not </span><span class="s1">name.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`Module` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.body</span>


<span class="s2">class </span><span class="s1">ComprehensionScope(LocalsDictNodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Scoping for different types of comprehensions.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">frame(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent frame node. 
 
        A frame node is a :class:`Module`, :class:`FunctionDef`, 
        or :class:`ClassDef`. 
 
        :returns: The first parent frame node. 
        :rtype: Module or FunctionDef or ClassDef 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parent.frame()</span>

    <span class="s1">scope_lookup = LocalsDictNodeNG._scope_lookup</span>


<span class="s2">class </span><span class="s1">GeneratorExp(ComprehensionScope):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.GeneratorExp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('(thing for thing in things if thing)') 
    &gt;&gt;&gt; node 
    &lt;GeneratorExp l.1 at 0x7f23b2e4e400&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;elt&quot;</span><span class="s1">, </span><span class="s4">&quot;generators&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">,)</span>
    <span class="s1">elt = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The element that forms the output of the expression. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">generators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The generators that are looped through. 
 
    :type: list(Comprehension) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining the local. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, elt=</span><span class="s2">None</span><span class="s1">, generators=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param elt: The element that forms the output of the expression. 
        :type elt: NodeNG or None 
 
        :param generators: The generators that are looped through. 
        :type generators: list(Comprehension) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.elt = elt</span>
        <span class="s2">if </span><span class="s1">generators </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.generators = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generators = generators</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`GeneratorExp` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.elt</span>

        <span class="s2">yield from </span><span class="s1">self.generators</span>


<span class="s2">class </span><span class="s1">DictComp(ComprehensionScope):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.DictComp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('{k:v for k, v in things if k &gt; v}') 
    &gt;&gt;&gt; node 
    &lt;DictComp l.1 at 0x7f23b2e41d68&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;key&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">, </span><span class="s4">&quot;generators&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">,)</span>
    <span class="s1">key = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What produces the keys. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What produces the values. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">generators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The generators that are looped through. 
 
    :type: list(Comprehension) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining the local. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, key=</span><span class="s2">None</span><span class="s1">, value=</span><span class="s2">None</span><span class="s1">, generators=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param key: What produces the keys. 
        :type key: NodeNG or None 
 
        :param value: What produces the values. 
        :type value: NodeNG or None 
 
        :param generators: The generators that are looped through. 
        :type generators: list(Comprehension) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.key = key</span>
        <span class="s1">self.value = value</span>
        <span class="s2">if </span><span class="s1">generators </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.generators = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generators = generators</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`DictComp` this is always :class:`Uninferable`. 
        :rtype: Uninferable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.key</span>
        <span class="s2">yield </span><span class="s1">self.value</span>

        <span class="s2">yield from </span><span class="s1">self.generators</span>


<span class="s2">class </span><span class="s1">SetComp(ComprehensionScope):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.SetComp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('{thing for thing in things if thing}') 
    &gt;&gt;&gt; node 
    &lt;SetComp l.1 at 0x7f23b2e41898&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;elt&quot;</span><span class="s1">, </span><span class="s4">&quot;generators&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">,)</span>
    <span class="s1">elt = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The element that forms the output of the expression. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">generators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The generators that are looped through. 
 
    :type: list(Comprehension) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining the local. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, elt=</span><span class="s2">None</span><span class="s1">, generators=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param elt: The element that forms the output of the expression. 
        :type elt: NodeNG or None 
 
        :param generators: The generators that are looped through. 
        :type generators: list(Comprehension) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.elt = elt</span>
        <span class="s2">if </span><span class="s1">generators </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.generators = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.generators = generators</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`SetComp` this is always :class:`Uninferable`. 
        :rtype: Uninferable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.elt</span>

        <span class="s2">yield from </span><span class="s1">self.generators</span>


<span class="s2">class </span><span class="s1">_ListComp(node_classes.NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ListComp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('[thing for thing in things if thing]') 
    &gt;&gt;&gt; node 
    &lt;ListComp l.1 at 0x7f23b2e418d0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;elt&quot;</span><span class="s1">, </span><span class="s4">&quot;generators&quot;</span><span class="s1">)</span>
    <span class="s1">elt = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The element that forms the output of the expression. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">generators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The generators that are looped through. 
 
    :type: list(Comprehension) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, elt=</span><span class="s2">None</span><span class="s1">, generators=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param elt: The element that forms the output of the expression. 
        :type elt: NodeNG or None 
 
        :param generators: The generators that are looped through. 
        :type generators: list(Comprehension) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.elt = elt</span>
        <span class="s1">self.generators = generators</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`ListComp` this is always :class:`Uninferable`. 
        :rtype: Uninferable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.elt</span>

        <span class="s2">yield from </span><span class="s1">self.generators</span>


<span class="s2">class </span><span class="s1">ListComp(_ListComp, ComprehensionScope):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ListComp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('[thing for thing in things if thing]') 
    &gt;&gt;&gt; node 
    &lt;ListComp l.1 at 0x7f23b2e418d0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining it. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>


<span class="s2">def </span><span class="s1">_infer_decorator_callchain(node):</span>
    <span class="s0">&quot;&quot;&quot;Detect decorator call chaining and see if the end result is a 
    static or a classmethod. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isinstance(node, FunctionDef):</span>
        <span class="s2">return None</span>
    <span class="s2">if not </span><span class="s1">node.parent:</span>
        <span class="s2">return None</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">result = next(node.infer_call_result(node.parent))</span>
    <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
        <span class="s2">return None</span>
    <span class="s2">if </span><span class="s1">isinstance(result, bases.Instance):</span>
        <span class="s1">result = result._proxied</span>
    <span class="s2">if </span><span class="s1">isinstance(result, ClassDef):</span>
        <span class="s2">if </span><span class="s1">result.is_subtype_of(</span><span class="s4">&quot;%s.classmethod&quot; </span><span class="s1">% BUILTINS):</span>
            <span class="s2">return </span><span class="s4">&quot;classmethod&quot;</span>
        <span class="s2">if </span><span class="s1">result.is_subtype_of(</span><span class="s4">&quot;%s.staticmethod&quot; </span><span class="s1">% BUILTINS):</span>
            <span class="s2">return </span><span class="s4">&quot;staticmethod&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(result, FunctionDef):</span>
        <span class="s2">if not </span><span class="s1">result.decorators:</span>
            <span class="s2">return None</span>
        <span class="s0"># Determine if this function is decorated with one of the builtin descriptors we want.</span>
        <span class="s2">for </span><span class="s1">decorator </span><span class="s2">in </span><span class="s1">result.decorators.nodes:</span>
            <span class="s2">if </span><span class="s1">isinstance(decorator, node_classes.Name):</span>
                <span class="s2">if </span><span class="s1">decorator.name </span><span class="s2">in </span><span class="s1">BUILTIN_DESCRIPTORS:</span>
                    <span class="s2">return </span><span class="s1">decorator.name</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(decorator, node_classes.Attribute)</span>
                <span class="s2">and </span><span class="s1">isinstance(decorator.expr, node_classes.Name)</span>
                <span class="s2">and </span><span class="s1">decorator.expr.name == BUILTINS</span>
                <span class="s2">and </span><span class="s1">decorator.attrname </span><span class="s2">in </span><span class="s1">BUILTIN_DESCRIPTORS</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">decorator.attrname</span>
    <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">Lambda(mixins.FilterStmtsMixin, LocalsDictNodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Lambda` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('lambda arg: arg + 1') 
    &gt;&gt;&gt; node 
    &lt;Lambda.&lt;lambda&gt; l.1 at 0x7f23b2e41518&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;args&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">,)</span>
    <span class="s1">name = </span><span class="s4">&quot;&lt;lambda&gt;&quot;</span>
    <span class="s1">is_lambda = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">implicit_parameters(self):</span>
        <span class="s2">return </span><span class="s3">0</span>

    <span class="s0"># function's type, 'function' | 'method' | 'staticmethod' | 'classmethod'</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether this is a method or function. 
 
        :returns: 'method' if this is a method, 'function' otherwise. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member</span>
        <span class="s2">if </span><span class="s1">self.args.arguments </span><span class="s2">and </span><span class="s1">self.args.arguments[</span><span class="s3">0</span><span class="s1">].name == </span><span class="s4">&quot;self&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.parent.scope(), ClassDef):</span>
                <span class="s2">return </span><span class="s4">&quot;method&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;function&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining it. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.args = []</span>
        <span class="s4">&quot;&quot;&quot;The arguments that the function takes. 
 
        :type: Arguments or list 
        &quot;&quot;&quot;</span>

        <span class="s1">self.body = []</span>
        <span class="s4">&quot;&quot;&quot;The contents of the function body. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, args, body):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param args: The arguments that the function takes. 
        :type args: Arguments 
 
        :param body: The contents of the function body. 
        :type body: list(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.body = body</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;method&quot; </span><span class="s2">in </span><span class="s1">self.type:</span>
            <span class="s2">return </span><span class="s4">&quot;%s.instancemethod&quot; </span><span class="s1">% BUILTINS</span>
        <span class="s2">return </span><span class="s4">&quot;%s.function&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">display_type(self):</span>
        <span class="s0">&quot;&quot;&quot;A human readable type of this node. 
 
        :returns: The type of this node. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;method&quot; </span><span class="s2">in </span><span class="s1">self.type:</span>
            <span class="s2">return </span><span class="s4">&quot;Method&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;Function&quot;</span>

    <span class="s2">def </span><span class="s1">callable(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether this node defines something that is callable. 
 
        :returns: True if this defines something that is callable, 
            False otherwise. 
            For a :class:`Lambda` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">argnames(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the names of each of the arguments. 
 
        :returns: The names of the arguments. 
        :rtype: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member; github.com/pycqa/astroid/issues/291</span>
        <span class="s0"># args is in fact redefined later on by postinit. Can't be changed</span>
        <span class="s0"># to None due to a strong interaction between Lambda and FunctionDef.</span>

        <span class="s2">if </span><span class="s1">self.args.arguments:  </span><span class="s0"># maybe None with builtin functions</span>
            <span class="s1">names = _rec_get_names(self.args.arguments)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">names = []</span>
        <span class="s2">if </span><span class="s1">self.args.vararg:</span>
            <span class="s1">names.append(self.args.vararg)</span>
        <span class="s2">if </span><span class="s1">self.args.kwarg:</span>
            <span class="s1">names.append(self.args.kwarg)</span>
        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Infer what the function returns when called. 
 
        :param caller: Unused 
        :type caller: object 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member; github.com/pycqa/astroid/issues/291</span>
        <span class="s0"># args is in fact redefined later on by postinit. Can't be changed</span>
        <span class="s0"># to None due to a strong interaction between Lambda and FunctionDef.</span>
        <span class="s2">return </span><span class="s1">self.body.infer(context)</span>

    <span class="s2">def </span><span class="s1">scope_lookup(self, node, name, offset=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Lookup where the given names is assigned. 
 
        :param node: The node to look for assignments up to. 
            Any assignments after the given node are ignored. 
        :type node: NodeNG 
 
        :param name: The name to find assignments for. 
        :type name: str 
 
        :param offset: The line offset to filter statements up to. 
        :type offset: int 
 
        :returns: This scope node and the list of assignments associated to the 
            given name according to the scope where it has been found (locals, 
            globals or builtin). 
        :rtype: tuple(str, list(NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=no-member; github.com/pycqa/astroid/issues/291</span>
        <span class="s0"># args is in fact redefined later on by postinit. Can't be changed</span>
        <span class="s0"># to None due to a strong interaction between Lambda and FunctionDef.</span>

        <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.args.defaults </span><span class="s2">or </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.args.kw_defaults:</span>
            <span class="s1">frame = self.parent.frame()</span>
            <span class="s0"># line offset to avoid that def func(f=func) resolve the default</span>
            <span class="s0"># value to the defined function</span>
            <span class="s1">offset = -</span><span class="s3">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># check this is not used in function decorators</span>
            <span class="s1">frame = self</span>
        <span class="s2">return </span><span class="s1">frame._scope_lookup(node, name, offset)</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`Lambda` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.args</span>
        <span class="s2">yield </span><span class="s1">self.body</span>


<span class="s2">class </span><span class="s1">FunctionDef(mixins.MultiLineBlockMixin, node_classes.Statement, Lambda):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.FunctionDef`. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    ... def my_func(arg): 
    ...     return arg + 1 
    ... ''') 
    &gt;&gt;&gt; node 
    &lt;FunctionDef.my_func l.2 at 0x7f23b2e71e10&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;decorators&quot;</span><span class="s1">, </span><span class="s4">&quot;args&quot;</span><span class="s1">, </span><span class="s4">&quot;returns&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">,)</span>
    <span class="s1">returns = </span><span class="s2">None</span>
    <span class="s1">decorators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The decorators that are applied to this method or function. 
 
    :type: Decorators or None 
    &quot;&quot;&quot;</span>
    <span class="s1">special_attributes = objectmodel.FunctionModel()</span>
    <span class="s4">&quot;&quot;&quot;The names of special attributes that this function has. 
 
    :type: objectmodel.FunctionModel 
    &quot;&quot;&quot;</span>
    <span class="s1">is_function = </span><span class="s2">True</span>
    <span class="s4">&quot;&quot;&quot;Whether this node indicates a function. 
 
    For a :class:`FunctionDef` this is always ``True``. 
 
    :type: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">type_annotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;If present, this will contain the type annotation passed by a type comment 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">type_comment_args = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot; 
    If present, this will contain the type annotation for arguments 
    passed by a type comment 
    &quot;&quot;&quot;</span>
    <span class="s1">type_comment_returns = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;If present, this will contain the return type annotation, passed by a type comment&quot;&quot;&quot;</span>
    <span class="s0"># attributes below are set by the builder module or by raw factories</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;name&quot;</span><span class="s1">, </span><span class="s4">&quot;doc&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span>
        <span class="s4">&quot;locals&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;_type&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;type_comment_returns&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;type_comment_args&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">_type = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self, name=</span><span class="s2">None</span><span class="s1">, doc=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name of the function. 
        :type name: str or None 
 
        :param doc: The function's docstring. 
        :type doc: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s4">&quot;&quot;&quot;The name of the function. 
 
        :type name: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.doc = doc</span>
        <span class="s4">&quot;&quot;&quot;The function's docstring. 
 
        :type doc: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.instance_attrs = {}</span>
        <span class="s1">super().__init__(lineno, col_offset, parent)</span>
        <span class="s2">if </span><span class="s1">parent:</span>
            <span class="s1">frame = parent.frame()</span>
            <span class="s1">frame.set_local(name, self)</span>

    <span class="s0"># pylint: disable=arguments-differ; different than Lambdas</span>
    <span class="s2">def </span><span class="s1">postinit(</span>
        <span class="s1">self,</span>
        <span class="s1">args,</span>
        <span class="s1">body,</span>
        <span class="s1">decorators=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">returns=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type_comment_returns=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type_comment_args=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param args: The arguments that the function takes. 
        :type args: Arguments or list 
 
        :param body: The contents of the function body. 
        :type body: list(NodeNG) 
 
        :param decorators: The decorators that are applied to this 
            method or function. 
        :type decorators: Decorators or None 
        :params type_comment_returns: 
            The return type annotation passed via a type comment. 
        :params type_comment_args: 
            The args type annotation passed via a type comment. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.decorators = decorators</span>
        <span class="s1">self.returns = returns</span>
        <span class="s1">self.type_comment_returns = type_comment_returns</span>
        <span class="s1">self.type_comment_args = type_comment_args</span>

    <span class="s1">@decorators_mod.cachedproperty</span>
    <span class="s2">def </span><span class="s1">extra_decorators(self):</span>
        <span class="s0">&quot;&quot;&quot;The extra decorators that this function can have. 
 
        Additional decorators are considered when they are used as 
        assignments, as in ``method = staticmethod(method)``. 
        The property will return all the callables that are used for 
        decoration. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s1">frame = self.parent.frame()</span>
        <span class="s2">if not </span><span class="s1">isinstance(frame, ClassDef):</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">decorators = []</span>
        <span class="s2">for </span><span class="s1">assign </span><span class="s2">in </span><span class="s1">frame._get_assign_nodes():</span>
            <span class="s2">if </span><span class="s1">isinstance(assign.value, node_classes.Call) </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">assign.value.func, node_classes.Name</span>
            <span class="s1">):</span>
                <span class="s2">for </span><span class="s1">assign_node </span><span class="s2">in </span><span class="s1">assign.targets:</span>
                    <span class="s2">if not </span><span class="s1">isinstance(assign_node, node_classes.AssignName):</span>
                        <span class="s0"># Support only `name = callable(name)`</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">assign_node.name != self.name:</span>
                        <span class="s0"># Interested only in the assignment nodes that</span>
                        <span class="s0"># decorates the current method.</span>
                        <span class="s2">continue</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">meth = frame[self.name]</span>
                    <span class="s2">except </span><span class="s1">KeyError:</span>
                        <span class="s2">continue</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s0"># Must be a function and in the same frame as the</span>
                        <span class="s0"># original method.</span>
                        <span class="s2">if </span><span class="s1">(</span>
                            <span class="s1">isinstance(meth, FunctionDef)</span>
                            <span class="s2">and </span><span class="s1">assign_node.frame() == frame</span>
                        <span class="s1">):</span>
                            <span class="s1">decorators.append(assign.value)</span>
        <span class="s2">return </span><span class="s1">decorators</span>

    <span class="s1">@decorators_mod.cachedproperty</span>
    <span class="s2">def </span><span class="s1">type(</span>
        <span class="s1">self,</span>
    <span class="s1">):  </span><span class="s0"># pylint: disable=invalid-overridden-method,too-many-return-statements</span>
        <span class="s0">&quot;&quot;&quot;The function type for this node. 
 
        Possible values are: method, function, staticmethod, classmethod. 
 
        :type: str 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">decorator </span><span class="s2">in </span><span class="s1">self.extra_decorators:</span>
            <span class="s2">if </span><span class="s1">decorator.func.name </span><span class="s2">in </span><span class="s1">BUILTIN_DESCRIPTORS:</span>
                <span class="s2">return </span><span class="s1">decorator.func.name</span>

        <span class="s1">frame = self.parent.frame()</span>
        <span class="s1">type_name = </span><span class="s4">&quot;function&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(frame, ClassDef):</span>
            <span class="s2">if </span><span class="s1">self.name == </span><span class="s4">&quot;__new__&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s4">&quot;classmethod&quot;</span>
            <span class="s2">if </span><span class="s1">sys.version_info &gt;= (</span><span class="s3">3</span><span class="s1">, </span><span class="s3">6</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.name == </span><span class="s4">&quot;__init_subclass__&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s4">&quot;classmethod&quot;</span>

            <span class="s1">type_name = </span><span class="s4">&quot;method&quot;</span>

        <span class="s2">if not </span><span class="s1">self.decorators:</span>
            <span class="s2">return </span><span class="s1">type_name</span>

        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.decorators.nodes:</span>
            <span class="s2">if </span><span class="s1">isinstance(node, node_classes.Name):</span>
                <span class="s2">if </span><span class="s1">node.name </span><span class="s2">in </span><span class="s1">BUILTIN_DESCRIPTORS:</span>
                    <span class="s2">return </span><span class="s1">node.name</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(node, node_classes.Attribute)</span>
                <span class="s2">and </span><span class="s1">isinstance(node.expr, node_classes.Name)</span>
                <span class="s2">and </span><span class="s1">node.expr.name == BUILTINS</span>
                <span class="s2">and </span><span class="s1">node.attrname </span><span class="s2">in </span><span class="s1">BUILTIN_DESCRIPTORS</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">node.attrname</span>

            <span class="s2">if </span><span class="s1">isinstance(node, node_classes.Call):</span>
                <span class="s0"># Handle the following case:</span>
                <span class="s0"># @some_decorator(arg1, arg2)</span>
                <span class="s0"># def func(...)</span>
                <span class="s0">#</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">current = next(node.func.infer())</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">continue</span>
                <span class="s1">_type = _infer_decorator_callchain(current)</span>
                <span class="s2">if </span><span class="s1">_type </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">_type</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">node.infer():</span>
                    <span class="s0"># Check to see if this returns a static or a class method.</span>
                    <span class="s1">_type = _infer_decorator_callchain(inferred)</span>
                    <span class="s2">if </span><span class="s1">_type </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">return </span><span class="s1">_type</span>

                    <span class="s2">if not </span><span class="s1">isinstance(inferred, ClassDef):</span>
                        <span class="s2">continue</span>
                    <span class="s2">for </span><span class="s1">ancestor </span><span class="s2">in </span><span class="s1">inferred.ancestors():</span>
                        <span class="s2">if not </span><span class="s1">isinstance(ancestor, ClassDef):</span>
                            <span class="s2">continue</span>
                        <span class="s2">if </span><span class="s1">ancestor.is_subtype_of(</span><span class="s4">&quot;%s.classmethod&quot; </span><span class="s1">% BUILTINS):</span>
                            <span class="s2">return </span><span class="s4">&quot;classmethod&quot;</span>
                        <span class="s2">if </span><span class="s1">ancestor.is_subtype_of(</span><span class="s4">&quot;%s.staticmethod&quot; </span><span class="s1">% BUILTINS):</span>
                            <span class="s2">return </span><span class="s4">&quot;staticmethod&quot;</span>
            <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">type_name</span>

    <span class="s1">@decorators_mod.cachedproperty</span>
    <span class="s2">def </span><span class="s1">fromlineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The first line that this node appears on in the source code. 
 
        :type: int or None 
        &quot;&quot;&quot;</span>
        <span class="s0"># lineno is the line number of the first decorator, we want the def</span>
        <span class="s0"># statement lineno</span>
        <span class="s1">lineno = self.lineno</span>
        <span class="s2">if </span><span class="s1">self.decorators </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lineno += sum(</span>
                <span class="s1">node.tolineno - node.lineno + </span><span class="s3">1 </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.decorators.nodes</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">lineno</span>

    <span class="s1">@decorators_mod.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.args.tolineno</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: Unused. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fromlineno, self.tolineno</span>

    <span class="s2">def </span><span class="s1">getattr(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;this method doesn't look in the instance_attrs dictionary since it's 
        done by an Instance proxy at inference time. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">name:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self, attribute=name, context=context</span>
            <span class="s1">)</span>

        <span class="s1">found_attrs = []</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.instance_attrs:</span>
            <span class="s1">found_attrs = self.instance_attrs[name]</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.special_attributes:</span>
            <span class="s1">found_attrs.append(self.special_attributes.lookup(name))</span>
        <span class="s2">if </span><span class="s1">found_attrs:</span>
            <span class="s2">return </span><span class="s1">found_attrs</span>
        <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(target=self, attribute=name)</span>

    <span class="s2">def </span><span class="s1">igetattr(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Inferred getattr, which returns an iterator of inferred statements.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">bases._infer_stmts(self.getattr(name, context), context, frame=self)</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError </span><span class="s2">as </span><span class="s1">error:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s1">error.message, target=self, attribute=name, context=context</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">error</span>

    <span class="s2">def </span><span class="s1">is_method(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if this function node represents a method. 
 
        :returns: True if this is a method, False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s0"># check we are defined in a ClassDef, because this is usually expected</span>
        <span class="s0"># (e.g. pylint...) when is_method() return True</span>
        <span class="s2">return </span><span class="s1">self.type != </span><span class="s4">&quot;function&quot; </span><span class="s2">and </span><span class="s1">isinstance(self.parent.frame(), ClassDef)</span>

    <span class="s1">@decorators_mod.cached</span>
    <span class="s2">def </span><span class="s1">decoratornames(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the qualified names of each of the decorators on this function. 
 
        :param context: 
            An inference context that can be passed to inference functions 
        :returns: The names of the decorators. 
        :rtype: set(str) 
        &quot;&quot;&quot;</span>
        <span class="s1">result = set()</span>
        <span class="s1">decoratornodes = []</span>
        <span class="s2">if </span><span class="s1">self.decorators </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">decoratornodes += self.decorators.nodes</span>
        <span class="s1">decoratornodes += self.extra_decorators</span>
        <span class="s2">for </span><span class="s1">decnode </span><span class="s2">in </span><span class="s1">decoratornodes:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">infnode </span><span class="s2">in </span><span class="s1">decnode.infer(context=context):</span>
                    <span class="s1">result.add(infnode.qname())</span>
            <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                <span class="s2">continue</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">is_bound(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if the function is bound to an instance or class. 
 
        :returns: True if the function is bound to an instance or class, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.type == </span><span class="s4">&quot;classmethod&quot;</span>

    <span class="s2">def </span><span class="s1">is_abstract(self, pass_is_abstract=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Check if the method is abstract. 
 
        A method is considered abstract if any of the following is true: 
        * The only statement is 'raise NotImplementedError' 
        * The only statement is 'pass' and pass_is_abstract is True 
        * The method is annotated with abc.astractproperty/abc.abstractmethod 
 
        :returns: True if the method is abstract, False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.decorators:</span>
            <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.decorators.nodes:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">inferred = next(node.infer())</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">inferred </span><span class="s2">and </span><span class="s1">inferred.qname() </span><span class="s2">in </span><span class="s1">(</span>
                    <span class="s4">&quot;abc.abstractproperty&quot;</span><span class="s1">,</span>
                    <span class="s4">&quot;abc.abstractmethod&quot;</span><span class="s1">,</span>
                <span class="s1">):</span>
                    <span class="s2">return True</span>

        <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.body:</span>
            <span class="s2">if </span><span class="s1">isinstance(child_node, node_classes.Raise):</span>
                <span class="s2">if </span><span class="s1">child_node.raises_not_implemented():</span>
                    <span class="s2">return True</span>
            <span class="s2">return </span><span class="s1">pass_is_abstract </span><span class="s2">and </span><span class="s1">isinstance(child_node, node_classes.Pass)</span>
        <span class="s0"># empty function is the same as function with a single &quot;pass&quot; statement</span>
        <span class="s2">if </span><span class="s1">pass_is_abstract:</span>
            <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">is_generator(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if this is a generator function. 
 
        :returns: True is this is a generator function, False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(next(self._get_yield_nodes_skip_lambdas(), </span><span class="s2">False</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">infer_call_result(self, caller=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Infer what the function returns when called. 
 
        :returns: What the function returns. 
        :rtype: iterable(NodeNG or Uninferable) or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.is_generator():</span>
            <span class="s2">if </span><span class="s1">isinstance(self, AsyncFunctionDef):</span>
                <span class="s1">generator_cls = bases.AsyncGenerator</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">generator_cls = bases.Generator</span>
            <span class="s1">result = generator_cls(self)</span>
            <span class="s2">yield </span><span class="s1">result</span>
            <span class="s2">return</span>
        <span class="s0"># This is really a gigantic hack to work around metaclass generators</span>
        <span class="s0"># that return transient class-generating functions. Pylint's AST structure</span>
        <span class="s0"># cannot handle a base class object that is only used for calling __new__,</span>
        <span class="s0"># but does not contribute to the inheritance structure itself. We inject</span>
        <span class="s0"># a fake class into the hierarchy here for several well-known metaclass</span>
        <span class="s0"># generators, and filter it out later.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.name == </span><span class="s4">&quot;with_metaclass&quot;</span>
            <span class="s2">and </span><span class="s1">len(self.args.args) == </span><span class="s3">1</span>
            <span class="s2">and </span><span class="s1">self.args.vararg </span><span class="s2">is not None</span>
        <span class="s1">):</span>
            <span class="s1">metaclass = next(caller.args[</span><span class="s3">0</span><span class="s1">].infer(context))</span>
            <span class="s2">if </span><span class="s1">isinstance(metaclass, ClassDef):</span>
                <span class="s1">class_bases = [next(arg.infer(context)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">caller.args[</span><span class="s3">1</span><span class="s1">:]]</span>
                <span class="s1">new_class = ClassDef(name=</span><span class="s4">&quot;temporary_class&quot;</span><span class="s1">)</span>
                <span class="s1">new_class.hide = </span><span class="s2">True</span>
                <span class="s1">new_class.parent = self</span>
                <span class="s1">new_class.postinit(</span>
                    <span class="s1">bases=[base </span><span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">class_bases </span><span class="s2">if </span><span class="s1">base != util.Uninferable],</span>
                    <span class="s1">body=[],</span>
                    <span class="s1">decorators=[],</span>
                    <span class="s1">metaclass=metaclass,</span>
                <span class="s1">)</span>
                <span class="s2">yield </span><span class="s1">new_class</span>
                <span class="s2">return</span>
        <span class="s1">returns = self._get_return_nodes_skip_functions()</span>

        <span class="s1">first_return = next(returns, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">first_return:</span>
            <span class="s2">if </span><span class="s1">self.body </span><span class="s2">and </span><span class="s1">isinstance(self.body[-</span><span class="s3">1</span><span class="s1">], node_classes.Assert):</span>
                <span class="s2">yield </span><span class="s1">node_classes.Const(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s2">return</span>

            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s4">&quot;The function does not have any return statements&quot;</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">returnnode </span><span class="s2">in </span><span class="s1">itertools.chain((first_return,), returns):</span>
            <span class="s2">if </span><span class="s1">returnnode.value </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">node_classes.Const(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">yield from </span><span class="s1">returnnode.value.infer(context)</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">yield </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`FunctionDef` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.decorators </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.decorators</span>

        <span class="s2">yield </span><span class="s1">self.args</span>

        <span class="s2">if </span><span class="s1">self.returns </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.returns</span>

        <span class="s2">yield from </span><span class="s1">self.body</span>

    <span class="s2">def </span><span class="s1">scope_lookup(self, node, name, offset=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Lookup where the given name is assigned.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;__class__&quot;</span><span class="s1">:</span>
            <span class="s0"># __class__ is an implicit closure reference created by the compiler</span>
            <span class="s0"># if any methods in a class body refer to either __class__ or super.</span>
            <span class="s0"># In our case, we want to be able to look it up in the current scope</span>
            <span class="s0"># when `__class__` is being used.</span>
            <span class="s1">frame = self.parent.frame()</span>
            <span class="s2">if </span><span class="s1">isinstance(frame, ClassDef):</span>
                <span class="s2">return </span><span class="s1">self, [frame]</span>
        <span class="s2">return </span><span class="s1">super().scope_lookup(node, name, offset)</span>


<span class="s2">class </span><span class="s1">AsyncFunctionDef(FunctionDef):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.FunctionDef` node. 
 
    A :class:`AsyncFunctionDef` is an asynchronous function 
    created with the `async` keyword. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    async def func(things): 
        async for thing in things: 
            print(thing) 
    ''') 
    &gt;&gt;&gt; node 
    &lt;AsyncFunctionDef.func l.2 at 0x7f23b2e416d8&gt; 
    &gt;&gt;&gt; node.body[0] 
    &lt;AsyncFor l.3 at 0x7f23b2e417b8&gt; 
    &quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_rec_get_names(args, names=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;return a list of all argument names&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">names = []</span>
    <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
        <span class="s2">if </span><span class="s1">isinstance(arg, node_classes.Tuple):</span>
            <span class="s1">_rec_get_names(arg.elts, names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">names.append(arg.name)</span>
    <span class="s2">return </span><span class="s1">names</span>


<span class="s2">def </span><span class="s1">_is_metaclass(klass, seen=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return if the given class can be 
    used as a metaclass. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">klass.name == </span><span class="s4">&quot;type&quot;</span><span class="s1">:</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">seen </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">seen = set()</span>
    <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">klass.bases:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">baseobj </span><span class="s2">in </span><span class="s1">base.infer():</span>
                <span class="s1">baseobj_name = baseobj.qname()</span>
                <span class="s2">if </span><span class="s1">baseobj_name </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s2">continue</span>

                <span class="s1">seen.add(baseobj_name)</span>
                <span class="s2">if </span><span class="s1">isinstance(baseobj, bases.Instance):</span>
                    <span class="s0"># not abstract</span>
                    <span class="s2">return False</span>
                <span class="s2">if </span><span class="s1">baseobj </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">baseobj </span><span class="s2">is </span><span class="s1">klass:</span>
                    <span class="s2">continue</span>
                <span class="s2">if not </span><span class="s1">isinstance(baseobj, ClassDef):</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">baseobj._type == </span><span class="s4">&quot;metaclass&quot;</span><span class="s1">:</span>
                    <span class="s2">return True</span>
                <span class="s2">if </span><span class="s1">_is_metaclass(baseobj, seen):</span>
                    <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">continue</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_class_type(klass, ancestors=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;return a ClassDef node type to differ metaclass and exception 
    from 'regular' classes 
    &quot;&quot;&quot;</span>
    <span class="s0"># XXX we have to store ancestors in case we have an ancestor loop</span>
    <span class="s2">if </span><span class="s1">klass._type </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">klass._type</span>
    <span class="s2">if </span><span class="s1">_is_metaclass(klass):</span>
        <span class="s1">klass._type = </span><span class="s4">&quot;metaclass&quot;</span>
    <span class="s2">elif </span><span class="s1">klass.name.endswith(</span><span class="s4">&quot;Exception&quot;</span><span class="s1">):</span>
        <span class="s1">klass._type = </span><span class="s4">&quot;exception&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">ancestors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ancestors = set()</span>
        <span class="s1">klass_name = klass.qname()</span>
        <span class="s2">if </span><span class="s1">klass_name </span><span class="s2">in </span><span class="s1">ancestors:</span>
            <span class="s0"># XXX we are in loop ancestors, and have found no type</span>
            <span class="s1">klass._type = </span><span class="s4">&quot;class&quot;</span>
            <span class="s2">return </span><span class="s4">&quot;class&quot;</span>
        <span class="s1">ancestors.add(klass_name)</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">klass.ancestors(recurs=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">name = _class_type(base, ancestors)</span>
            <span class="s2">if </span><span class="s1">name != </span><span class="s4">&quot;class&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;metaclass&quot; </span><span class="s2">and not </span><span class="s1">_is_metaclass(klass):</span>
                    <span class="s0"># don't propagate it if the current class</span>
                    <span class="s0"># can't be a metaclass</span>
                    <span class="s2">continue</span>
                <span class="s1">klass._type = base.type</span>
                <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">klass._type </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">klass._type = </span><span class="s4">&quot;class&quot;</span>
    <span class="s2">return </span><span class="s1">klass._type</span>


<span class="s2">def </span><span class="s1">get_wrapping_class(node):</span>
    <span class="s0">&quot;&quot;&quot;Get the class that wraps the given node. 
 
    We consider that a class wraps a node if the class 
    is a parent for the said node. 
 
    :returns: The class that wraps the given node 
    :rtype: ClassDef or None 
    &quot;&quot;&quot;</span>

    <span class="s1">klass = node.frame()</span>
    <span class="s2">while </span><span class="s1">klass </span><span class="s2">is not None and not </span><span class="s1">isinstance(klass, ClassDef):</span>
        <span class="s2">if </span><span class="s1">klass.parent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">klass = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">klass = klass.parent.frame()</span>
    <span class="s2">return </span><span class="s1">klass</span>


<span class="s2">class </span><span class="s1">ClassDef(mixins.FilterStmtsMixin, LocalsDictNodeNG, node_classes.Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ClassDef` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    class Thing: 
        def my_meth(self, arg): 
            return arg + self.offset 
    ''') 
    &gt;&gt;&gt; node 
    &lt;ClassDef.Thing l.2 at 0x7f23b2e9e748&gt; 
    &quot;&quot;&quot;</span>

    <span class="s0"># some of the attributes below are set by the builder module or</span>
    <span class="s0"># by a raw factories</span>

    <span class="s0"># a dictionary of class instances attributes</span>
    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;decorators&quot;</span><span class="s1">, </span><span class="s4">&quot;bases&quot;</span><span class="s1">, </span><span class="s4">&quot;keywords&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)  </span><span class="s0"># name</span>

    <span class="s1">decorators = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The decorators that are applied to this class. 
 
    :type: Decorators or None 
    &quot;&quot;&quot;</span>
    <span class="s1">special_attributes = objectmodel.ClassModel()</span>
    <span class="s4">&quot;&quot;&quot;The names of special attributes that this class has. 
 
    :type: objectmodel.ClassModel 
    &quot;&quot;&quot;</span>

    <span class="s1">_type = </span><span class="s2">None</span>
    <span class="s1">_metaclass_hack = </span><span class="s2">False</span>
    <span class="s1">hide = </span><span class="s2">False</span>
    <span class="s1">type = property(</span>
        <span class="s1">_class_type,</span>
        <span class="s1">doc=(</span>
            <span class="s4">&quot;The class type for this node.</span><span class="s5">\n\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Possible values are: class, metaclass, exception.</span><span class="s5">\n\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;:type: str&quot;</span>
        <span class="s1">),</span>
    <span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;name&quot;</span><span class="s1">, </span><span class="s4">&quot;doc&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;locals&quot;</span><span class="s1">, </span><span class="s4">&quot;_newstyle&quot;</span><span class="s1">)</span>
    <span class="s1">_newstyle = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self, name=</span><span class="s2">None</span><span class="s1">, doc=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name of the class. 
        :type name: str or None 
 
        :param doc: The function's docstring. 
        :type doc: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.instance_attrs = {}</span>
        <span class="s1">self.locals = {}</span>
        <span class="s4">&quot;&quot;&quot;A map of the name of a local variable to the node defining it. 
 
        :type: dict(str, NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.keywords = []</span>
        <span class="s4">&quot;&quot;&quot;The keywords given to the class definition. 
 
        This is usually for :pep:`3115` style metaclass declaration. 
 
        :type: list(Keyword) or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.bases = []</span>
        <span class="s4">&quot;&quot;&quot;What the class inherits from. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.body = []</span>
        <span class="s4">&quot;&quot;&quot;The contents of the class body. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.name = name</span>
        <span class="s4">&quot;&quot;&quot;The name of the class. 
 
        :type name: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.doc = doc</span>
        <span class="s4">&quot;&quot;&quot;The class' docstring. 
 
        :type doc: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>
        <span class="s2">if </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">parent.frame().set_local(name, self)</span>

        <span class="s2">for </span><span class="s1">local_name, node </span><span class="s2">in </span><span class="s1">self.implicit_locals():</span>
            <span class="s1">self.add_local_node(node, local_name)</span>

    <span class="s2">def </span><span class="s1">implicit_parameters(self):</span>
        <span class="s2">return </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">implicit_locals(self):</span>
        <span class="s0">&quot;&quot;&quot;Get implicitly defined class definition locals. 
 
        :returns: the the name and Const pair for each local 
        :rtype: tuple(tuple(str, node_classes.Const), ...) 
        &quot;&quot;&quot;</span>
        <span class="s1">locals_ = ((</span><span class="s4">&quot;__module__&quot;</span><span class="s1">, self.special_attributes.attr___module__),)</span>
        <span class="s0"># __qualname__ is defined in PEP3155</span>
        <span class="s1">locals_ += ((</span><span class="s4">&quot;__qualname__&quot;</span><span class="s1">, self.special_attributes.attr___qualname__),)</span>
        <span class="s2">return </span><span class="s1">locals_</span>

    <span class="s0"># pylint: disable=redefined-outer-name</span>
    <span class="s2">def </span><span class="s1">postinit(</span>
        <span class="s1">self, bases, body, decorators, newstyle=</span><span class="s2">None</span><span class="s1">, metaclass=</span><span class="s2">None</span><span class="s1">, keywords=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param bases: What the class inherits from. 
        :type bases: list(NodeNG) 
 
        :param body: The contents of the class body. 
        :type body: list(NodeNG) 
 
        :param decorators: The decorators that are applied to this class. 
        :type decorators: Decorators or None 
 
        :param newstyle: Whether this is a new style class or not. 
        :type newstyle: bool or None 
 
        :param metaclass: The metaclass of this class. 
        :type metaclass: NodeNG or None 
 
        :param keywords: The keywords given to the class definition. 
        :type keywords: list(Keyword) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.keywords = keywords</span>
        <span class="s1">self.bases = bases</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.decorators = decorators</span>
        <span class="s2">if </span><span class="s1">newstyle </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._newstyle = newstyle</span>
        <span class="s2">if </span><span class="s1">metaclass </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._metaclass = metaclass</span>

    <span class="s2">def </span><span class="s1">_newstyle_impl(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">context </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">context = contextmod.InferenceContext()</span>
        <span class="s2">if </span><span class="s1">self._newstyle </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._newstyle</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">self.ancestors(recurs=</span><span class="s2">False</span><span class="s1">, context=context):</span>
            <span class="s2">if </span><span class="s1">base._newstyle_impl(context):</span>
                <span class="s1">self._newstyle = </span><span class="s2">True</span>
                <span class="s2">break</span>
        <span class="s1">klass = self.declared_metaclass()</span>
        <span class="s0"># could be any callable, we'd need to infer the result of klass(name,</span>
        <span class="s0"># bases, dict).  punt if it's not a class node.</span>
        <span class="s2">if </span><span class="s1">klass </span><span class="s2">is not None and </span><span class="s1">isinstance(klass, ClassDef):</span>
            <span class="s1">self._newstyle = klass._newstyle_impl(context)</span>
        <span class="s2">if </span><span class="s1">self._newstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._newstyle = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self._newstyle</span>

    <span class="s1">_newstyle = </span><span class="s2">None</span>
    <span class="s1">newstyle = property(</span>
        <span class="s1">_newstyle_impl,</span>
        <span class="s1">doc=(</span><span class="s4">&quot;Whether this is a new style class or not</span><span class="s5">\n\n</span><span class="s4">&quot; &quot;:type: bool or None&quot;</span><span class="s1">),</span>
    <span class="s1">)</span>

    <span class="s1">@decorators_mod.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.bases:</span>
            <span class="s2">return </span><span class="s1">self.bases[-</span><span class="s3">1</span><span class="s1">].tolineno</span>

        <span class="s2">return </span><span class="s1">self.fromlineno</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: Unused. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fromlineno, self.tolineno</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.newstyle:</span>
            <span class="s2">return </span><span class="s4">&quot;%s.type&quot; </span><span class="s1">% BUILTINS</span>
        <span class="s2">return </span><span class="s4">&quot;%s.classobj&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">display_type(self):</span>
        <span class="s0">&quot;&quot;&quot;A human readable type of this node. 
 
        :returns: The type of this node. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;Class&quot;</span>

    <span class="s2">def </span><span class="s1">callable(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether this node defines something that is callable. 
 
        :returns: True if this defines something that is callable, 
            False otherwise. 
            For a :class:`ClassDef` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">is_subtype_of(self, type_name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Whether this class is a subtype of the given type. 
 
        :param type_name: The name of the type of check against. 
        :type type_name: str 
 
        :returns: True if this class is a subtype of the given type, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.qname() == type_name:</span>
            <span class="s2">return True</span>
        <span class="s2">for </span><span class="s1">anc </span><span class="s2">in </span><span class="s1">self.ancestors(context=context):</span>
            <span class="s2">if </span><span class="s1">anc.qname() == type_name:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_infer_type_call(self, caller, context):</span>
        <span class="s1">name_node = next(caller.args[</span><span class="s3">0</span><span class="s1">].infer(context))</span>
        <span class="s2">if </span><span class="s1">isinstance(name_node, node_classes.Const) </span><span class="s2">and </span><span class="s1">isinstance(</span>
            <span class="s1">name_node.value, str</span>
        <span class="s1">):</span>
            <span class="s1">name = name_node.value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">util.Uninferable</span>

        <span class="s1">result = ClassDef(name, </span><span class="s2">None</span><span class="s1">)</span>

        <span class="s0"># Get the bases of the class.</span>
        <span class="s1">class_bases = next(caller.args[</span><span class="s3">1</span><span class="s1">].infer(context))</span>
        <span class="s2">if </span><span class="s1">isinstance(class_bases, (node_classes.Tuple, node_classes.List)):</span>
            <span class="s1">bases = []</span>
            <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">class_bases.itered():</span>
                <span class="s1">inferred = next(base.infer(context=context))</span>
                <span class="s2">if </span><span class="s1">inferred:</span>
                    <span class="s1">bases.append(</span>
                        <span class="s1">node_classes.EvaluatedObject(original=base, value=inferred)</span>
                    <span class="s1">)</span>
            <span class="s1">result.bases = bases</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># There is currently no AST node that can represent an 'unknown'</span>
            <span class="s0"># node (Uninferable is not an AST node), therefore we simply return Uninferable here</span>
            <span class="s0"># although we know at least the name of the class.</span>
            <span class="s2">return </span><span class="s1">util.Uninferable</span>

        <span class="s0"># Get the members of the class</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">members = next(caller.args[</span><span class="s3">2</span><span class="s1">].infer(context))</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s1">members = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">members </span><span class="s2">and </span><span class="s1">isinstance(members, node_classes.Dict):</span>
            <span class="s2">for </span><span class="s1">attr, value </span><span class="s2">in </span><span class="s1">members.items:</span>
                <span class="s2">if </span><span class="s1">isinstance(attr, node_classes.Const) </span><span class="s2">and </span><span class="s1">isinstance(attr.value, str):</span>
                    <span class="s1">result.locals[attr.value] = [value]</span>

        <span class="s1">result.parent = caller.parent</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;infer what a class is returning when called&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.is_subtype_of(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">BUILTINS</span><span class="s5">}</span><span class="s4">.type&quot;</span><span class="s1">, context) </span><span class="s2">and </span><span class="s1">len(caller.args) == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">result = self._infer_type_call(caller, context)</span>
            <span class="s2">yield </span><span class="s1">result</span>
            <span class="s2">return</span>

        <span class="s1">dunder_call = </span><span class="s2">None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">metaclass = self.metaclass(context=context)</span>
            <span class="s2">if </span><span class="s1">metaclass </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">dunder_call = next(metaclass.igetattr(</span><span class="s4">&quot;__call__&quot;</span><span class="s1">, context))</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
            <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">dunder_call </span><span class="s2">and </span><span class="s1">dunder_call.qname() != </span><span class="s4">&quot;builtins.type.__call__&quot;</span><span class="s1">:</span>
            <span class="s0"># Call type.__call__ if not set metaclass</span>
            <span class="s0"># (since type is the default metaclass)</span>
            <span class="s1">context = contextmod.bind_context_to_node(context, self)</span>
            <span class="s2">yield from </span><span class="s1">dunder_call.infer_call_result(caller, context)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.instantiate_class()</span>

    <span class="s2">def </span><span class="s1">scope_lookup(self, node, name, offset=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Lookup where the given name is assigned. 
 
        :param node: The node to look for assignments up to. 
            Any assignments after the given node are ignored. 
        :type node: NodeNG 
 
        :param name: The name to find assignments for. 
        :type name: str 
 
        :param offset: The line offset to filter statements up to. 
        :type offset: int 
 
        :returns: This scope node and the list of assignments associated to the 
            given name according to the scope where it has been found (locals, 
            globals or builtin). 
        :rtype: tuple(str, list(NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s0"># If the name looks like a builtin name, just try to look</span>
        <span class="s0"># into the upper scope of this class. We might have a</span>
        <span class="s0"># decorator that it's poorly named after a builtin object</span>
        <span class="s0"># inside this class.</span>
        <span class="s1">lookup_upper_frame = (</span>
            <span class="s1">isinstance(node.parent, node_classes.Decorators)</span>
            <span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">MANAGER.builtins_module</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">any(node == base </span><span class="s2">or </span><span class="s1">base.parent_of(node) </span><span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">self.bases)</span>
            <span class="s2">or </span><span class="s1">lookup_upper_frame</span>
        <span class="s1">):</span>
            <span class="s0"># Handle the case where we have either a name</span>
            <span class="s0"># in the bases of a class, which exists before</span>
            <span class="s0"># the actual definition or the case where we have</span>
            <span class="s0"># a Getattr node, with that name.</span>
            <span class="s0">#</span>
            <span class="s0"># name = ...</span>
            <span class="s0"># class A(name):</span>
            <span class="s0">#     def name(self): ...</span>
            <span class="s0">#</span>
            <span class="s0"># import name</span>
            <span class="s0"># class A(name.Name):</span>
            <span class="s0">#     def name(self): ...</span>

            <span class="s1">frame = self.parent.frame()</span>
            <span class="s0"># line offset to avoid that class A(A) resolve the ancestor to</span>
            <span class="s0"># the defined class</span>
            <span class="s1">offset = -</span><span class="s3">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">frame = self</span>
        <span class="s2">return </span><span class="s1">frame._scope_lookup(node, name, offset)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">basenames(self):</span>
        <span class="s0">&quot;&quot;&quot;The names of the parent classes 
 
        Names are given in the order they appear in the class definition. 
 
        :type: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[bnode.as_string() </span><span class="s2">for </span><span class="s1">bnode </span><span class="s2">in </span><span class="s1">self.bases]</span>

    <span class="s2">def </span><span class="s1">ancestors(self, recurs=</span><span class="s2">True</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over the base classes in prefixed depth first order. 
 
        :param recurs: Whether to recurse or return direct ancestors only. 
        :type recurs: bool 
 
        :returns: The base classes 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s0"># FIXME: should be possible to choose the resolution order</span>
        <span class="s0"># FIXME: inference make infinite loops possible here</span>
        <span class="s1">yielded = {self}</span>
        <span class="s2">if </span><span class="s1">context </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">context = contextmod.InferenceContext()</span>
        <span class="s2">if not </span><span class="s1">self.bases </span><span class="s2">and </span><span class="s1">self.qname() != </span><span class="s4">&quot;builtins.object&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">builtin_lookup(</span><span class="s4">&quot;object&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">self.bases:</span>
            <span class="s2">with </span><span class="s1">context.restore_path():</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">baseobj </span><span class="s2">in </span><span class="s1">stmt.infer(context):</span>
                        <span class="s2">if not </span><span class="s1">isinstance(baseobj, ClassDef):</span>
                            <span class="s2">if </span><span class="s1">isinstance(baseobj, bases.Instance):</span>
                                <span class="s1">baseobj = baseobj._proxied</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s2">continue</span>
                        <span class="s2">if not </span><span class="s1">baseobj.hide:</span>
                            <span class="s2">if </span><span class="s1">baseobj </span><span class="s2">in </span><span class="s1">yielded:</span>
                                <span class="s2">continue</span>
                            <span class="s1">yielded.add(baseobj)</span>
                            <span class="s2">yield </span><span class="s1">baseobj</span>
                        <span class="s2">if not </span><span class="s1">recurs:</span>
                            <span class="s2">continue</span>
                        <span class="s2">for </span><span class="s1">grandpa </span><span class="s2">in </span><span class="s1">baseobj.ancestors(recurs=</span><span class="s2">True</span><span class="s1">, context=context):</span>
                            <span class="s2">if </span><span class="s1">grandpa </span><span class="s2">is </span><span class="s1">self:</span>
                                <span class="s0"># This class is the ancestor of itself.</span>
                                <span class="s2">break</span>
                            <span class="s2">if </span><span class="s1">grandpa </span><span class="s2">in </span><span class="s1">yielded:</span>
                                <span class="s2">continue</span>
                            <span class="s1">yielded.add(grandpa)</span>
                            <span class="s2">yield </span><span class="s1">grandpa</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">continue</span>

    <span class="s2">def </span><span class="s1">local_attr_ancestors(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over the parents that define the given name. 
 
        :param name: The name to find definitions for. 
        :type name: str 
 
        :returns: The parents that define the given name. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s0"># Look up in the mro if we can. This will result in the</span>
        <span class="s0"># attribute being looked up just as Python does it.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ancestors = self.mro(context)[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s2">except </span><span class="s1">exceptions.MroError:</span>
            <span class="s0"># Fallback to use ancestors, we can't determine</span>
            <span class="s0"># a sane MRO.</span>
            <span class="s1">ancestors = self.ancestors(context=context)</span>
        <span class="s2">for </span><span class="s1">astroid </span><span class="s2">in </span><span class="s1">ancestors:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">astroid:</span>
                <span class="s2">yield </span><span class="s1">astroid</span>

    <span class="s2">def </span><span class="s1">instance_attr_ancestors(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over the parents that define the given name as an attribute. 
 
        :param name: The name to find definitions for. 
        :type name: str 
 
        :returns: The parents that define the given name as 
            an instance attribute. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">astroid </span><span class="s2">in </span><span class="s1">self.ancestors(context=context):</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">astroid.instance_attrs:</span>
                <span class="s2">yield </span><span class="s1">astroid</span>

    <span class="s2">def </span><span class="s1">has_base(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Whether this class directly inherits from the given node. 
 
        :param node: The node to check for. 
        :type node: NodeNG 
 
        :returns: True if this class directly inherits from the given node. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.bases</span>

    <span class="s2">def </span><span class="s1">local_attr(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the list of assign nodes associated to the given name. 
 
        Assignments are looked for in both this class and in parents. 
 
        :returns: The list of assignments to the given name. 
        :rtype: list(NodeNG) 
 
        :raises AttributeInferenceError: If no attribute with this name 
            can be found in this class or parent classes. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.locals:</span>
            <span class="s1">result = self.locals[name]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">class_node = next(self.local_attr_ancestors(name, context), </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">class_node:</span>
                <span class="s1">result = class_node.locals[name]</span>
        <span class="s1">result = [n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">result </span><span class="s2">if not </span><span class="s1">isinstance(n, node_classes.DelAttr)]</span>
        <span class="s2">if </span><span class="s1">result:</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
            <span class="s1">target=self, attribute=name, context=context</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">instance_attr(self, name, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the list of nodes associated to the given attribute name. 
 
        Assignments are looked for in both this class and in parents. 
 
        :returns: The list of assignments to the given name. 
        :rtype: list(NodeNG) 
 
        :raises AttributeInferenceError: If no attribute with this name 
            can be found in this class or parent classes. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Return a copy, so we don't modify self.instance_attrs,</span>
        <span class="s0"># which could lead to infinite loop.</span>
        <span class="s1">values = list(self.instance_attrs.get(name, []))</span>
        <span class="s0"># get all values from parents</span>
        <span class="s2">for </span><span class="s1">class_node </span><span class="s2">in </span><span class="s1">self.instance_attr_ancestors(name, context):</span>
            <span class="s1">values += class_node.instance_attrs[name]</span>
        <span class="s1">values = [n </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">values </span><span class="s2">if not </span><span class="s1">isinstance(n, node_classes.DelAttr)]</span>
        <span class="s2">if </span><span class="s1">values:</span>
            <span class="s2">return </span><span class="s1">values</span>
        <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
            <span class="s1">target=self, attribute=name, context=context</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">instantiate_class(self):</span>
        <span class="s0">&quot;&quot;&quot;Get an :class:`Instance` of the :class:`ClassDef` node. 
 
        :returns: An :class:`Instance` of the :class:`ClassDef` node, 
            or self if this is not possible. 
        :rtype: Instance or ClassDef 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">any(cls.name </span><span class="s2">in </span><span class="s1">EXCEPTION_BASE_CLASSES </span><span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">self.mro()):</span>
                <span class="s0"># Subclasses of exceptions can be exception instances</span>
                <span class="s2">return </span><span class="s1">objects.ExceptionInstance(self)</span>
        <span class="s2">except </span><span class="s1">exceptions.MroError:</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">bases.Instance(self)</span>

    <span class="s2">def </span><span class="s1">getattr(self, name, context=</span><span class="s2">None</span><span class="s1">, class_context=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get an attribute from this class, using Python's attribute semantic. 
 
        This method doesn't look in the :attr:`instance_attrs` dictionary 
        since it is done by an :class:`Instance` proxy at inference time. 
        It may return an :class:`Uninferable` object if 
        the attribute has not been 
        found, but a ``__getattr__`` or ``__getattribute__`` method is defined. 
        If ``class_context`` is given, then it is considered that the 
        attribute is accessed from a class context, 
        e.g. ClassDef.attribute, otherwise it might have been accessed 
        from an instance as well. If ``class_context`` is used in that 
        case, then a lookup in the implicit metaclass and the explicit 
        metaclass will be done. 
 
        :param name: The attribute to look for. 
        :type name: str 
 
        :param class_context: Whether the attribute can be accessed statically. 
        :type class_context: bool 
 
        :returns: The attribute. 
        :rtype: list(NodeNG) 
 
        :raises AttributeInferenceError: If the attribute cannot be inferred. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">name:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self, attribute=name, context=context</span>
            <span class="s1">)</span>

        <span class="s1">values = self.locals.get(name, [])</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.special_attributes </span><span class="s2">and </span><span class="s1">class_context </span><span class="s2">and not </span><span class="s1">values:</span>
            <span class="s1">result = [self.special_attributes.lookup(name)]</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;__bases__&quot;</span><span class="s1">:</span>
                <span class="s0"># Need special treatment, since they are mutable</span>
                <span class="s0"># and we need to return all the values.</span>
                <span class="s1">result += values</span>
            <span class="s2">return </span><span class="s1">result</span>

        <span class="s0"># don't modify the list in self.locals!</span>
        <span class="s1">values = list(values)</span>
        <span class="s2">for </span><span class="s1">classnode </span><span class="s2">in </span><span class="s1">self.ancestors(recurs=</span><span class="s2">True</span><span class="s1">, context=context):</span>
            <span class="s1">values += classnode.locals.get(name, [])</span>

        <span class="s2">if </span><span class="s1">class_context:</span>
            <span class="s1">values += self._metaclass_lookup_attribute(name, context)</span>

        <span class="s2">if not </span><span class="s1">values:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self, attribute=name, context=context</span>
            <span class="s1">)</span>

        <span class="s0"># Look for AnnAssigns, which are not attributes in the purest sense.</span>
        <span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">values:</span>
            <span class="s2">if </span><span class="s1">isinstance(value, node_classes.AssignName):</span>
                <span class="s1">stmt = value.statement()</span>
                <span class="s2">if </span><span class="s1">isinstance(stmt, node_classes.AnnAssign) </span><span class="s2">and </span><span class="s1">stmt.value </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                        <span class="s1">target=self, attribute=name, context=context</span>
                    <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">def </span><span class="s1">_metaclass_lookup_attribute(self, name, context):</span>
        <span class="s0">&quot;&quot;&quot;Search the given name in the implicit and the explicit metaclass.&quot;&quot;&quot;</span>
        <span class="s1">attrs = set()</span>
        <span class="s1">implicit_meta = self.implicit_metaclass()</span>
        <span class="s1">context = contextmod.copy_context(context)</span>
        <span class="s1">metaclass = self.metaclass(context=context)</span>
        <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">{implicit_meta, metaclass}:</span>
            <span class="s2">if </span><span class="s1">cls </span><span class="s2">and </span><span class="s1">cls != self </span><span class="s2">and </span><span class="s1">isinstance(cls, ClassDef):</span>
                <span class="s1">cls_attributes = self._get_attribute_from_metaclass(cls, name, context)</span>
                <span class="s1">attrs.update(set(cls_attributes))</span>
        <span class="s2">return </span><span class="s1">attrs</span>

    <span class="s2">def </span><span class="s1">_get_attribute_from_metaclass(self, cls, name, context):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">attrs = cls.getattr(name, context=context, class_context=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">bases._infer_stmts(attrs, context, frame=cls):</span>
            <span class="s2">if not </span><span class="s1">isinstance(attr, FunctionDef):</span>
                <span class="s2">yield </span><span class="s1">attr</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">isinstance(attr, objects.Property):</span>
                <span class="s2">yield </span><span class="s1">attr</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">attr.type == </span><span class="s4">&quot;classmethod&quot;</span><span class="s1">:</span>
                <span class="s0"># If the method is a classmethod, then it will</span>
                <span class="s0"># be bound to the metaclass, not to the class</span>
                <span class="s0"># from where the attribute is retrieved.</span>
                <span class="s0"># get_wrapping_class could return None, so just</span>
                <span class="s0"># default to the current class.</span>
                <span class="s1">frame = get_wrapping_class(attr) </span><span class="s2">or </span><span class="s1">self</span>
                <span class="s2">yield </span><span class="s1">bases.BoundMethod(attr, frame)</span>
            <span class="s2">elif </span><span class="s1">attr.type == </span><span class="s4">&quot;staticmethod&quot;</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">attr</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">bases.BoundMethod(attr, self)</span>

    <span class="s2">def </span><span class="s1">igetattr(self, name, context=</span><span class="s2">None</span><span class="s1">, class_context=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Infer the possible values of the given variable. 
 
        :param name: The name of the variable to infer. 
        :type name: str 
 
        :returns: The inferred possible values. 
        :rtype: iterable(NodeNG or Uninferable) 
        &quot;&quot;&quot;</span>
        <span class="s0"># set lookup name since this is necessary to infer on import nodes for</span>
        <span class="s0"># instance</span>
        <span class="s1">context = contextmod.copy_context(context)</span>
        <span class="s1">context.lookupname = name</span>

        <span class="s1">metaclass = self.declared_metaclass(context=context)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">attributes = self.getattr(name, context, class_context=class_context)</span>
            <span class="s0"># If we have more than one attribute, make sure that those starting from</span>
            <span class="s0"># the second one are from the same scope. This is to account for modifications</span>
            <span class="s0"># to the attribute happening *after* the attribute's definition (e.g. AugAssigns on lists)</span>
            <span class="s2">if </span><span class="s1">len(attributes) &gt; </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">first_attr, attributes = attributes[</span><span class="s3">0</span><span class="s1">], attributes[</span><span class="s3">1</span><span class="s1">:]</span>
                <span class="s1">first_scope = first_attr.scope()</span>
                <span class="s1">attributes = [first_attr] + [</span>
                    <span class="s1">attr</span>
                    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attributes</span>
                    <span class="s2">if </span><span class="s1">attr.parent </span><span class="s2">and </span><span class="s1">attr.parent.scope() == first_scope</span>
                <span class="s1">]</span>

            <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">bases._infer_stmts(attributes, context, frame=self):</span>
                <span class="s0"># yield Uninferable object instead of descriptors when necessary</span>
                <span class="s2">if not </span><span class="s1">isinstance(inferred, node_classes.Const) </span><span class="s2">and </span><span class="s1">isinstance(</span>
                    <span class="s1">inferred, bases.Instance</span>
                <span class="s1">):</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">inferred._proxied.getattr(</span><span class="s4">&quot;__get__&quot;</span><span class="s1">, context)</span>
                    <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
                        <span class="s2">yield </span><span class="s1">inferred</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">yield </span><span class="s1">util.Uninferable</span>
                <span class="s2">elif </span><span class="s1">isinstance(inferred, objects.Property):</span>
                    <span class="s1">function = inferred.function</span>
                    <span class="s2">if not </span><span class="s1">class_context:</span>
                        <span class="s0"># Through an instance so we can solve the property</span>
                        <span class="s2">yield from </span><span class="s1">function.infer_call_result(</span>
                            <span class="s1">caller=self, context=context</span>
                        <span class="s1">)</span>
                    <span class="s0"># If we have a metaclass, we're accessing this attribute through</span>
                    <span class="s0"># the class itself, which means we can solve the property</span>
                    <span class="s2">elif </span><span class="s1">metaclass:</span>
                        <span class="s0"># Resolve a property as long as it is not accessed through</span>
                        <span class="s0"># the class itself.</span>
                        <span class="s2">yield from </span><span class="s1">function.infer_call_result(</span>
                            <span class="s1">caller=self, context=context</span>
                        <span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">yield </span><span class="s1">inferred</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield </span><span class="s1">function_to_method(inferred, self)</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError </span><span class="s2">as </span><span class="s1">error:</span>
            <span class="s2">if not </span><span class="s1">name.startswith(</span><span class="s4">&quot;__&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.has_dynamic_getattr(context):</span>
                <span class="s0"># class handle some dynamic attributes, return a Uninferable object</span>
                <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                    <span class="s1">error.message, target=self, attribute=name, context=context</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">error</span>

    <span class="s2">def </span><span class="s1">has_dynamic_getattr(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Check if the class has a custom __getattr__ or __getattribute__. 
 
        If any such method is found and it is not from 
        builtins, nor from an extension module, then the function 
        will return True. 
 
        :returns: True if the class has a custom 
            __getattr__ or __getattribute__, False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">_valid_getattr(node):</span>
            <span class="s1">root = node.root()</span>
            <span class="s2">return </span><span class="s1">root.name != BUILTINS </span><span class="s2">and </span><span class="s1">getattr(root, </span><span class="s4">&quot;pure_python&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_valid_getattr(self.getattr(</span><span class="s4">&quot;__getattr__&quot;</span><span class="s1">, context)[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
            <span class="s0"># if self.newstyle: XXX cause an infinite recursion error</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">getattribute = self.getattr(</span><span class="s4">&quot;__getattribute__&quot;</span><span class="s1">, context)[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s2">return </span><span class="s1">_valid_getattr(getattribute)</span>
            <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
                <span class="s2">pass</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">getitem(self, index, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return the inference of a subscript. 
 
        This is basically looking up the method in the metaclass and calling it. 
 
        :returns: The inferred value of a subscript to this class. 
        :rtype: NodeNG 
 
        :raises AstroidTypeError: If this class does not define a 
            ``__getitem__`` method. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">methods = dunder_lookup.lookup(self, </span><span class="s4">&quot;__getitem__&quot;</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">isinstance(self, ClassDef):</span>
                <span class="s0"># subscripting a class definition may be</span>
                <span class="s0"># achieved thanks to __class_getitem__ method</span>
                <span class="s0"># which is a classmethod defined in the class</span>
                <span class="s0"># that supports subscript and not in the metaclass</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">methods = self.getattr(</span><span class="s4">&quot;__class_getitem__&quot;</span><span class="s1">)</span>
                    <span class="s0"># Here it is assumed that the __class_getitem__ node is</span>
                    <span class="s0"># a FunctionDef. One possible improvement would be to deal</span>
                    <span class="s0"># with more generic inference.</span>
                <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span>
                        <span class="s1">node=self, context=context</span>
                    <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(node=self, context=context) </span><span class="s2">from </span><span class="s1">exc</span>

        <span class="s1">method = methods[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s0"># Create a new callcontext for providing index as an argument.</span>
        <span class="s1">new_context = contextmod.bind_context_to_node(context, self)</span>
        <span class="s1">new_context.callcontext = contextmod.CallContext(args=[index])</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">next(method.infer_call_result(self, new_context))</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s0"># Starting with python3.9, builtin types list, dict etc...</span>
            <span class="s0"># are subscriptable thanks to __class_getitem___ classmethod.</span>
            <span class="s0"># However in such case the method is bound to an EmptyNode and</span>
            <span class="s0"># EmptyNode doesn't have infer_call_result method yielding to</span>
            <span class="s0"># AttributeError</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(method, node_classes.EmptyNode)</span>
                <span class="s2">and </span><span class="s1">self.name </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;list&quot;</span><span class="s1">, </span><span class="s4">&quot;dict&quot;</span><span class="s1">, </span><span class="s4">&quot;set&quot;</span><span class="s1">, </span><span class="s4">&quot;tuple&quot;</span><span class="s1">, </span><span class="s4">&quot;frozenset&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">PY39</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">self</span>
            <span class="s2">raise</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">methods(self):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over all of the method defined in this class and its parents. 
 
        :returns: The methods defined on the class. 
        :rtype: iterable(FunctionDef) 
        &quot;&quot;&quot;</span>
        <span class="s1">done = {}</span>
        <span class="s2">for </span><span class="s1">astroid </span><span class="s2">in </span><span class="s1">itertools.chain(iter((self,)), self.ancestors()):</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">astroid.mymethods():</span>
                <span class="s2">if </span><span class="s1">meth.name </span><span class="s2">in </span><span class="s1">done:</span>
                    <span class="s2">continue</span>
                <span class="s1">done[meth.name] = </span><span class="s2">None</span>
                <span class="s2">yield </span><span class="s1">meth</span>

    <span class="s2">def </span><span class="s1">mymethods(self):</span>
        <span class="s0">&quot;&quot;&quot;Iterate over all of the method defined in this class only. 
 
        :returns: The methods defined on the class. 
        :rtype: iterable(FunctionDef) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">member </span><span class="s2">in </span><span class="s1">self.values():</span>
            <span class="s2">if </span><span class="s1">isinstance(member, FunctionDef):</span>
                <span class="s2">yield </span><span class="s1">member</span>

    <span class="s2">def </span><span class="s1">implicit_metaclass(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the implicit metaclass of the current class. 
 
        For newstyle classes, this will return an instance of builtins.type. 
        For oldstyle classes, it will simply return None, since there's 
        no implicit metaclass there. 
 
        :returns: The metaclass. 
        :rtype: builtins.type or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.newstyle:</span>
            <span class="s2">return </span><span class="s1">builtin_lookup(</span><span class="s4">&quot;type&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">return None</span>

    <span class="s1">_metaclass = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">declared_metaclass(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return the explicit declared metaclass for the current class. 
 
        An explicit declared metaclass is defined 
        either by passing the ``metaclass`` keyword argument 
        in the class definition line (Python 3) or (Python 2) by 
        having a ``__metaclass__`` class attribute, or if there are 
        no explicit bases but there is a global ``__metaclass__`` variable. 
 
        :returns: The metaclass of this class, 
            or None if one could not be found. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">self.bases:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">baseobj </span><span class="s2">in </span><span class="s1">base.infer(context=context):</span>
                    <span class="s2">if </span><span class="s1">isinstance(baseobj, ClassDef) </span><span class="s2">and </span><span class="s1">baseobj.hide:</span>
                        <span class="s1">self._metaclass = baseobj._metaclass</span>
                        <span class="s1">self._metaclass_hack = </span><span class="s2">True</span>
                        <span class="s2">break</span>
            <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                <span class="s2">pass</span>

        <span class="s2">if </span><span class="s1">self._metaclass:</span>
            <span class="s0"># Expects this from Py3k TreeRebuilder</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">next(</span>
                    <span class="s1">node</span>
                    <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self._metaclass.infer(context=context)</span>
                    <span class="s2">if </span><span class="s1">node </span><span class="s2">is not </span><span class="s1">util.Uninferable</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">(exceptions.InferenceError, StopIteration):</span>
                <span class="s2">return None</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_find_metaclass(self, seen=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">seen </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">seen = set()</span>
        <span class="s1">seen.add(self)</span>

        <span class="s1">klass = self.declared_metaclass(context=context)</span>
        <span class="s2">if </span><span class="s1">klass </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">parent </span><span class="s2">in </span><span class="s1">self.ancestors(context=context):</span>
                <span class="s2">if </span><span class="s1">parent </span><span class="s2">not in </span><span class="s1">seen:</span>
                    <span class="s1">klass = parent._find_metaclass(seen)</span>
                    <span class="s2">if </span><span class="s1">klass </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">klass</span>

    <span class="s2">def </span><span class="s1">metaclass(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the metaclass of this class. 
 
        If this class does not define explicitly a metaclass, 
        then the first defined metaclass in ancestors will be used 
        instead. 
 
        :returns: The metaclass of this class. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._find_metaclass(context=context)</span>

    <span class="s2">def </span><span class="s1">has_metaclass_hack(self):</span>
        <span class="s2">return </span><span class="s1">self._metaclass_hack</span>

    <span class="s2">def </span><span class="s1">_islots(self):</span>
        <span class="s0">&quot;&quot;&quot; Return an iterator with the inferred slots. &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;__slots__&quot; </span><span class="s2">not in </span><span class="s1">self.locals:</span>
            <span class="s2">return None</span>
        <span class="s2">for </span><span class="s1">slots </span><span class="s2">in </span><span class="s1">self.igetattr(</span><span class="s4">&quot;__slots__&quot;</span><span class="s1">):</span>
            <span class="s0"># check if __slots__ is a valid type</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">ITER_METHODS:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">slots.getattr(meth)</span>
                    <span class="s2">break</span>
                <span class="s2">except </span><span class="s1">exceptions.AttributeInferenceError:</span>
                    <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">isinstance(slots, node_classes.Const):</span>
                <span class="s0"># a string. Ignore the following checks,</span>
                <span class="s0"># but yield the node, only if it has a value</span>
                <span class="s2">if </span><span class="s1">slots.value:</span>
                    <span class="s2">yield </span><span class="s1">slots</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">hasattr(slots, </span><span class="s4">&quot;itered&quot;</span><span class="s1">):</span>
                <span class="s0"># we can't obtain the values, maybe a .deque?</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">isinstance(slots, node_classes.Dict):</span>
                <span class="s1">values = [item[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">slots.items]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">values = slots.itered()</span>
            <span class="s2">if </span><span class="s1">values </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">values:</span>
                <span class="s0"># Stop the iteration, because the class</span>
                <span class="s0"># has an empty list of slots.</span>
                <span class="s2">return </span><span class="s1">values</span>

            <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">values:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">elt.infer():</span>
                        <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                            <span class="s2">continue</span>
                        <span class="s2">if not </span><span class="s1">isinstance(</span>
                            <span class="s1">inferred, node_classes.Const</span>
                        <span class="s1">) </span><span class="s2">or not </span><span class="s1">isinstance(inferred.value, str):</span>
                            <span class="s2">continue</span>
                        <span class="s2">if not </span><span class="s1">inferred.value:</span>
                            <span class="s2">continue</span>
                        <span class="s2">yield </span><span class="s1">inferred</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">continue</span>

        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_slots(self):</span>
        <span class="s2">if not </span><span class="s1">self.newstyle:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">&quot;The concept of slots is undefined for old-style classes.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">slots = self._islots()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">first = next(slots)</span>
        <span class="s2">except </span><span class="s1">StopIteration </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s0"># The class doesn't have a __slots__ definition or empty slots.</span>
            <span class="s2">if </span><span class="s1">exc.args </span><span class="s2">and </span><span class="s1">exc.args[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">&quot;&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s1">exc.args[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">[first] + list(slots)</span>

    <span class="s0"># Cached, because inferring them all the time is expensive</span>
    <span class="s1">@decorators_mod.cached</span>
    <span class="s2">def </span><span class="s1">slots(self):</span>
        <span class="s0">&quot;&quot;&quot;Get all the slots for this node. 
 
        :returns: The names of slots for this class. 
            If the class doesn't define any slot, through the ``__slots__`` 
            variable, then this function will return a None. 
            Also, it will return None in the case the slots were not inferred. 
        :rtype: list(str) or None 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">grouped_slots():</span>
            <span class="s0"># Not interested in object, since it can't have slots.</span>
            <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">self.mro()[:-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">cls_slots = cls._slots()</span>
                <span class="s2">except </span><span class="s1">NotImplementedError:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">cls_slots </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">yield from </span><span class="s1">cls_slots</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield None</span>

        <span class="s2">if not </span><span class="s1">self.newstyle:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">&quot;The concept of slots is undefined for old-style classes.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">slots = list(grouped_slots())</span>
        <span class="s2">if not </span><span class="s1">all(slot </span><span class="s2">is not None for </span><span class="s1">slot </span><span class="s2">in </span><span class="s1">slots):</span>
            <span class="s2">return None</span>

        <span class="s2">return </span><span class="s1">sorted(set(slots), key=</span><span class="s2">lambda </span><span class="s1">item: item.value)</span>

    <span class="s2">def </span><span class="s1">_inferred_bases(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># Similar with .ancestors, but the difference is when one base is inferred,</span>
        <span class="s0"># only the first object is wanted. That's because</span>
        <span class="s0"># we aren't interested in superclasses, as in the following</span>
        <span class="s0"># example:</span>
        <span class="s0">#</span>
        <span class="s0"># class SomeSuperClass(object): pass</span>
        <span class="s0"># class SomeClass(SomeSuperClass): pass</span>
        <span class="s0"># class Test(SomeClass): pass</span>
        <span class="s0">#</span>
        <span class="s0"># Inferring SomeClass from the Test's bases will give</span>
        <span class="s0"># us both SomeClass and SomeSuperClass, but we are interested</span>
        <span class="s0"># only in SomeClass.</span>

        <span class="s2">if </span><span class="s1">context </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">context = contextmod.InferenceContext()</span>
        <span class="s2">if not </span><span class="s1">self.bases </span><span class="s2">and </span><span class="s1">self.qname() != </span><span class="s4">&quot;builtins.object&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">builtin_lookup(</span><span class="s4">&quot;object&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">self.bases:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">baseobj = next(stmt.infer(context=context.clone()))</span>
            <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance(baseobj, bases.Instance):</span>
                <span class="s1">baseobj = baseobj._proxied</span>
            <span class="s2">if not </span><span class="s1">isinstance(baseobj, ClassDef):</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">baseobj.hide:</span>
                <span class="s2">yield </span><span class="s1">baseobj</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield from </span><span class="s1">baseobj.bases</span>

    <span class="s2">def </span><span class="s1">_compute_mro(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">inferred_bases = list(self._inferred_bases(context=context))</span>
        <span class="s1">bases_mro = []</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">inferred_bases:</span>
            <span class="s2">if </span><span class="s1">base </span><span class="s2">is </span><span class="s1">self:</span>
                <span class="s2">continue</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mro = base._compute_mro(context=context)</span>
                <span class="s1">bases_mro.append(mro)</span>
            <span class="s2">except </span><span class="s1">NotImplementedError:</span>
                <span class="s0"># Some classes have in their ancestors both newstyle and</span>
                <span class="s0"># old style classes. For these we can't retrieve the .mro,</span>
                <span class="s0"># although in Python it's possible, since the class we are</span>
                <span class="s0"># currently working is in fact new style.</span>
                <span class="s0"># So, we fallback to ancestors here.</span>
                <span class="s1">ancestors = list(base.ancestors(context=context))</span>
                <span class="s1">bases_mro.append(ancestors)</span>

        <span class="s1">unmerged_mro = [[self]] + bases_mro + [inferred_bases]</span>
        <span class="s1">unmerged_mro = list(clean_duplicates_mro(unmerged_mro, self, context))</span>
        <span class="s1">clean_typing_generic_mro(unmerged_mro)</span>
        <span class="s2">return </span><span class="s1">_c3_merge(unmerged_mro, self, context)</span>

    <span class="s2">def </span><span class="s1">mro(self, context=</span><span class="s2">None</span><span class="s1">) -&gt; List[</span><span class="s4">&quot;ClassDef&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Get the method resolution order, using C3 linearization. 
 
        :returns: The list of ancestors, sorted by the mro. 
        :rtype: list(NodeNG) 
        :raises DuplicateBasesError: Duplicate bases in the same class base 
        :raises InconsistentMroError: A class' MRO is inconsistent 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._compute_mro(context=context)</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For a :class:`ClassDef` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.decorators </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.decorators</span>

        <span class="s2">yield from </span><span class="s1">self.bases</span>
        <span class="s2">if </span><span class="s1">self.keywords </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield from </span><span class="s1">self.keywords</span>
        <span class="s2">yield from </span><span class="s1">self.body</span>

    <span class="s1">@decorators_mod.cached</span>
    <span class="s2">def </span><span class="s1">_get_assign_nodes(self):</span>
        <span class="s1">children_assign_nodes = (</span>
            <span class="s1">child_node._get_assign_nodes() </span><span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.body</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">list(itertools.chain.from_iterable(children_assign_nodes))</span>
</pre>
</body>
</html>