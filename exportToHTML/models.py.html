<html>
<head>
<title>models.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #d19a66;}
.s4 { color: #98c379;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
models.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>

<span class="s0">&quot;&quot;&quot; 
requests.models 
~~~~~~~~~~~~~~~ 
 
This module contains the primary objects that power Requests. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">sys</span>

<span class="s0"># Import encoding now, to avoid implicit import later.</span>
<span class="s0"># Implicit import within threads may cause LookupError when standard library is in a ZIP,</span>
<span class="s0"># such as in Embedded Python. See https://github.com/psf/requests/issues/3578.</span>
<span class="s2">import </span><span class="s1">encodings.idna</span>

<span class="s2">from </span><span class="s1">urllib3.fields </span><span class="s2">import </span><span class="s1">RequestField</span>
<span class="s2">from </span><span class="s1">urllib3.filepost </span><span class="s2">import </span><span class="s1">encode_multipart_formdata</span>
<span class="s2">from </span><span class="s1">urllib3.util </span><span class="s2">import </span><span class="s1">parse_url</span>
<span class="s2">from </span><span class="s1">urllib3.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DecodeError, ReadTimeoutError, ProtocolError, LocationParseError)</span>

<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">UnsupportedOperation</span>
<span class="s2">from </span><span class="s1">.hooks </span><span class="s2">import </span><span class="s1">default_hooks</span>
<span class="s2">from </span><span class="s1">.structures </span><span class="s2">import </span><span class="s1">CaseInsensitiveDict</span>

<span class="s2">from </span><span class="s1">.auth </span><span class="s2">import </span><span class="s1">HTTPBasicAuth</span>
<span class="s2">from </span><span class="s1">.cookies </span><span class="s2">import </span><span class="s1">cookiejar_from_dict, get_cookie_header, _copy_cookie_jar</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">HTTPError, MissingSchema, InvalidURL, ChunkedEncodingError,</span>
    <span class="s1">ContentDecodingError, ConnectionError, StreamConsumedError)</span>
<span class="s2">from </span><span class="s1">._internal_utils </span><span class="s2">import </span><span class="s1">to_native_string, unicode_is_ascii</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">guess_filename, get_auth_from_url, requote_uri,</span>
    <span class="s1">stream_decode_response_unicode, to_key_val_list, parse_header_links,</span>
    <span class="s1">iter_slices, guess_json_utf, super_len, check_header_validity)</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Callable, Mapping,</span>
    <span class="s1">cookielib, urlunparse, urlsplit, urlencode, str, bytes,</span>
    <span class="s1">is_py2, chardet, builtin_str, basestring)</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">json </span><span class="s2">as </span><span class="s1">complexjson</span>
<span class="s2">from </span><span class="s1">.status_codes </span><span class="s2">import </span><span class="s1">codes</span>

<span class="s0">#: The set of HTTP status codes that indicate an automatically</span>
<span class="s0">#: processable redirect.</span>
<span class="s1">REDIRECT_STATI = (</span>
    <span class="s1">codes.moved,               </span><span class="s0"># 301</span>
    <span class="s1">codes.found,               </span><span class="s0"># 302</span>
    <span class="s1">codes.other,               </span><span class="s0"># 303</span>
    <span class="s1">codes.temporary_redirect,  </span><span class="s0"># 307</span>
    <span class="s1">codes.permanent_redirect,  </span><span class="s0"># 308</span>
<span class="s1">)</span>

<span class="s1">DEFAULT_REDIRECT_LIMIT = </span><span class="s3">30</span>
<span class="s1">CONTENT_CHUNK_SIZE = </span><span class="s3">10 </span><span class="s1">* </span><span class="s3">1024</span>
<span class="s1">ITER_CHUNK_SIZE = </span><span class="s3">512</span>


<span class="s2">class </span><span class="s1">RequestEncodingMixin(object):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">path_url(self):</span>
        <span class="s0">&quot;&quot;&quot;Build the path URL to use.&quot;&quot;&quot;</span>

        <span class="s1">url = []</span>

        <span class="s1">p = urlsplit(self.url)</span>

        <span class="s1">path = p.path</span>
        <span class="s2">if not </span><span class="s1">path:</span>
            <span class="s1">path = </span><span class="s4">'/'</span>

        <span class="s1">url.append(path)</span>

        <span class="s1">query = p.query</span>
        <span class="s2">if </span><span class="s1">query:</span>
            <span class="s1">url.append(</span><span class="s4">'?'</span><span class="s1">)</span>
            <span class="s1">url.append(query)</span>

        <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(url)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_encode_params(data):</span>
        <span class="s0">&quot;&quot;&quot;Encode parameters in a piece of data. 
 
        Will successfully encode parameters when passed as a dict or a list of 
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary 
        if parameters are supplied as a dict. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(data, (str, bytes)):</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">elif </span><span class="s1">hasattr(data, </span><span class="s4">'read'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">data</span>
        <span class="s2">elif </span><span class="s1">hasattr(data, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
            <span class="s1">result = []</span>
            <span class="s2">for </span><span class="s1">k, vs </span><span class="s2">in </span><span class="s1">to_key_val_list(data):</span>
                <span class="s2">if </span><span class="s1">isinstance(vs, basestring) </span><span class="s2">or not </span><span class="s1">hasattr(vs, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
                    <span class="s1">vs = [vs]</span>
                <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vs:</span>
                    <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">result.append(</span>
                            <span class="s1">(k.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">isinstance(k, str) </span><span class="s2">else </span><span class="s1">k,</span>
                             <span class="s1">v.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">isinstance(v, str) </span><span class="s2">else </span><span class="s1">v))</span>
            <span class="s2">return </span><span class="s1">urlencode(result, doseq=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_encode_files(files, data):</span>
        <span class="s0">&quot;&quot;&quot;Build the body for a multipart/form-data request. 
 
        Will successfully encode files when passed as a dict or a list of 
        tuples. Order is retained if data is a list of tuples but arbitrary 
        if parameters are supplied as a dict. 
        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype) 
        or 4-tuples (filename, fileobj, contentype, custom_headers). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">files):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Files must be provided.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(data, basestring):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Data must not be a string.&quot;</span><span class="s1">)</span>

        <span class="s1">new_fields = []</span>
        <span class="s1">fields = to_key_val_list(data </span><span class="s2">or </span><span class="s1">{})</span>
        <span class="s1">files = to_key_val_list(files </span><span class="s2">or </span><span class="s1">{})</span>

        <span class="s2">for </span><span class="s1">field, val </span><span class="s2">in </span><span class="s1">fields:</span>
            <span class="s2">if </span><span class="s1">isinstance(val, basestring) </span><span class="s2">or not </span><span class="s1">hasattr(val, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
                <span class="s1">val = [val]</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">val:</span>
                <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s0"># Don't call str() on bytestrings: in Py3 it all goes wrong.</span>
                    <span class="s2">if not </span><span class="s1">isinstance(v, bytes):</span>
                        <span class="s1">v = str(v)</span>

                    <span class="s1">new_fields.append(</span>
                        <span class="s1">(field.decode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">isinstance(field, bytes) </span><span class="s2">else </span><span class="s1">field,</span>
                         <span class="s1">v.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">isinstance(v, str) </span><span class="s2">else </span><span class="s1">v))</span>

        <span class="s2">for </span><span class="s1">(k, v) </span><span class="s2">in </span><span class="s1">files:</span>
            <span class="s0"># support for explicit filename</span>
            <span class="s1">ft = </span><span class="s2">None</span>
            <span class="s1">fh = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">isinstance(v, (tuple, list)):</span>
                <span class="s2">if </span><span class="s1">len(v) == </span><span class="s3">2</span><span class="s1">:</span>
                    <span class="s1">fn, fp = v</span>
                <span class="s2">elif </span><span class="s1">len(v) == </span><span class="s3">3</span><span class="s1">:</span>
                    <span class="s1">fn, fp, ft = v</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fn, fp, ft, fh = v</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fn = guess_filename(v) </span><span class="s2">or </span><span class="s1">k</span>
                <span class="s1">fp = v</span>

            <span class="s2">if </span><span class="s1">isinstance(fp, (str, bytes, bytearray)):</span>
                <span class="s1">fdata = fp</span>
            <span class="s2">elif </span><span class="s1">hasattr(fp, </span><span class="s4">'read'</span><span class="s1">):</span>
                <span class="s1">fdata = fp.read()</span>
            <span class="s2">elif </span><span class="s1">fp </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fdata = fp</span>

            <span class="s1">rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)</span>
            <span class="s1">rf.make_multipart(content_type=ft)</span>
            <span class="s1">new_fields.append(rf)</span>

        <span class="s1">body, content_type = encode_multipart_formdata(new_fields)</span>

        <span class="s2">return </span><span class="s1">body, content_type</span>


<span class="s2">class </span><span class="s1">RequestHooksMixin(object):</span>
    <span class="s2">def </span><span class="s1">register_hook(self, event, hook):</span>
        <span class="s0">&quot;&quot;&quot;Properly register a hook.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">event </span><span class="s2">not in </span><span class="s1">self.hooks:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Unsupported event specified, with event name &quot;%s&quot;' </span><span class="s1">% (event))</span>

        <span class="s2">if </span><span class="s1">isinstance(hook, Callable):</span>
            <span class="s1">self.hooks[event].append(hook)</span>
        <span class="s2">elif </span><span class="s1">hasattr(hook, </span><span class="s4">'__iter__'</span><span class="s1">):</span>
            <span class="s1">self.hooks[event].extend(h </span><span class="s2">for </span><span class="s1">h </span><span class="s2">in </span><span class="s1">hook </span><span class="s2">if </span><span class="s1">isinstance(h, Callable))</span>

    <span class="s2">def </span><span class="s1">deregister_hook(self, event, hook):</span>
        <span class="s0">&quot;&quot;&quot;Deregister a previously registered hook. 
        Returns True if the hook existed, False if not. 
        &quot;&quot;&quot;</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.hooks[event].remove(hook)</span>
            <span class="s2">return True</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">Request(RequestHooksMixin):</span>
    <span class="s0">&quot;&quot;&quot;A user-created :class:`Request &lt;Request&gt;` object. 
 
    Used to prepare a :class:`PreparedRequest &lt;PreparedRequest&gt;`, which is sent to the server. 
 
    :param method: HTTP method to use. 
    :param url: URL to send. 
    :param headers: dictionary of headers to send. 
    :param files: dictionary of {filename: fileobject} files to multipart upload. 
    :param data: the body to attach to the request. If a dictionary or 
        list of tuples ``[(key, value)]`` is provided, form-encoding will 
        take place. 
    :param json: json for the body to attach to the request (if files or data is not specified). 
    :param params: URL parameters to append to the URL. If a dictionary or 
        list of tuples ``[(key, value)]`` is provided, form-encoding will 
        take place. 
    :param auth: Auth handler or (user, pass) tuple. 
    :param cookies: dictionary or CookieJar of cookies to attach to this request. 
    :param hooks: dictionary of callback hooks, for internal usage. 
 
    Usage:: 
 
      &gt;&gt;&gt; import requests 
      &gt;&gt;&gt; req = requests.Request('GET', 'https://httpbin.org/get') 
      &gt;&gt;&gt; req.prepare() 
      &lt;PreparedRequest [GET]&gt; 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self,</span>
            <span class="s1">method=</span><span class="s2">None</span><span class="s1">, url=</span><span class="s2">None</span><span class="s1">, headers=</span><span class="s2">None</span><span class="s1">, files=</span><span class="s2">None</span><span class="s1">, data=</span><span class="s2">None</span><span class="s1">,</span>
            <span class="s1">params=</span><span class="s2">None</span><span class="s1">, auth=</span><span class="s2">None</span><span class="s1">, cookies=</span><span class="s2">None</span><span class="s1">, hooks=</span><span class="s2">None</span><span class="s1">, json=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s0"># Default empty dicts for dict params.</span>
        <span class="s1">data = [] </span><span class="s2">if </span><span class="s1">data </span><span class="s2">is None else </span><span class="s1">data</span>
        <span class="s1">files = [] </span><span class="s2">if </span><span class="s1">files </span><span class="s2">is None else </span><span class="s1">files</span>
        <span class="s1">headers = {} </span><span class="s2">if </span><span class="s1">headers </span><span class="s2">is None else </span><span class="s1">headers</span>
        <span class="s1">params = {} </span><span class="s2">if </span><span class="s1">params </span><span class="s2">is None else </span><span class="s1">params</span>
        <span class="s1">hooks = {} </span><span class="s2">if </span><span class="s1">hooks </span><span class="s2">is None else </span><span class="s1">hooks</span>

        <span class="s1">self.hooks = default_hooks()</span>
        <span class="s2">for </span><span class="s1">(k, v) </span><span class="s2">in </span><span class="s1">list(hooks.items()):</span>
            <span class="s1">self.register_hook(event=k, hook=v)</span>

        <span class="s1">self.method = method</span>
        <span class="s1">self.url = url</span>
        <span class="s1">self.headers = headers</span>
        <span class="s1">self.files = files</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.json = json</span>
        <span class="s1">self.params = params</span>
        <span class="s1">self.auth = auth</span>
        <span class="s1">self.cookies = cookies</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;Request [%s]&gt;' </span><span class="s1">% (self.method)</span>

    <span class="s2">def </span><span class="s1">prepare(self):</span>
        <span class="s0">&quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for transmission and returns it.&quot;&quot;&quot;</span>
        <span class="s1">p = PreparedRequest()</span>
        <span class="s1">p.prepare(</span>
            <span class="s1">method=self.method,</span>
            <span class="s1">url=self.url,</span>
            <span class="s1">headers=self.headers,</span>
            <span class="s1">files=self.files,</span>
            <span class="s1">data=self.data,</span>
            <span class="s1">json=self.json,</span>
            <span class="s1">params=self.params,</span>
            <span class="s1">auth=self.auth,</span>
            <span class="s1">cookies=self.cookies,</span>
            <span class="s1">hooks=self.hooks,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">p</span>


<span class="s2">class </span><span class="s1">PreparedRequest(RequestEncodingMixin, RequestHooksMixin):</span>
    <span class="s0">&quot;&quot;&quot;The fully mutable :class:`PreparedRequest &lt;PreparedRequest&gt;` object, 
    containing the exact bytes that will be sent to the server. 
 
    Instances are generated from a :class:`Request &lt;Request&gt;` object, and 
    should not be instantiated manually; doing so may produce undesirable 
    effects. 
 
    Usage:: 
 
      &gt;&gt;&gt; import requests 
      &gt;&gt;&gt; req = requests.Request('GET', 'https://httpbin.org/get') 
      &gt;&gt;&gt; r = req.prepare() 
      &gt;&gt;&gt; r 
      &lt;PreparedRequest [GET]&gt; 
 
      &gt;&gt;&gt; s = requests.Session() 
      &gt;&gt;&gt; s.send(r) 
      &lt;Response [200]&gt; 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s0">#: HTTP verb to send to the server.</span>
        <span class="s1">self.method = </span><span class="s2">None</span>
        <span class="s0">#: HTTP URL to send the request to.</span>
        <span class="s1">self.url = </span><span class="s2">None</span>
        <span class="s0">#: dictionary of HTTP headers.</span>
        <span class="s1">self.headers = </span><span class="s2">None</span>
        <span class="s0"># The `CookieJar` used to create the Cookie header will be stored here</span>
        <span class="s0"># after prepare_cookies is called</span>
        <span class="s1">self._cookies = </span><span class="s2">None</span>
        <span class="s0">#: request body to send to the server.</span>
        <span class="s1">self.body = </span><span class="s2">None</span>
        <span class="s0">#: dictionary of callback hooks, for internal usage.</span>
        <span class="s1">self.hooks = default_hooks()</span>
        <span class="s0">#: integer denoting starting position of a readable file-like body.</span>
        <span class="s1">self._body_position = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">prepare(self,</span>
            <span class="s1">method=</span><span class="s2">None</span><span class="s1">, url=</span><span class="s2">None</span><span class="s1">, headers=</span><span class="s2">None</span><span class="s1">, files=</span><span class="s2">None</span><span class="s1">, data=</span><span class="s2">None</span><span class="s1">,</span>
            <span class="s1">params=</span><span class="s2">None</span><span class="s1">, auth=</span><span class="s2">None</span><span class="s1">, cookies=</span><span class="s2">None</span><span class="s1">, hooks=</span><span class="s2">None</span><span class="s1">, json=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the entire request with the given parameters.&quot;&quot;&quot;</span>

        <span class="s1">self.prepare_method(method)</span>
        <span class="s1">self.prepare_url(url, params)</span>
        <span class="s1">self.prepare_headers(headers)</span>
        <span class="s1">self.prepare_cookies(cookies)</span>
        <span class="s1">self.prepare_body(data, files, json)</span>
        <span class="s1">self.prepare_auth(auth, url)</span>

        <span class="s0"># Note that prepare_auth must be last to enable authentication schemes</span>
        <span class="s0"># such as OAuth to work on a fully prepared request.</span>

        <span class="s0"># This MUST go after prepare_auth. Authenticators could add a hook</span>
        <span class="s1">self.prepare_hooks(hooks)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;PreparedRequest [%s]&gt;' </span><span class="s1">% (self.method)</span>

    <span class="s2">def </span><span class="s1">copy(self):</span>
        <span class="s1">p = PreparedRequest()</span>
        <span class="s1">p.method = self.method</span>
        <span class="s1">p.url = self.url</span>
        <span class="s1">p.headers = self.headers.copy() </span><span class="s2">if </span><span class="s1">self.headers </span><span class="s2">is not None else None</span>
        <span class="s1">p._cookies = _copy_cookie_jar(self._cookies)</span>
        <span class="s1">p.body = self.body</span>
        <span class="s1">p.hooks = self.hooks</span>
        <span class="s1">p._body_position = self._body_position</span>
        <span class="s2">return </span><span class="s1">p</span>

    <span class="s2">def </span><span class="s1">prepare_method(self, method):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP method.&quot;&quot;&quot;</span>
        <span class="s1">self.method = method</span>
        <span class="s2">if </span><span class="s1">self.method </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.method = to_native_string(self.method.upper())</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_idna_encoded_host(host):</span>
        <span class="s2">import </span><span class="s1">idna</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">host = idna.encode(host, uts46=</span><span class="s2">True</span><span class="s1">).decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">idna.IDNAError:</span>
            <span class="s2">raise </span><span class="s1">UnicodeError</span>
        <span class="s2">return </span><span class="s1">host</span>

    <span class="s2">def </span><span class="s1">prepare_url(self, url, params):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP URL.&quot;&quot;&quot;</span>
        <span class="s0">#: Accept objects that have string representations.</span>
        <span class="s0">#: We're unable to blindly call unicode/str functions</span>
        <span class="s0">#: as this will include the bytestring indicator (b'')</span>
        <span class="s0">#: on python 3.x.</span>
        <span class="s0">#: https://github.com/psf/requests/pull/2238</span>
        <span class="s2">if </span><span class="s1">isinstance(url, bytes):</span>
            <span class="s1">url = url.decode(</span><span class="s4">'utf8'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">url = unicode(url) </span><span class="s2">if </span><span class="s1">is_py2 </span><span class="s2">else </span><span class="s1">str(url)</span>

        <span class="s0"># Remove leading whitespaces from url</span>
        <span class="s1">url = url.lstrip()</span>

        <span class="s0"># Don't do any URL preparation for non-HTTP schemes like `mailto`,</span>
        <span class="s0"># `data` etc to work around exceptions from `url_parse`, which</span>
        <span class="s0"># handles RFC 3986 only.</span>
        <span class="s2">if </span><span class="s4">':' </span><span class="s2">in </span><span class="s1">url </span><span class="s2">and not </span><span class="s1">url.lower().startswith(</span><span class="s4">'http'</span><span class="s1">):</span>
            <span class="s1">self.url = url</span>
            <span class="s2">return</span>

        <span class="s0"># Support for unicode domain names and paths.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">scheme, auth, host, port, path, query, fragment = parse_url(url)</span>
        <span class="s2">except </span><span class="s1">LocationParseError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">InvalidURL(*e.args)</span>

        <span class="s2">if not </span><span class="s1">scheme:</span>
            <span class="s1">error = (</span><span class="s4">&quot;Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?&quot;</span><span class="s1">)</span>
            <span class="s1">error = error.format(to_native_string(url, </span><span class="s4">'utf8'</span><span class="s1">))</span>

            <span class="s2">raise </span><span class="s1">MissingSchema(error)</span>

        <span class="s2">if not </span><span class="s1">host:</span>
            <span class="s2">raise </span><span class="s1">InvalidURL(</span><span class="s4">&quot;Invalid URL %r: No host supplied&quot; </span><span class="s1">% url)</span>

        <span class="s0"># In general, we want to try IDNA encoding the hostname if the string contains</span>
        <span class="s0"># non-ASCII characters. This allows users to automatically get the correct IDNA</span>
        <span class="s0"># behaviour. For strings containing only ASCII characters, we need to also verify</span>
        <span class="s0"># it doesn't start with a wildcard (*), before allowing the unencoded hostname.</span>
        <span class="s2">if not </span><span class="s1">unicode_is_ascii(host):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">host = self._get_idna_encoded_host(host)</span>
            <span class="s2">except </span><span class="s1">UnicodeError:</span>
                <span class="s2">raise </span><span class="s1">InvalidURL(</span><span class="s4">'URL has an invalid label.'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">host.startswith(</span><span class="s4">u'*'</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">InvalidURL(</span><span class="s4">'URL has an invalid label.'</span><span class="s1">)</span>

        <span class="s0"># Carefully reconstruct the network location</span>
        <span class="s1">netloc = auth </span><span class="s2">or </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">netloc:</span>
            <span class="s1">netloc += </span><span class="s4">'@'</span>
        <span class="s1">netloc += host</span>
        <span class="s2">if </span><span class="s1">port:</span>
            <span class="s1">netloc += </span><span class="s4">':' </span><span class="s1">+ str(port)</span>

        <span class="s0"># Bare domains aren't valid URLs.</span>
        <span class="s2">if not </span><span class="s1">path:</span>
            <span class="s1">path = </span><span class="s4">'/'</span>

        <span class="s2">if </span><span class="s1">is_py2:</span>
            <span class="s2">if </span><span class="s1">isinstance(scheme, str):</span>
                <span class="s1">scheme = scheme.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(netloc, str):</span>
                <span class="s1">netloc = netloc.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(path, str):</span>
                <span class="s1">path = path.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(query, str):</span>
                <span class="s1">query = query.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(fragment, str):</span>
                <span class="s1">fragment = fragment.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(params, (str, bytes)):</span>
            <span class="s1">params = to_native_string(params)</span>

        <span class="s1">enc_params = self._encode_params(params)</span>
        <span class="s2">if </span><span class="s1">enc_params:</span>
            <span class="s2">if </span><span class="s1">query:</span>
                <span class="s1">query = </span><span class="s4">'%s&amp;%s' </span><span class="s1">% (query, enc_params)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">query = enc_params</span>

        <span class="s1">url = requote_uri(urlunparse([scheme, netloc, path, </span><span class="s2">None</span><span class="s1">, query, fragment]))</span>
        <span class="s1">self.url = url</span>

    <span class="s2">def </span><span class="s1">prepare_headers(self, headers):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP headers.&quot;&quot;&quot;</span>

        <span class="s1">self.headers = CaseInsensitiveDict()</span>
        <span class="s2">if </span><span class="s1">headers:</span>
            <span class="s2">for </span><span class="s1">header </span><span class="s2">in </span><span class="s1">headers.items():</span>
                <span class="s0"># Raise exception on invalid header value.</span>
                <span class="s1">check_header_validity(header)</span>
                <span class="s1">name, value = header</span>
                <span class="s1">self.headers[to_native_string(name)] = value</span>

    <span class="s2">def </span><span class="s1">prepare_body(self, data, files, json=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot;</span>

        <span class="s0"># Check if file, fo, generator, iterator.</span>
        <span class="s0"># If not, run through normal process.</span>

        <span class="s0"># Nottin' on you.</span>
        <span class="s1">body = </span><span class="s2">None</span>
        <span class="s1">content_type = </span><span class="s2">None</span>

        <span class="s2">if not </span><span class="s1">data </span><span class="s2">and </span><span class="s1">json </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># urllib3 requires a bytes-like body. Python 2's json.dumps</span>
            <span class="s0"># provides this natively, but Python 3 gives a Unicode string.</span>
            <span class="s1">content_type = </span><span class="s4">'application/json'</span>
            <span class="s1">body = complexjson.dumps(json)</span>
            <span class="s2">if not </span><span class="s1">isinstance(body, bytes):</span>
                <span class="s1">body = body.encode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>

        <span class="s1">is_stream = all([</span>
            <span class="s1">hasattr(data, </span><span class="s4">'__iter__'</span><span class="s1">),</span>
            <span class="s2">not </span><span class="s1">isinstance(data, (basestring, list, tuple, Mapping))</span>
        <span class="s1">])</span>

        <span class="s2">if </span><span class="s1">is_stream:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">length = super_len(data)</span>
            <span class="s2">except </span><span class="s1">(TypeError, AttributeError, UnsupportedOperation):</span>
                <span class="s1">length = </span><span class="s2">None</span>

            <span class="s1">body = data</span>

            <span class="s2">if </span><span class="s1">getattr(body, </span><span class="s4">'tell'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s0"># Record the current file position before reading.</span>
                <span class="s0"># This will allow us to rewind a file in the event</span>
                <span class="s0"># of a redirect.</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self._body_position = body.tell()</span>
                <span class="s2">except </span><span class="s1">(IOError, OSError):</span>
                    <span class="s0"># This differentiates from None, allowing us to catch</span>
                    <span class="s0"># a failed `tell()` later when trying to rewind the body</span>
                    <span class="s1">self._body_position = object()</span>

            <span class="s2">if </span><span class="s1">files:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Streamed bodies and files are mutually exclusive.'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">length:</span>
                <span class="s1">self.headers[</span><span class="s4">'Content-Length'</span><span class="s1">] = builtin_str(length)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.headers[</span><span class="s4">'Transfer-Encoding'</span><span class="s1">] = </span><span class="s4">'chunked'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Multi-part file uploads.</span>
            <span class="s2">if </span><span class="s1">files:</span>
                <span class="s1">(body, content_type) = self._encode_files(files, data)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">data:</span>
                    <span class="s1">body = self._encode_params(data)</span>
                    <span class="s2">if </span><span class="s1">isinstance(data, basestring) </span><span class="s2">or </span><span class="s1">hasattr(data, </span><span class="s4">'read'</span><span class="s1">):</span>
                        <span class="s1">content_type = </span><span class="s2">None</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">content_type = </span><span class="s4">'application/x-www-form-urlencoded'</span>

            <span class="s1">self.prepare_content_length(body)</span>

            <span class="s0"># Add content-type if it wasn't explicitly provided.</span>
            <span class="s2">if </span><span class="s1">content_type </span><span class="s2">and </span><span class="s1">(</span><span class="s4">'content-type' </span><span class="s2">not in </span><span class="s1">self.headers):</span>
                <span class="s1">self.headers[</span><span class="s4">'Content-Type'</span><span class="s1">] = content_type</span>

        <span class="s1">self.body = body</span>

    <span class="s2">def </span><span class="s1">prepare_content_length(self, body):</span>
        <span class="s0">&quot;&quot;&quot;Prepare Content-Length header based on request method and body&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">body </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">length = super_len(body)</span>
            <span class="s2">if </span><span class="s1">length:</span>
                <span class="s0"># If length exists, set it. Otherwise, we fallback</span>
                <span class="s0"># to Transfer-Encoding: chunked.</span>
                <span class="s1">self.headers[</span><span class="s4">'Content-Length'</span><span class="s1">] = builtin_str(length)</span>
        <span class="s2">elif </span><span class="s1">self.method </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">'GET'</span><span class="s1">, </span><span class="s4">'HEAD'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.headers.get(</span><span class="s4">'Content-Length'</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Set Content-Length to 0 for methods that can have a body</span>
            <span class="s0"># but don't provide one. (i.e. not GET or HEAD)</span>
            <span class="s1">self.headers[</span><span class="s4">'Content-Length'</span><span class="s1">] = </span><span class="s4">'0'</span>

    <span class="s2">def </span><span class="s1">prepare_auth(self, auth, url=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP auth data.&quot;&quot;&quot;</span>

        <span class="s0"># If no Auth is explicitly provided, extract it from the URL first.</span>
        <span class="s2">if </span><span class="s1">auth </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">url_auth = get_auth_from_url(self.url)</span>
            <span class="s1">auth = url_auth </span><span class="s2">if </span><span class="s1">any(url_auth) </span><span class="s2">else None</span>

        <span class="s2">if </span><span class="s1">auth:</span>
            <span class="s2">if </span><span class="s1">isinstance(auth, tuple) </span><span class="s2">and </span><span class="s1">len(auth) == </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s0"># special-case basic HTTP auth</span>
                <span class="s1">auth = HTTPBasicAuth(*auth)</span>

            <span class="s0"># Allow auth to make its changes.</span>
            <span class="s1">r = auth(self)</span>

            <span class="s0"># Update self to reflect the auth changes.</span>
            <span class="s1">self.__dict__.update(r.__dict__)</span>

            <span class="s0"># Recompute Content-Length</span>
            <span class="s1">self.prepare_content_length(self.body)</span>

    <span class="s2">def </span><span class="s1">prepare_cookies(self, cookies):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given HTTP cookie data. 
 
        This function eventually generates a ``Cookie`` header from the 
        given cookies using cookielib. Due to cookielib's design, the header 
        will not be regenerated if it already exists, meaning this function 
        can only be called once for the life of the 
        :class:`PreparedRequest &lt;PreparedRequest&gt;` object. Any subsequent calls 
        to ``prepare_cookies`` will have no actual effect, unless the &quot;Cookie&quot; 
        header is removed beforehand. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(cookies, cookielib.CookieJar):</span>
            <span class="s1">self._cookies = cookies</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._cookies = cookiejar_from_dict(cookies)</span>

        <span class="s1">cookie_header = get_cookie_header(self._cookies, self)</span>
        <span class="s2">if </span><span class="s1">cookie_header </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.headers[</span><span class="s4">'Cookie'</span><span class="s1">] = cookie_header</span>

    <span class="s2">def </span><span class="s1">prepare_hooks(self, hooks):</span>
        <span class="s0">&quot;&quot;&quot;Prepares the given hooks.&quot;&quot;&quot;</span>
        <span class="s0"># hooks can be passed as None to the prepare method and to this</span>
        <span class="s0"># method. To prevent iterating over None, simply use an empty list</span>
        <span class="s0"># if hooks is False-y</span>
        <span class="s1">hooks = hooks </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">event </span><span class="s2">in </span><span class="s1">hooks:</span>
            <span class="s1">self.register_hook(event, hooks[event])</span>


<span class="s2">class </span><span class="s1">Response(object):</span>
    <span class="s0">&quot;&quot;&quot;The :class:`Response &lt;Response&gt;` object, which contains a 
    server's response to an HTTP request. 
    &quot;&quot;&quot;</span>

    <span class="s1">__attrs__ = [</span>
        <span class="s4">'_content'</span><span class="s1">, </span><span class="s4">'status_code'</span><span class="s1">, </span><span class="s4">'headers'</span><span class="s1">, </span><span class="s4">'url'</span><span class="s1">, </span><span class="s4">'history'</span><span class="s1">,</span>
        <span class="s4">'encoding'</span><span class="s1">, </span><span class="s4">'reason'</span><span class="s1">, </span><span class="s4">'cookies'</span><span class="s1">, </span><span class="s4">'elapsed'</span><span class="s1">, </span><span class="s4">'request'</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._content = </span><span class="s2">False</span>
        <span class="s1">self._content_consumed = </span><span class="s2">False</span>
        <span class="s1">self._next = </span><span class="s2">None</span>

        <span class="s0">#: Integer Code of responded HTTP Status, e.g. 404 or 200.</span>
        <span class="s1">self.status_code = </span><span class="s2">None</span>

        <span class="s0">#: Case-insensitive Dictionary of Response Headers.</span>
        <span class="s0">#: For example, ``headers['content-encoding']`` will return the</span>
        <span class="s0">#: value of a ``'Content-Encoding'`` response header.</span>
        <span class="s1">self.headers = CaseInsensitiveDict()</span>

        <span class="s0">#: File-like object representation of response (for advanced usage).</span>
        <span class="s0">#: Use of ``raw`` requires that ``stream=True`` be set on the request.</span>
        <span class="s0">#: This requirement does not apply for use internally to Requests.</span>
        <span class="s1">self.raw = </span><span class="s2">None</span>

        <span class="s0">#: Final URL location of Response.</span>
        <span class="s1">self.url = </span><span class="s2">None</span>

        <span class="s0">#: Encoding to decode with when accessing r.text.</span>
        <span class="s1">self.encoding = </span><span class="s2">None</span>

        <span class="s0">#: A list of :class:`Response &lt;Response&gt;` objects from</span>
        <span class="s0">#: the history of the Request. Any redirect responses will end</span>
        <span class="s0">#: up here. The list is sorted from the oldest to the most recent request.</span>
        <span class="s1">self.history = []</span>

        <span class="s0">#: Textual reason of responded HTTP Status, e.g. &quot;Not Found&quot; or &quot;OK&quot;.</span>
        <span class="s1">self.reason = </span><span class="s2">None</span>

        <span class="s0">#: A CookieJar of Cookies the server sent back.</span>
        <span class="s1">self.cookies = cookiejar_from_dict({})</span>

        <span class="s0">#: The amount of time elapsed between sending the request</span>
        <span class="s0">#: and the arrival of the response (as a timedelta).</span>
        <span class="s0">#: This property specifically measures the time taken between sending</span>
        <span class="s0">#: the first byte of the request and finishing parsing the headers. It</span>
        <span class="s0">#: is therefore unaffected by consuming the response content or the</span>
        <span class="s0">#: value of the ``stream`` keyword argument.</span>
        <span class="s1">self.elapsed = datetime.timedelta(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">#: The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to which this</span>
        <span class="s0">#: is a response.</span>
        <span class="s1">self.request = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self, *args):</span>
        <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0"># Consume everything; accessing the content attribute makes</span>
        <span class="s0"># sure the content has been fully read.</span>
        <span class="s2">if not </span><span class="s1">self._content_consumed:</span>
            <span class="s1">self.content</span>

        <span class="s2">return </span><span class="s1">{attr: getattr(self, attr, </span><span class="s2">None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.__attrs__}</span>

    <span class="s2">def </span><span class="s1">__setstate__(self, state):</span>
        <span class="s2">for </span><span class="s1">name, value </span><span class="s2">in </span><span class="s1">state.items():</span>
            <span class="s1">setattr(self, name, value)</span>

        <span class="s0"># pickled objects do not have .raw</span>
        <span class="s1">setattr(self, </span><span class="s4">'_content_consumed'</span><span class="s1">, </span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">setattr(self, </span><span class="s4">'raw'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;Response [%s]&gt;' </span><span class="s1">% (self.status_code)</span>

    <span class="s2">def </span><span class="s1">__bool__(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns True if :attr:`status_code` is less than 400. 
 
        This attribute checks if the status code of the response is between 
        400 and 600 to see if there was a client error or a server error. If 
        the status code, is between 200 and 400, this will return True. This 
        is **not** a check to see if the response code is ``200 OK``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.ok</span>

    <span class="s2">def </span><span class="s1">__nonzero__(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns True if :attr:`status_code` is less than 400. 
 
        This attribute checks if the status code of the response is between 
        400 and 600 to see if there was a client error or a server error. If 
        the status code, is between 200 and 400, this will return True. This 
        is **not** a check to see if the response code is ``200 OK``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.ok</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">&quot;&quot;&quot;Allows you to use a response as an iterator.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.iter_content(</span><span class="s3">128</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ok(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns True if :attr:`status_code` is less than 400, False if not. 
 
        This attribute checks if the status code of the response is between 
        400 and 600 to see if there was a client error or a server error. If 
        the status code is between 200 and 400, this will return True. This 
        is **not** a check to see if the response code is ``200 OK``. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.raise_for_status()</span>
        <span class="s2">except </span><span class="s1">HTTPError:</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_redirect(self):</span>
        <span class="s0">&quot;&quot;&quot;True if this Response is a well-formed HTTP redirect that could have 
        been processed automatically (by :meth:`Session.resolve_redirects`). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">'location' </span><span class="s2">in </span><span class="s1">self.headers </span><span class="s2">and </span><span class="s1">self.status_code </span><span class="s2">in </span><span class="s1">REDIRECT_STATI)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_permanent_redirect(self):</span>
        <span class="s0">&quot;&quot;&quot;True if this Response one of the permanent versions of redirect.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">'location' </span><span class="s2">in </span><span class="s1">self.headers </span><span class="s2">and </span><span class="s1">self.status_code </span><span class="s2">in </span><span class="s1">(codes.moved_permanently, codes.permanent_redirect))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">next(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns a PreparedRequest for the next request in a redirect chain, if there is one.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._next</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">apparent_encoding(self):</span>
        <span class="s0">&quot;&quot;&quot;The apparent encoding, provided by the chardet library.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">chardet.detect(self.content)[</span><span class="s4">'encoding'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">iter_content(self, chunk_size=</span><span class="s3">1</span><span class="s1">, decode_unicode=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Iterates over the response data.  When stream=True is set on the 
        request, this avoids reading the content at once into memory for 
        large responses.  The chunk size is the number of bytes it should 
        read into memory.  This is not necessarily the length of each item 
        returned as decoding can take place. 
 
        chunk_size must be of type int or None. A value of None will 
        function differently depending on the value of `stream`. 
        stream=True will read data as it arrives in whatever size the 
        chunks are received. If stream=False, data is returned as 
        a single chunk. 
 
        If decode_unicode is True, content will be decoded using the best 
        available encoding based on the response. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">generate():</span>
            <span class="s0"># Special case for urllib3.</span>
            <span class="s2">if </span><span class="s1">hasattr(self.raw, </span><span class="s4">'stream'</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">self.raw.stream(chunk_size, decode_content=</span><span class="s2">True</span><span class="s1">):</span>
                        <span class="s2">yield </span><span class="s1">chunk</span>
                <span class="s2">except </span><span class="s1">ProtocolError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">raise </span><span class="s1">ChunkedEncodingError(e)</span>
                <span class="s2">except </span><span class="s1">DecodeError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">raise </span><span class="s1">ContentDecodingError(e)</span>
                <span class="s2">except </span><span class="s1">ReadTimeoutError </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s2">raise </span><span class="s1">ConnectionError(e)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># Standard file-like object.</span>
                <span class="s2">while True</span><span class="s1">:</span>
                    <span class="s1">chunk = self.raw.read(chunk_size)</span>
                    <span class="s2">if not </span><span class="s1">chunk:</span>
                        <span class="s2">break</span>
                    <span class="s2">yield </span><span class="s1">chunk</span>

            <span class="s1">self._content_consumed = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">self._content_consumed </span><span class="s2">and </span><span class="s1">isinstance(self._content, bool):</span>
            <span class="s2">raise </span><span class="s1">StreamConsumedError()</span>
        <span class="s2">elif </span><span class="s1">chunk_size </span><span class="s2">is not None and not </span><span class="s1">isinstance(chunk_size, int):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;chunk_size must be an int, it is instead a %s.&quot; </span><span class="s1">% type(chunk_size))</span>
        <span class="s0"># simulate reading small chunks of the content</span>
        <span class="s1">reused_chunks = iter_slices(self._content, chunk_size)</span>

        <span class="s1">stream_chunks = generate()</span>

        <span class="s1">chunks = reused_chunks </span><span class="s2">if </span><span class="s1">self._content_consumed </span><span class="s2">else </span><span class="s1">stream_chunks</span>

        <span class="s2">if </span><span class="s1">decode_unicode:</span>
            <span class="s1">chunks = stream_decode_response_unicode(chunks, self)</span>

        <span class="s2">return </span><span class="s1">chunks</span>

    <span class="s2">def </span><span class="s1">iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=</span><span class="s2">False</span><span class="s1">, delimiter=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Iterates over the response data, one line at a time.  When 
        stream=True is set on the request, this avoids reading the 
        content at once into memory for large responses. 
 
        .. note:: This method is not reentrant safe. 
        &quot;&quot;&quot;</span>

        <span class="s1">pending = </span><span class="s2">None</span>

        <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s1">self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):</span>

            <span class="s2">if </span><span class="s1">pending </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">chunk = pending + chunk</span>

            <span class="s2">if </span><span class="s1">delimiter:</span>
                <span class="s1">lines = chunk.split(delimiter)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">lines = chunk.splitlines()</span>

            <span class="s2">if </span><span class="s1">lines </span><span class="s2">and </span><span class="s1">lines[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">and </span><span class="s1">chunk </span><span class="s2">and </span><span class="s1">lines[-</span><span class="s3">1</span><span class="s1">][-</span><span class="s3">1</span><span class="s1">] == chunk[-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s1">pending = lines.pop()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">pending = </span><span class="s2">None</span>

            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
                <span class="s2">yield </span><span class="s1">line</span>

        <span class="s2">if </span><span class="s1">pending </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">pending</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">content(self):</span>
        <span class="s0">&quot;&quot;&quot;Content of the response, in bytes.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self._content </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s0"># Read the contents.</span>
            <span class="s2">if </span><span class="s1">self._content_consumed:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                    <span class="s4">'The content for this response was already consumed'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">self.status_code == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.raw </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._content = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._content = </span><span class="s4">b''</span><span class="s1">.join(self.iter_content(CONTENT_CHUNK_SIZE)) </span><span class="s2">or </span><span class="s4">b''</span>

        <span class="s1">self._content_consumed = </span><span class="s2">True</span>
        <span class="s0"># don't need to release the connection; that's been handled by urllib3</span>
        <span class="s0"># since we exhausted the data.</span>
        <span class="s2">return </span><span class="s1">self._content</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">text(self):</span>
        <span class="s0">&quot;&quot;&quot;Content of the response, in unicode. 
 
        If Response.encoding is None, encoding will be guessed using 
        ``chardet``. 
 
        The encoding of the response content is determined based solely on HTTP 
        headers, following RFC 2616 to the letter. If you can take advantage of 
        non-HTTP knowledge to make a better guess at the encoding, you should 
        set ``r.encoding`` appropriately before accessing this property. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Try charset from content-type</span>
        <span class="s1">content = </span><span class="s2">None</span>
        <span class="s1">encoding = self.encoding</span>

        <span class="s2">if not </span><span class="s1">self.content:</span>
            <span class="s2">return </span><span class="s1">str(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s0"># Fallback to auto-detected encoding.</span>
        <span class="s2">if </span><span class="s1">self.encoding </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">encoding = self.apparent_encoding</span>

        <span class="s0"># Decode unicode from given encoding.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">content = str(self.content, encoding, errors=</span><span class="s4">'replace'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(LookupError, TypeError):</span>
            <span class="s0"># A LookupError is raised if the encoding was not found which could</span>
            <span class="s0"># indicate a misspelling or similar mistake.</span>
            <span class="s0">#</span>
            <span class="s0"># A TypeError can be raised if encoding is None</span>
            <span class="s0">#</span>
            <span class="s0"># So we try blindly encoding.</span>
            <span class="s1">content = str(self.content, errors=</span><span class="s4">'replace'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">content</span>

    <span class="s2">def </span><span class="s1">json(self, **kwargs):</span>
        <span class="s0">r&quot;&quot;&quot;Returns the json-encoded content of a response, if any. 
 
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes. 
        :raises ValueError: If the response body does not contain valid json. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">self.encoding </span><span class="s2">and </span><span class="s1">self.content </span><span class="s2">and </span><span class="s1">len(self.content) &gt; </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s0"># No encoding set. JSON RFC 4627 section 3 states we should expect</span>
            <span class="s0"># UTF-8, -16 or -32. Detect which one to use; If the detection or</span>
            <span class="s0"># decoding fails, fall back to `self.text` (using chardet to make</span>
            <span class="s0"># a best guess).</span>
            <span class="s1">encoding = guess_json_utf(self.content)</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">complexjson.loads(</span>
                        <span class="s1">self.content.decode(encoding), **kwargs</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                    <span class="s0"># Wrong UTF codec detected; usually because it's not UTF-8</span>
                    <span class="s0"># but some other 8-bit codec.  This is an RFC violation,</span>
                    <span class="s0"># and the server didn't bother to tell us what codec *was*</span>
                    <span class="s0"># used.</span>
                    <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">complexjson.loads(self.text, **kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">links(self):</span>
        <span class="s0">&quot;&quot;&quot;Returns the parsed header links of the response, if any.&quot;&quot;&quot;</span>

        <span class="s1">header = self.headers.get(</span><span class="s4">'link'</span><span class="s1">)</span>

        <span class="s0"># l = MultiDict()</span>
        <span class="s1">l = {}</span>

        <span class="s2">if </span><span class="s1">header:</span>
            <span class="s1">links = parse_header_links(header)</span>

            <span class="s2">for </span><span class="s1">link </span><span class="s2">in </span><span class="s1">links:</span>
                <span class="s1">key = link.get(</span><span class="s4">'rel'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">link.get(</span><span class="s4">'url'</span><span class="s1">)</span>
                <span class="s1">l[key] = link</span>

        <span class="s2">return </span><span class="s1">l</span>

    <span class="s2">def </span><span class="s1">raise_for_status(self):</span>
        <span class="s0">&quot;&quot;&quot;Raises :class:`HTTPError`, if one occurred.&quot;&quot;&quot;</span>

        <span class="s1">http_error_msg = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">isinstance(self.reason, bytes):</span>
            <span class="s0"># We attempt to decode utf-8 first because some servers</span>
            <span class="s0"># choose to localize their reason strings. If the string</span>
            <span class="s0"># isn't utf-8, we fall back to iso-8859-1 for all other</span>
            <span class="s0"># encodings. (See PR #3538)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">reason = self.reason.decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">UnicodeDecodeError:</span>
                <span class="s1">reason = self.reason.decode(</span><span class="s4">'iso-8859-1'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reason = self.reason</span>

        <span class="s2">if </span><span class="s3">400 </span><span class="s1">&lt;= self.status_code &lt; </span><span class="s3">500</span><span class="s1">:</span>
            <span class="s1">http_error_msg = </span><span class="s4">u'%s Client Error: %s for url: %s' </span><span class="s1">% (self.status_code, reason, self.url)</span>

        <span class="s2">elif </span><span class="s3">500 </span><span class="s1">&lt;= self.status_code &lt; </span><span class="s3">600</span><span class="s1">:</span>
            <span class="s1">http_error_msg = </span><span class="s4">u'%s Server Error: %s for url: %s' </span><span class="s1">% (self.status_code, reason, self.url)</span>

        <span class="s2">if </span><span class="s1">http_error_msg:</span>
            <span class="s2">raise </span><span class="s1">HTTPError(http_error_msg, response=self)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s0">&quot;&quot;&quot;Releases the connection back to the pool. Once this method has been 
        called the underlying ``raw`` object must not be accessed again. 
 
        *Note: Should not normally need to be called explicitly.* 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._content_consumed:</span>
            <span class="s1">self.raw.close()</span>

        <span class="s1">release_conn = getattr(self.raw, </span><span class="s4">'release_conn'</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">release_conn </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">release_conn()</span>
</pre>
</body>
</html>