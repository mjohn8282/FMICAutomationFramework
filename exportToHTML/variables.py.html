<html>
<head>
<title>variables.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
variables.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;</span>
<span class="s0"># Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;</span>
<span class="s0"># Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2011-2014, 2017 Google, Inc.</span>
<span class="s0"># Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;</span>
<span class="s0"># Copyright (c) 2014 Ricardo Gemignani &lt;ricardo.gemignani@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;</span>
<span class="s0"># Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;</span>
<span class="s0"># Copyright (c) 2015 Radu Ciorba &lt;radu@devrandom.ro&gt;</span>
<span class="s0"># Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;</span>
<span class="s0"># Copyright (c) 2016, 2018-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2016, 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;</span>
<span class="s0"># Copyright (c) 2016-2017 Derek Gustafson &lt;degustaf@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016-2017 Łukasz Rogalski &lt;rogalski.91@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016 Grant Welch &lt;gwelch925+github@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018 Ville Skyttä &lt;ville.skytta@iki.fi&gt;</span>
<span class="s0"># Copyright (c) 2017 Dan Garrette &lt;dhgarrette@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018-2019 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Mike Miller &lt;mtmiller@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Drew &lt;drewrisinger@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Marianna Polatoglou &lt;mpolatoglou@bloomberg.net&gt;</span>
<span class="s0"># Copyright (c) 2018 mar-chi-pan &lt;mar.polatoglou@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Andrew Simmons &lt;anjsimmo@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Andrew Simmons &lt;a.simmons@deakin.edu.au&gt;</span>
<span class="s0"># Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;</span>
<span class="s0"># Copyright (c) 2020 Ashley Whetter &lt;ashleyw@activestate.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2021 haasea &lt;44787650+haasea@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Alexander Kapshuna &lt;kapsh@kap.sh&gt;</span>

<span class="s0"># Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="s0"># For details: https://github.com/PyCQA/pylint/blob/master/LICENSE</span>

<span class="s0">&quot;&quot;&quot;variables checkers for Python code 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">lru_cache</span>

<span class="s2">import </span><span class="s1">astroid</span>

<span class="s2">from </span><span class="s1">pylint.checkers </span><span class="s2">import </span><span class="s1">BaseChecker, utils</span>
<span class="s2">from </span><span class="s1">pylint.checkers.utils </span><span class="s2">import </span><span class="s1">is_postponed_evaluation_enabled</span>
<span class="s2">from </span><span class="s1">pylint.constants </span><span class="s2">import </span><span class="s1">PY39_PLUS</span>
<span class="s2">from </span><span class="s1">pylint.interfaces </span><span class="s2">import </span><span class="s1">HIGH, INFERENCE, INFERENCE_FAILURE, IAstroidChecker</span>
<span class="s2">from </span><span class="s1">pylint.utils </span><span class="s2">import </span><span class="s1">get_global_option</span>

<span class="s1">SPECIAL_OBJ = re.compile(</span><span class="s3">&quot;^_{2}[a-z]+_{2}$&quot;</span><span class="s1">)</span>
<span class="s1">FUTURE = </span><span class="s3">&quot;__future__&quot;</span>
<span class="s0"># regexp for ignored argument name</span>
<span class="s1">IGNORED_ARGUMENT_NAMES = re.compile(</span><span class="s3">&quot;_.*|^ignored_|^unused_&quot;</span><span class="s1">)</span>
<span class="s0"># In Python 3.7 abc has a Python implementation which is preferred</span>
<span class="s0"># by astroid. Unfortunately this also messes up our explicit checks</span>
<span class="s0"># for `abc`</span>
<span class="s1">METACLASS_NAME_TRANSFORMS = {</span><span class="s3">&quot;_py_abc&quot;</span><span class="s1">: </span><span class="s3">&quot;abc&quot;</span><span class="s1">}</span>
<span class="s1">TYPING_TYPE_CHECKS_GUARDS = frozenset({</span><span class="s3">&quot;typing.TYPE_CHECKING&quot;</span><span class="s1">, </span><span class="s3">&quot;TYPE_CHECKING&quot;</span><span class="s1">})</span>
<span class="s1">BUILTIN_RANGE = </span><span class="s3">&quot;builtins.range&quot;</span>
<span class="s1">TYPING_MODULE = </span><span class="s3">&quot;typing&quot;</span>
<span class="s1">TYPING_NAMES = frozenset(</span>
    <span class="s1">{</span>
        <span class="s3">&quot;Any&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Callable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;ClassVar&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Generic&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Optional&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Tuple&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Type&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;TypeVar&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Union&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AbstractSet&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;ByteString&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Container&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;ContextManager&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Hashable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;ItemsView&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Iterable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Iterator&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;KeysView&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Mapping&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;MappingView&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;MutableMapping&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;MutableSequence&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;MutableSet&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Sequence&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Sized&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;ValuesView&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Awaitable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AsyncIterator&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AsyncIterable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Coroutine&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Collection&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AsyncGenerator&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AsyncContextManager&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Reversible&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsAbs&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsBytes&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsComplex&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsFloat&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsInt&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;SupportsRound&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Counter&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Deque&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Dict&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;DefaultDict&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;List&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Set&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;FrozenSet&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;NamedTuple&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Generator&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;AnyStr&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Text&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Pattern&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;BinaryIO&quot;</span><span class="s1">,</span>
    <span class="s1">}</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_is_from_future_import(stmt, name):</span>
    <span class="s0">&quot;&quot;&quot;Check if the name is a future import from another module.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">module = stmt.do_import_module(stmt.modname)</span>
    <span class="s2">except </span><span class="s1">astroid.AstroidBuildingException:</span>
        <span class="s2">return None</span>

    <span class="s2">for </span><span class="s1">local_node </span><span class="s2">in </span><span class="s1">module.locals.get(name, []):</span>
        <span class="s2">if </span><span class="s1">isinstance(local_node, astroid.ImportFrom) </span><span class="s2">and </span><span class="s1">local_node.modname == FUTURE:</span>
            <span class="s2">return True</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">in_for_else_branch(parent, stmt):</span>
    <span class="s0">&quot;&quot;&quot;Returns True if stmt in inside the else branch for a parent For stmt.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance(parent, astroid.For) </span><span class="s2">and </span><span class="s1">any(</span>
        <span class="s1">else_stmt.parent_of(stmt) </span><span class="s2">or </span><span class="s1">else_stmt == stmt </span><span class="s2">for </span><span class="s1">else_stmt </span><span class="s2">in </span><span class="s1">parent.orelse</span>
    <span class="s1">)</span>


<span class="s1">@lru_cache(maxsize=</span><span class="s4">1000</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">overridden_method(klass, name):</span>
    <span class="s0">&quot;&quot;&quot;get overridden method if any&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">parent = next(klass.local_attr_ancestors(name))</span>
    <span class="s2">except </span><span class="s1">(StopIteration, KeyError):</span>
        <span class="s2">return None</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">meth_node = parent[name]</span>
    <span class="s2">except </span><span class="s1">KeyError:</span>
        <span class="s0"># We have found an ancestor defining &lt;name&gt; but it's not in the local</span>
        <span class="s0"># dictionary. This may happen with astroid built from living objects.</span>
        <span class="s2">return None</span>
    <span class="s2">if </span><span class="s1">isinstance(meth_node, astroid.FunctionDef):</span>
        <span class="s2">return </span><span class="s1">meth_node</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_get_unpacking_extra_info(node, inferred):</span>
    <span class="s0">&quot;&quot;&quot;return extra information to add to the message for unpacking-non-sequence 
    and unbalanced-tuple-unpacking errors 
    &quot;&quot;&quot;</span>
    <span class="s1">more = </span><span class="s3">&quot;&quot;</span>
    <span class="s1">inferred_module = inferred.root().name</span>
    <span class="s2">if </span><span class="s1">node.root().name == inferred_module:</span>
        <span class="s2">if </span><span class="s1">node.lineno == inferred.lineno:</span>
            <span class="s1">more = </span><span class="s3">&quot; %s&quot; </span><span class="s1">% inferred.as_string()</span>
        <span class="s2">elif </span><span class="s1">inferred.lineno:</span>
            <span class="s1">more = </span><span class="s3">&quot; defined at line %s&quot; </span><span class="s1">% inferred.lineno</span>
    <span class="s2">elif </span><span class="s1">inferred.lineno:</span>
        <span class="s1">more = </span><span class="s3">f&quot; defined at line </span><span class="s5">{</span><span class="s1">inferred.lineno</span><span class="s5">} </span><span class="s3">of </span><span class="s5">{</span><span class="s1">inferred_module</span><span class="s5">}</span><span class="s3">&quot;</span>
    <span class="s2">return </span><span class="s1">more</span>


<span class="s2">def </span><span class="s1">_detect_global_scope(node, frame, defframe):</span>
    <span class="s0">&quot;&quot;&quot;Detect that the given frames shares a global 
    scope. 
 
    Two frames shares a global scope when neither 
    of them are hidden under a function scope, as well 
    as any of parent scope of them, until the root scope. 
    In this case, depending from something defined later on 
    will not work, because it is still undefined. 
 
    Example: 
        class A: 
            # B has the same global scope as `C`, leading to a NameError. 
            class B(C): ... 
        class C: ... 
 
    &quot;&quot;&quot;</span>
    <span class="s1">def_scope = scope = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">frame </span><span class="s2">and </span><span class="s1">frame.parent:</span>
        <span class="s1">scope = frame.parent.scope()</span>
    <span class="s2">if </span><span class="s1">defframe </span><span class="s2">and </span><span class="s1">defframe.parent:</span>
        <span class="s1">def_scope = defframe.parent.scope()</span>
    <span class="s2">if </span><span class="s1">isinstance(frame, astroid.FunctionDef):</span>
        <span class="s0"># If the parent of the current node is a</span>
        <span class="s0"># function, then it can be under its scope</span>
        <span class="s0"># (defined in, which doesn't concern us) or</span>
        <span class="s0"># the `-&gt;` part of annotations. The same goes</span>
        <span class="s0"># for annotations of function arguments, they'll have</span>
        <span class="s0"># their parent the Arguments node.</span>
        <span class="s2">if not </span><span class="s1">isinstance(node.parent, (astroid.FunctionDef, astroid.Arguments)):</span>
            <span class="s2">return False</span>
    <span class="s2">elif </span><span class="s1">any(</span>
        <span class="s2">not </span><span class="s1">isinstance(f, (astroid.ClassDef, astroid.Module)) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">(frame, defframe)</span>
    <span class="s1">):</span>
        <span class="s0"># Not interested in other frames, since they are already</span>
        <span class="s0"># not in a global scope.</span>
        <span class="s2">return False</span>

    <span class="s1">break_scopes = []</span>
    <span class="s2">for </span><span class="s1">current_scope </span><span class="s2">in </span><span class="s1">(scope, def_scope):</span>
        <span class="s0"># Look for parent scopes. If there is anything different</span>
        <span class="s0"># than a module or a class scope, then they frames don't</span>
        <span class="s0"># share a global scope.</span>
        <span class="s1">parent_scope = current_scope</span>
        <span class="s2">while </span><span class="s1">parent_scope:</span>
            <span class="s2">if not </span><span class="s1">isinstance(parent_scope, (astroid.ClassDef, astroid.Module)):</span>
                <span class="s1">break_scopes.append(parent_scope)</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">parent_scope.parent:</span>
                <span class="s1">parent_scope = parent_scope.parent.scope()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">break_scopes </span><span class="s2">and </span><span class="s1">len(set(break_scopes)) != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0"># Store different scopes than expected.</span>
        <span class="s0"># If the stored scopes are, in fact, the very same, then it means</span>
        <span class="s0"># that the two frames (frame and defframe) shares the same scope,</span>
        <span class="s0"># and we could apply our lineno analysis over them.</span>
        <span class="s0"># For instance, this works when they are inside a function, the node</span>
        <span class="s0"># that uses a definition and the definition itself.</span>
        <span class="s2">return False</span>
    <span class="s0"># At this point, we are certain that frame and defframe shares a scope</span>
    <span class="s0"># and the definition of the first depends on the second.</span>
    <span class="s2">return </span><span class="s1">frame.lineno &lt; defframe.lineno</span>


<span class="s2">def </span><span class="s1">_infer_name_module(node, name):</span>
    <span class="s1">context = astroid.context.InferenceContext()</span>
    <span class="s1">context.lookupname = name</span>
    <span class="s2">return </span><span class="s1">node.infer(context, asname=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_fix_dot_imports(not_consumed):</span>
    <span class="s0">&quot;&quot;&quot;Try to fix imports with multiple dots, by returning a dictionary 
    with the import names expanded. The function unflattens root imports, 
    like 'xml' (when we have both 'xml.etree' and 'xml.sax'), to 'xml.etree' 
    and 'xml.sax' respectively. 
    &quot;&quot;&quot;</span>
    <span class="s1">names = {}</span>
    <span class="s2">for </span><span class="s1">name, stmts </span><span class="s2">in </span><span class="s1">not_consumed.items():</span>
        <span class="s2">if </span><span class="s1">any(</span>
            <span class="s1">isinstance(stmt, astroid.AssignName)</span>
            <span class="s2">and </span><span class="s1">isinstance(stmt.assign_type(), astroid.AugAssign)</span>
            <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">stmts</span>
        <span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">stmts:</span>
            <span class="s2">if not </span><span class="s1">isinstance(stmt, (astroid.ImportFrom, astroid.Import)):</span>
                <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">imports </span><span class="s2">in </span><span class="s1">stmt.names:</span>
                <span class="s1">second_name = </span><span class="s2">None</span>
                <span class="s1">import_module_name = imports[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">import_module_name == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
                    <span class="s0"># In case of wildcard imports,</span>
                    <span class="s0"># pick the name from inside the imported module.</span>
                    <span class="s1">second_name = name</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">name_matches_dotted_import = </span><span class="s2">False</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">import_module_name.startswith(name)</span>
                        <span class="s2">and </span><span class="s1">import_module_name.find(</span><span class="s3">&quot;.&quot;</span><span class="s1">) &gt; -</span><span class="s4">1</span>
                    <span class="s1">):</span>
                        <span class="s1">name_matches_dotted_import = </span><span class="s2">True</span>

                    <span class="s2">if </span><span class="s1">name_matches_dotted_import </span><span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">imports:</span>
                        <span class="s0"># Most likely something like 'xml.etree',</span>
                        <span class="s0"># which will appear in the .locals as 'xml'.</span>
                        <span class="s0"># Only pick the name if it wasn't consumed.</span>
                        <span class="s1">second_name = import_module_name</span>
                <span class="s2">if </span><span class="s1">second_name </span><span class="s2">and </span><span class="s1">second_name </span><span class="s2">not in </span><span class="s1">names:</span>
                    <span class="s1">names[second_name] = stmt</span>
    <span class="s2">return </span><span class="s1">sorted(names.items(), key=</span><span class="s2">lambda </span><span class="s1">a: a[</span><span class="s4">1</span><span class="s1">].fromlineno)</span>


<span class="s2">def </span><span class="s1">_find_frame_imports(name, frame):</span>
    <span class="s0">&quot;&quot;&quot; 
    Detect imports in the frame, with the required 
    *name*. Such imports can be considered assignments. 
    Returns True if an import for the given name was found. 
    &quot;&quot;&quot;</span>
    <span class="s1">imports = frame.nodes_of_class((astroid.Import, astroid.ImportFrom))</span>
    <span class="s2">for </span><span class="s1">import_node </span><span class="s2">in </span><span class="s1">imports:</span>
        <span class="s2">for </span><span class="s1">import_name, import_alias </span><span class="s2">in </span><span class="s1">import_node.names:</span>
            <span class="s0"># If the import uses an alias, check only that.</span>
            <span class="s0"># Otherwise, check only the import name.</span>
            <span class="s2">if </span><span class="s1">import_alias:</span>
                <span class="s2">if </span><span class="s1">import_alias == name:</span>
                    <span class="s2">return True</span>
            <span class="s2">elif </span><span class="s1">import_name </span><span class="s2">and </span><span class="s1">import_name == name:</span>
                <span class="s2">return True</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_import_name_is_global(stmt, global_names):</span>
    <span class="s2">for </span><span class="s1">import_name, import_alias </span><span class="s2">in </span><span class="s1">stmt.names:</span>
        <span class="s0"># If the import uses an alias, check only that.</span>
        <span class="s0"># Otherwise, check only the import name.</span>
        <span class="s2">if </span><span class="s1">import_alias:</span>
            <span class="s2">if </span><span class="s1">import_alias </span><span class="s2">in </span><span class="s1">global_names:</span>
                <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">import_name </span><span class="s2">in </span><span class="s1">global_names:</span>
            <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_flattened_scope_names(iterator):</span>
    <span class="s1">values = (set(stmt.names) </span><span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">iterator)</span>
    <span class="s2">return </span><span class="s1">set(itertools.chain.from_iterable(values))</span>


<span class="s2">def </span><span class="s1">_assigned_locally(name_node):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks if name_node has corresponding assign statement in same scope 
    &quot;&quot;&quot;</span>
    <span class="s1">assign_stmts = name_node.scope().nodes_of_class(astroid.AssignName)</span>
    <span class="s2">return </span><span class="s1">any(a.name == name_node.name </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">assign_stmts)</span>


<span class="s2">def </span><span class="s1">_is_type_checking_import(node):</span>
    <span class="s1">parent = node.parent</span>
    <span class="s2">if not </span><span class="s1">isinstance(parent, astroid.If):</span>
        <span class="s2">return False</span>
    <span class="s1">test = parent.test</span>
    <span class="s2">return </span><span class="s1">test.as_string() </span><span class="s2">in </span><span class="s1">TYPING_TYPE_CHECKS_GUARDS</span>


<span class="s2">def </span><span class="s1">_has_locals_call_after_node(stmt, scope):</span>
    <span class="s1">skip_nodes = (</span>
        <span class="s1">astroid.FunctionDef,</span>
        <span class="s1">astroid.ClassDef,</span>
        <span class="s1">astroid.Import,</span>
        <span class="s1">astroid.ImportFrom,</span>
    <span class="s1">)</span>
    <span class="s2">for </span><span class="s1">call </span><span class="s2">in </span><span class="s1">scope.nodes_of_class(astroid.Call, skip_klass=skip_nodes):</span>
        <span class="s1">inferred = utils.safe_infer(call.func)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">utils.is_builtin_object(inferred)</span>
            <span class="s2">and </span><span class="s1">getattr(inferred, </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">) == </span><span class="s3">&quot;locals&quot;</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">stmt.lineno &lt; call.lineno:</span>
                <span class="s2">return True</span>
    <span class="s2">return False</span>


<span class="s1">MSGS = {</span>
    <span class="s3">&quot;E0601&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Using variable %r before assignment&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;used-before-assignment&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a local variable is accessed before its assignment.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;E0602&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Undefined variable %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;undefined-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an undefined variable is accessed.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;E0603&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Undefined variable name %r in __all__&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;undefined-all-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an undefined variable name is referenced in __all__.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;E0604&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Invalid object %r in __all__, must contain only strings&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;invalid-all-object&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an invalid (non-string) object occurs in __all__.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;E0611&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;No name %r in module %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;no-name-in-module&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a name cannot be found in a module.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0601&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Global variable %r undefined at the module level&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;global-variable-undefined&quot;</span><span class="s1">,</span>
        <span class="s3">'Used when a variable is defined through the &quot;global&quot; statement '</span>
        <span class="s3">&quot;but the variable is not defined in the module scope.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0602&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Using global for %r but no assignment is done&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;global-variable-not-assigned&quot;</span><span class="s1">,</span>
        <span class="s3">'Used when a variable is defined through the &quot;global&quot; statement '</span>
        <span class="s3">&quot;but no assignment to this variable is done.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0603&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Using the global statement&quot;</span><span class="s1">,  </span><span class="s0"># W0121</span>
        <span class="s3">&quot;global-statement&quot;</span><span class="s1">,</span>
        <span class="s3">'Used when you use the &quot;global&quot; statement to update a global '</span>
        <span class="s3">&quot;variable. Pylint just try to discourage this &quot;</span>
        <span class="s3">&quot;usage. That doesn't mean you cannot use it !&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0604&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Using the global statement at the module level&quot;</span><span class="s1">,  </span><span class="s0"># W0103</span>
        <span class="s3">&quot;global-at-module-level&quot;</span><span class="s1">,</span>
        <span class="s3">'Used when you use the &quot;global&quot; statement at the module level '</span>
        <span class="s3">&quot;since it has no effect&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0611&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Unused %s&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-import&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an imported module or variable is not used.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0612&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Unused variable %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a variable is defined but not used.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0613&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Unused argument %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-argument&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a function or method argument is not used.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0614&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Unused import %s from wildcard import&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-wildcard-import&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an imported module or variable is not used from a &quot;</span>
        <span class="s3">&quot;`'from X import *'` style import.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0621&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Redefining name %r from outer scope (line %s)&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a variable's name hides a name defined in the outer scope.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0622&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Redefining built-in %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a variable or function override a built-in.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0623&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Redefining name %r from %s in exception handler&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;redefine-in-handler&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when an exception handler assigns the exception to an existing name&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0631&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Using possibly undefined loop variable %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a loop variable (i.e. defined by a for loop or &quot;</span>
        <span class="s3">&quot;a list comprehension or a generator expression) is used outside &quot;</span>
        <span class="s3">&quot;the loop.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0632&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Possible unbalanced tuple unpacking with &quot;</span>
        <span class="s3">&quot;sequence%s: &quot;</span>
        <span class="s3">&quot;left side has %d label(s), right side has %d value(s)&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unbalanced-tuple-unpacking&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when there is an unbalanced tuple unpacking in assignment&quot;</span><span class="s1">,</span>
        <span class="s1">{</span><span class="s3">&quot;old_names&quot;</span><span class="s1">: [(</span><span class="s3">&quot;E0632&quot;</span><span class="s1">, </span><span class="s3">&quot;old-unbalanced-tuple-unpacking&quot;</span><span class="s1">)]},</span>
    <span class="s1">),</span>
    <span class="s3">&quot;E0633&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Attempting to unpack a non-sequence%s&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unpacking-non-sequence&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when something which is not &quot;</span>
        <span class="s3">&quot;a sequence is used in an unpack assignment&quot;</span><span class="s1">,</span>
        <span class="s1">{</span><span class="s3">&quot;old_names&quot;</span><span class="s1">: [(</span><span class="s3">&quot;W0633&quot;</span><span class="s1">, </span><span class="s3">&quot;old-unpacking-non-sequence&quot;</span><span class="s1">)]},</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0640&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Cell variable %s defined in loop&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;cell-var-from-loop&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;A variable used in a closure is defined in a loop. &quot;</span>
        <span class="s3">&quot;This will result in all closures using the same value for &quot;</span>
        <span class="s3">&quot;the closed-over variable.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0641&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Possibly unused variable %r&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;possibly-unused-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Used when a variable is defined but might not be used. &quot;</span>
        <span class="s3">&quot;The possibility comes from the fact that locals() might be used, &quot;</span>
        <span class="s3">&quot;which could consume or not the said variable&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
    <span class="s3">&quot;W0642&quot;</span><span class="s1">: (</span>
        <span class="s3">&quot;Invalid assignment to %s in method&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;self-cls-assignment&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;Invalid assignment to self or cls in instance or class method &quot;</span>
        <span class="s3">&quot;respectively.&quot;</span><span class="s1">,</span>
    <span class="s1">),</span>
<span class="s1">}</span>


<span class="s1">ScopeConsumer = collections.namedtuple(</span>
    <span class="s3">&quot;ScopeConsumer&quot;</span><span class="s1">, </span><span class="s3">&quot;to_consume consumed scope_type&quot;</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">NamesConsumer:</span>
    <span class="s0">&quot;&quot;&quot; 
    A simple class to handle consumed, to consume and scope type info of node locals 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, node, scope_type):</span>
        <span class="s1">self._atomic = ScopeConsumer(copy.copy(node.locals), {}, scope_type)</span>
        <span class="s1">self.node = node</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">to_consumes = [</span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">k</span><span class="s5">}</span><span class="s3">-&gt;</span><span class="s5">{</span><span class="s1">v</span><span class="s5">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">self._atomic.to_consume.items()]</span>
        <span class="s1">consumed = [</span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">k</span><span class="s5">}</span><span class="s3">-&gt;</span><span class="s5">{</span><span class="s1">v</span><span class="s5">}</span><span class="s3">&quot; </span><span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">self._atomic.consumed.items()]</span>
        <span class="s1">to_consumes = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(to_consumes)</span>
        <span class="s1">consumed = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(consumed)</span>
        <span class="s2">return </span><span class="s3">f&quot;&quot;&quot;</span>
<span class="s3">to_consume : </span><span class="s5">{</span><span class="s1">to_consumes</span><span class="s5">}</span>
<span class="s3">consumed : </span><span class="s5">{</span><span class="s1">consumed</span><span class="s5">}</span>
<span class="s3">scope_type : </span><span class="s5">{</span><span class="s1">self._atomic.scope_type</span><span class="s5">}</span>
<span class="s3">&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self._atomic)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">to_consume(self):</span>
        <span class="s2">return </span><span class="s1">self._atomic.to_consume</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">consumed(self):</span>
        <span class="s2">return </span><span class="s1">self._atomic.consumed</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">scope_type(self):</span>
        <span class="s2">return </span><span class="s1">self._atomic.scope_type</span>

    <span class="s2">def </span><span class="s1">mark_as_consumed(self, name, new_node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Mark the name as consumed and delete it from 
        the to_consume dictionary 
        &quot;&quot;&quot;</span>
        <span class="s1">self.consumed[name] = new_node</span>
        <span class="s2">del </span><span class="s1">self.to_consume[name]</span>

    <span class="s2">def </span><span class="s1">get_next_to_consume(self, node):</span>
        <span class="s0"># Get the definition of `node` from this scope</span>
        <span class="s1">name = node.name</span>
        <span class="s1">parent_node = node.parent</span>
        <span class="s1">found_node = self.to_consume.get(name)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">found_node</span>
            <span class="s2">and </span><span class="s1">isinstance(parent_node, astroid.Assign)</span>
            <span class="s2">and </span><span class="s1">parent_node == found_node[</span><span class="s4">0</span><span class="s1">].parent</span>
        <span class="s1">):</span>
            <span class="s1">lhs = found_node[</span><span class="s4">0</span><span class="s1">].parent.targets[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">lhs.name == name:  </span><span class="s0"># this name is defined in this very statement</span>
                <span class="s1">found_node = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">found_node</span>
            <span class="s2">and </span><span class="s1">isinstance(parent_node, astroid.For)</span>
            <span class="s2">and </span><span class="s1">parent_node.iter == node</span>
            <span class="s2">and </span><span class="s1">parent_node.target </span><span class="s2">in </span><span class="s1">found_node</span>
        <span class="s1">):</span>
            <span class="s1">found_node = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">found_node</span>


<span class="s0"># pylint: disable=too-many-public-methods</span>
<span class="s2">class </span><span class="s1">VariablesChecker(BaseChecker):</span>
    <span class="s0">&quot;&quot;&quot;checks for 
    * unused variables / imports 
    * undefined variables 
    * redefinition of variable from builtins or from an outer scope 
    * use of variable before assignment 
    * __all__ consistency 
    * self/cls assignment 
    &quot;&quot;&quot;</span>

    <span class="s1">__implements__ = IAstroidChecker</span>

    <span class="s1">name = </span><span class="s3">&quot;variables&quot;</span>
    <span class="s1">msgs = MSGS</span>
    <span class="s1">priority = -</span><span class="s4">1</span>
    <span class="s1">options = (</span>
        <span class="s1">(</span>
            <span class="s3">&quot;init-import&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">,</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;yn&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;y_or_n&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;Tells whether we should check for unused import in &quot;</span>
                <span class="s3">&quot;__init__ files.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;dummy-variables-rgx&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: </span><span class="s3">&quot;_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;regexp&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;regexp&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;A regular expression matching the name of dummy &quot;</span>
                <span class="s3">&quot;variables (i.e. expected to not be used).&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;additional-builtins&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: (),</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;csv&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;comma separated list&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;List of additional names supposed to be defined in &quot;</span>
                <span class="s3">&quot;builtins. Remember that you should avoid defining new builtins &quot;</span>
                <span class="s3">&quot;when possible.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;callbacks&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: (</span><span class="s3">&quot;cb_&quot;</span><span class="s1">, </span><span class="s3">&quot;_cb&quot;</span><span class="s1">),</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;csv&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;callbacks&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;List of strings which can identify a callback &quot;</span>
                <span class="s3">&quot;function by name. A callback name must start or &quot;</span>
                <span class="s3">&quot;end with one of those strings.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;redefining-builtins-modules&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: (</span>
                    <span class="s3">&quot;six.moves&quot;</span><span class="s1">,</span>
                    <span class="s3">&quot;past.builtins&quot;</span><span class="s1">,</span>
                    <span class="s3">&quot;future.builtins&quot;</span><span class="s1">,</span>
                    <span class="s3">&quot;builtins&quot;</span><span class="s1">,</span>
                    <span class="s3">&quot;io&quot;</span><span class="s1">,</span>
                <span class="s1">),</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;csv&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;comma separated list&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;List of qualified module names which can have objects &quot;</span>
                <span class="s3">&quot;that can redefine builtins.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;ignored-argument-names&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: IGNORED_ARGUMENT_NAMES,</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;regexp&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;regexp&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;Argument names that match this expression will be &quot;</span>
                <span class="s3">&quot;ignored. Default to name with leading underscore.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;allow-global-unused-variables&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">,</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;yn&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;y_or_n&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;Tells whether unused global variables should be treated as a violation.&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
        <span class="s1">(</span>
            <span class="s3">&quot;allowed-redefined-builtins&quot;</span><span class="s1">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;default&quot;</span><span class="s1">: (),</span>
                <span class="s3">&quot;type&quot;</span><span class="s1">: </span><span class="s3">&quot;csv&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;metavar&quot;</span><span class="s1">: </span><span class="s3">&quot;&lt;comma separated list&gt;&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;help&quot;</span><span class="s1">: </span><span class="s3">&quot;List of names allowed to shadow builtins&quot;</span><span class="s1">,</span>
            <span class="s1">},</span>
        <span class="s1">),</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self, linter=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">BaseChecker.__init__(self, linter)</span>
        <span class="s1">self._to_consume = (</span>
            <span class="s2">None  </span><span class="s0"># list of tuples: (to_consume:dict, consumed:dict, scope_type:str)</span>
        <span class="s1">)</span>
        <span class="s1">self._checking_mod_attr = </span><span class="s2">None</span>
        <span class="s1">self._loop_variables = []</span>
        <span class="s1">self._type_annotation_names = []</span>
        <span class="s1">self._postponed_evaluation_enabled = </span><span class="s2">False</span>

    <span class="s1">@utils.check_messages(</span><span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">visit_for(self, node):</span>
        <span class="s1">assigned_to = [</span>
            <span class="s1">var.name </span><span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">node.target.nodes_of_class(astroid.AssignName)</span>
        <span class="s1">]</span>

        <span class="s0"># Only check variables that are used</span>
        <span class="s1">dummy_rgx = self.config.dummy_variables_rgx</span>
        <span class="s1">assigned_to = [var </span><span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">assigned_to </span><span class="s2">if not </span><span class="s1">dummy_rgx.match(var)]</span>

        <span class="s2">for </span><span class="s1">variable </span><span class="s2">in </span><span class="s1">assigned_to:</span>
            <span class="s2">for </span><span class="s1">outer_for, outer_variables </span><span class="s2">in </span><span class="s1">self._loop_variables:</span>
                <span class="s2">if </span><span class="s1">variable </span><span class="s2">in </span><span class="s1">outer_variables </span><span class="s2">and not </span><span class="s1">in_for_else_branch(</span>
                    <span class="s1">outer_for, node</span>
                <span class="s1">):</span>
                    <span class="s1">self.add_message(</span>
                        <span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">,</span>
                        <span class="s1">args=(variable, outer_for.fromlineno),</span>
                        <span class="s1">node=node,</span>
                    <span class="s1">)</span>
                    <span class="s2">break</span>

        <span class="s1">self._loop_variables.append((node, assigned_to))</span>

    <span class="s1">@utils.check_messages(</span><span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">leave_for(self, node):</span>
        <span class="s1">self._loop_variables.pop()</span>
        <span class="s1">self._store_type_annotation_names(node)</span>

    <span class="s2">def </span><span class="s1">visit_module(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit module : update consumption analysis variable 
        checks globals doesn't overrides builtins 
        &quot;&quot;&quot;</span>
        <span class="s1">self._to_consume = [NamesConsumer(node, </span><span class="s3">&quot;module&quot;</span><span class="s1">)]</span>
        <span class="s1">self._postponed_evaluation_enabled = is_postponed_evaluation_enabled(node)</span>

        <span class="s2">for </span><span class="s1">name, stmts </span><span class="s2">in </span><span class="s1">node.locals.items():</span>
            <span class="s2">if </span><span class="s1">utils.is_builtin(name) </span><span class="s2">and not </span><span class="s1">utils.is_inside_except(stmts[</span><span class="s4">0</span><span class="s1">]):</span>
                <span class="s2">if </span><span class="s1">self._should_ignore_redefined_builtin(stmts[</span><span class="s4">0</span><span class="s1">]) </span><span class="s2">or </span><span class="s1">name == </span><span class="s3">&quot;__doc__&quot;</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">, args=name, node=stmts[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">@utils.check_messages(</span>
        <span class="s3">&quot;unused-import&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-wildcard-import&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;undefined-all-variable&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;invalid-all-object&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;unused-variable&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">leave_module(self, node):</span>
        <span class="s0">&quot;&quot;&quot;leave module: check globals&quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">len(self._to_consume) == </span><span class="s4">1</span>

        <span class="s1">self._check_metaclasses(node)</span>
        <span class="s1">not_consumed = self._to_consume.pop().to_consume</span>
        <span class="s0"># attempt to check for __all__ if defined</span>
        <span class="s2">if </span><span class="s3">&quot;__all__&quot; </span><span class="s2">in </span><span class="s1">node.locals:</span>
            <span class="s1">self._check_all(node, not_consumed)</span>

        <span class="s0"># check for unused globals</span>
        <span class="s1">self._check_globals(not_consumed)</span>

        <span class="s0"># don't check unused imports in __init__ files</span>
        <span class="s2">if not </span><span class="s1">self.config.init_import </span><span class="s2">and </span><span class="s1">node.package:</span>
            <span class="s2">return</span>

        <span class="s1">self._check_imports(not_consumed)</span>

    <span class="s2">def </span><span class="s1">visit_classdef(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit class: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;class&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_classdef(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave class: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here (no sense)</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">visit_lambda(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit lambda: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;lambda&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_lambda(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave lambda: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">visit_generatorexp(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit genexpr: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;comprehension&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_generatorexp(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave genexpr: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">visit_dictcomp(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit dictcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;comprehension&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_dictcomp(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave dictcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">visit_setcomp(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit setcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;comprehension&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_setcomp(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave setcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">visit_functiondef(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit function: update consumption analysis variable and check locals&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;function&quot;</span><span class="s1">))</span>
        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">globs = node.root().globals</span>
        <span class="s2">for </span><span class="s1">name, stmt </span><span class="s2">in </span><span class="s1">node.items():</span>
            <span class="s2">if </span><span class="s1">utils.is_inside_except(stmt):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">globs </span><span class="s2">and not </span><span class="s1">isinstance(stmt, astroid.Global):</span>
                <span class="s1">definition = globs[name][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(definition, astroid.ImportFrom)</span>
                    <span class="s2">and </span><span class="s1">definition.modname == FUTURE</span>
                <span class="s1">):</span>
                    <span class="s0"># It is a __future__ directive, not a symbol.</span>
                    <span class="s2">continue</span>

                <span class="s0"># Do not take in account redefined names for the purpose</span>
                <span class="s0"># of type checking.:</span>
                <span class="s2">if </span><span class="s1">any(</span>
                    <span class="s1">isinstance(definition.parent, astroid.If)</span>
                    <span class="s2">and </span><span class="s1">definition.parent.test.as_string() </span><span class="s2">in </span><span class="s1">TYPING_TYPE_CHECKS_GUARDS</span>
                    <span class="s2">for </span><span class="s1">definition </span><span class="s2">in </span><span class="s1">globs[name]</span>
                <span class="s1">):</span>
                    <span class="s2">continue</span>

                <span class="s1">line = definition.fromlineno</span>
                <span class="s2">if not </span><span class="s1">self._is_name_ignored(stmt, name):</span>
                    <span class="s1">self.add_message(</span>
                        <span class="s3">&quot;redefined-outer-name&quot;</span><span class="s1">, args=(name, line), node=stmt</span>
                    <span class="s1">)</span>

            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">utils.is_builtin(name)</span>
                <span class="s2">and not </span><span class="s1">self._allowed_redefined_builtin(name)</span>
                <span class="s2">and not </span><span class="s1">self._should_ignore_redefined_builtin(stmt)</span>
            <span class="s1">):</span>
                <span class="s0"># do not print Redefining builtin for additional builtins</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">, args=name, node=stmt)</span>

    <span class="s2">def </span><span class="s1">leave_functiondef(self, node):</span>
        <span class="s0">&quot;&quot;&quot;leave function: check function's locals are consumed&quot;&quot;&quot;</span>
        <span class="s1">self._check_metaclasses(node)</span>

        <span class="s2">if </span><span class="s1">node.type_comment_returns:</span>
            <span class="s1">self._store_type_annotation_node(node.type_comment_returns)</span>
        <span class="s2">if </span><span class="s1">node.type_comment_args:</span>
            <span class="s2">for </span><span class="s1">argument_annotation </span><span class="s2">in </span><span class="s1">node.type_comment_args:</span>
                <span class="s1">self._store_type_annotation_node(argument_annotation)</span>

        <span class="s1">not_consumed = self._to_consume.pop().to_consume</span>
        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;unused-variable&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;possibly-unused-variable&quot;</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;unused-argument&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s0"># Don't check arguments of function which are only raising an exception.</span>
        <span class="s2">if </span><span class="s1">utils.is_error(node):</span>
            <span class="s2">return</span>

        <span class="s0"># Don't check arguments of abstract methods or within an interface.</span>
        <span class="s1">is_method = node.is_method()</span>
        <span class="s2">if </span><span class="s1">is_method </span><span class="s2">and </span><span class="s1">node.is_abstract():</span>
            <span class="s2">return</span>

        <span class="s1">global_names = _flattened_scope_names(node.nodes_of_class(astroid.Global))</span>
        <span class="s1">nonlocal_names = _flattened_scope_names(node.nodes_of_class(astroid.Nonlocal))</span>
        <span class="s2">for </span><span class="s1">name, stmts </span><span class="s2">in </span><span class="s1">not_consumed.items():</span>
            <span class="s1">self._check_is_unused(name, node, stmts[</span><span class="s4">0</span><span class="s1">], global_names, nonlocal_names)</span>

    <span class="s1">visit_asyncfunctiondef = visit_functiondef</span>
    <span class="s1">leave_asyncfunctiondef = leave_functiondef</span>

    <span class="s1">@utils.check_messages(</span>
        <span class="s3">&quot;global-variable-undefined&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;global-variable-not-assigned&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;global-statement&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;global-at-module-level&quot;</span><span class="s1">,</span>
        <span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">visit_global(self, node):</span>
        <span class="s0">&quot;&quot;&quot;check names imported exists in the global scope&quot;&quot;&quot;</span>
        <span class="s1">frame = node.frame()</span>
        <span class="s2">if </span><span class="s1">isinstance(frame, astroid.Module):</span>
            <span class="s1">self.add_message(</span><span class="s3">&quot;global-at-module-level&quot;</span><span class="s1">, node=node)</span>
            <span class="s2">return</span>

        <span class="s1">module = frame.root()</span>
        <span class="s1">default_message = </span><span class="s2">True</span>
        <span class="s1">locals_ = node.scope().locals</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">node.names:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">assign_nodes = module.getattr(name)</span>
            <span class="s2">except </span><span class="s1">astroid.NotFoundError:</span>
                <span class="s0"># unassigned global, skip</span>
                <span class="s1">assign_nodes = []</span>

            <span class="s1">not_defined_locally_by_import = </span><span class="s2">not </span><span class="s1">any(</span>
                <span class="s1">isinstance(local, astroid.node_classes.Import)</span>
                <span class="s2">for </span><span class="s1">local </span><span class="s2">in </span><span class="s1">locals_.get(name, ())</span>
            <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">assign_nodes </span><span class="s2">and </span><span class="s1">not_defined_locally_by_import:</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;global-variable-not-assigned&quot;</span><span class="s1">, args=name, node=node)</span>
                <span class="s1">default_message = </span><span class="s2">False</span>
                <span class="s2">continue</span>

            <span class="s2">for </span><span class="s1">anode </span><span class="s2">in </span><span class="s1">assign_nodes:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(anode, astroid.AssignName)</span>
                    <span class="s2">and </span><span class="s1">anode.name </span><span class="s2">in </span><span class="s1">module.special_attributes</span>
                <span class="s1">):</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;redefined-builtin&quot;</span><span class="s1">, args=name, node=node)</span>
                    <span class="s2">break</span>
                <span class="s2">if </span><span class="s1">anode.frame() </span><span class="s2">is </span><span class="s1">module:</span>
                    <span class="s0"># module level assignment</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">not_defined_locally_by_import:</span>
                    <span class="s0"># global undefined at the module scope</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;global-variable-undefined&quot;</span><span class="s1">, args=name, node=node)</span>
                    <span class="s1">default_message = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">default_message:</span>
            <span class="s1">self.add_message(</span><span class="s3">&quot;global-statement&quot;</span><span class="s1">, node=node)</span>

    <span class="s2">def </span><span class="s1">visit_assignname(self, node):</span>
        <span class="s2">if </span><span class="s1">isinstance(node.assign_type(), astroid.AugAssign):</span>
            <span class="s1">self.visit_name(node)</span>

    <span class="s2">def </span><span class="s1">visit_delname(self, node):</span>
        <span class="s1">self.visit_name(node)</span>

    <span class="s2">def </span><span class="s1">visit_name(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Check that a name is defined in the current scope&quot;&quot;&quot;</span>
        <span class="s1">stmt = node.statement()</span>
        <span class="s2">if </span><span class="s1">stmt.fromlineno </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># name node from an astroid built from live code, skip</span>
            <span class="s2">assert not </span><span class="s1">stmt.root().file.endswith(</span><span class="s3">&quot;.py&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>

        <span class="s1">name = node.name</span>
        <span class="s1">frame = stmt.scope()</span>
        <span class="s1">start_index = len(self._to_consume) - </span><span class="s4">1</span>

        <span class="s1">undefined_variable_is_enabled = self.linter.is_message_enabled(</span>
            <span class="s3">&quot;undefined-variable&quot;</span>
        <span class="s1">)</span>
        <span class="s1">used_before_assignment_is_enabled = self.linter.is_message_enabled(</span>
            <span class="s3">&quot;used-before-assignment&quot;</span>
        <span class="s1">)</span>

        <span class="s0"># iterates through parent scopes, from the inner to the outer</span>
        <span class="s1">base_scope_type = self._to_consume[start_index].scope_type</span>
        <span class="s0"># pylint: disable=too-many-nested-blocks; refactoring this block is a pain.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(start_index, -</span><span class="s4">1</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">current_consumer = self._to_consume[i]</span>

            <span class="s0"># The list of base classes in the class definition is not part</span>
            <span class="s0"># of the class body.</span>
            <span class="s0"># If the current scope is a class scope but it's not the inner</span>
            <span class="s0"># scope, ignore it. This prevents to access this scope instead of</span>
            <span class="s0"># the globals one in function members when there are some common</span>
            <span class="s0"># names.</span>
            <span class="s2">if </span><span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;class&quot; </span><span class="s2">and </span><span class="s1">(</span>
                <span class="s1">utils.is_ancestor_name(current_consumer.node, node)</span>
                <span class="s2">or </span><span class="s1">(i != start_index </span><span class="s2">and </span><span class="s1">self._ignore_class_scope(node))</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>

            <span class="s0"># Ignore inner class scope for keywords in class definition</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;class&quot;</span>
                <span class="s2">and </span><span class="s1">isinstance(node.parent, astroid.Keyword)</span>
                <span class="s2">and </span><span class="s1">isinstance(node.parent.parent, astroid.ClassDef)</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>

            <span class="s0"># if the name node is used as a function default argument's value or as</span>
            <span class="s0"># a decorator, then start from the parent frame of the function instead</span>
            <span class="s0"># of the function frame - and thus open an inner class scope</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;function&quot;</span>
                <span class="s2">and </span><span class="s1">self._defined_in_function_definition(node, current_consumer.node)</span>
            <span class="s1">):</span>
                <span class="s0"># ignore function scope if is an annotation/default/decorator, as not in the body</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;lambda&quot; </span><span class="s2">and </span><span class="s1">utils.is_default_argument(</span>
                <span class="s1">node, current_consumer.node</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>

            <span class="s0"># the name has already been consumed, only check it's not a loop</span>
            <span class="s0"># variable used outside the loop</span>
            <span class="s0"># avoid the case where there are homonyms inside function scope and</span>
            <span class="s0"># comprehension current scope (avoid bug #1731)</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">current_consumer.consumed </span><span class="s2">and not </span><span class="s1">(</span>
                <span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;comprehension&quot;</span>
                <span class="s2">and </span><span class="s1">self._has_homonym_in_upper_function_scope(node, i)</span>
            <span class="s1">):</span>
                <span class="s1">defnode = utils.assign_parent(current_consumer.consumed[name][</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">self._check_late_binding_closure(node, defnode)</span>
                <span class="s1">self._loopvar_name(node, name)</span>
                <span class="s2">break</span>

            <span class="s1">found_node = current_consumer.get_next_to_consume(node)</span>
            <span class="s2">if </span><span class="s1">found_node </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s0"># checks for use before assignment</span>
            <span class="s1">defnode = utils.assign_parent(current_consumer.to_consume[name][</span><span class="s4">0</span><span class="s1">])</span>

            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">undefined_variable_is_enabled </span><span class="s2">or </span><span class="s1">used_before_assignment_is_enabled</span>
            <span class="s1">) </span><span class="s2">and </span><span class="s1">defnode </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._check_late_binding_closure(node, defnode)</span>
                <span class="s1">defstmt = defnode.statement()</span>
                <span class="s1">defframe = defstmt.frame()</span>
                <span class="s0"># The class reuses itself in the class scope.</span>
                <span class="s1">recursive_klass = (</span>
                    <span class="s1">frame </span><span class="s2">is </span><span class="s1">defframe</span>
                    <span class="s2">and </span><span class="s1">defframe.parent_of(node)</span>
                    <span class="s2">and </span><span class="s1">isinstance(defframe, astroid.ClassDef)</span>
                    <span class="s2">and </span><span class="s1">node.name == defframe.name</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">recursive_klass</span>
                    <span class="s2">and </span><span class="s1">utils.is_inside_lambda(node)</span>
                    <span class="s2">and </span><span class="s1">(</span>
                        <span class="s2">not </span><span class="s1">utils.is_default_argument(node)</span>
                        <span class="s2">or </span><span class="s1">node.scope().parent.scope() </span><span class="s2">is not </span><span class="s1">defframe</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s0"># Self-referential class references are fine in lambda's --</span>
                    <span class="s0"># As long as they are not part of the default argument directly</span>
                    <span class="s0"># under the scope of the parent self-referring class.</span>
                    <span class="s0"># Example of valid default argument:</span>
                    <span class="s0"># class MyName3:</span>
                    <span class="s0">#     myattr = 1</span>
                    <span class="s0">#     mylambda3 = lambda: lambda a=MyName3: a</span>
                    <span class="s0"># Example of invalid default argument:</span>
                    <span class="s0"># class MyName4:</span>
                    <span class="s0">#     myattr = 1</span>
                    <span class="s0">#     mylambda4 = lambda a=MyName4: lambda: a</span>

                    <span class="s0"># If the above conditional is True,</span>
                    <span class="s0"># there is no possibility of undefined-variable</span>
                    <span class="s0"># Also do not consume class name</span>
                    <span class="s0"># (since consuming blocks subsequent checks)</span>
                    <span class="s0"># -- quit</span>
                    <span class="s2">break</span>

                <span class="s1">(</span>
                    <span class="s1">maybee0601,</span>
                    <span class="s1">annotation_return,</span>
                    <span class="s1">use_outer_definition,</span>
                <span class="s1">) = self._is_variable_violation(</span>
                    <span class="s1">node,</span>
                    <span class="s1">name,</span>
                    <span class="s1">defnode,</span>
                    <span class="s1">stmt,</span>
                    <span class="s1">defstmt,</span>
                    <span class="s1">frame,</span>
                    <span class="s1">defframe,</span>
                    <span class="s1">base_scope_type,</span>
                    <span class="s1">recursive_klass,</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">use_outer_definition:</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">maybee0601</span>
                    <span class="s2">and not </span><span class="s1">utils.is_defined_before(node)</span>
                    <span class="s2">and not </span><span class="s1">astroid.are_exclusive(stmt, defstmt, (</span><span class="s3">&quot;NameError&quot;</span><span class="s1">,))</span>
                <span class="s1">):</span>

                    <span class="s0"># Used and defined in the same place, e.g `x += 1` and `del x`</span>
                    <span class="s1">defined_by_stmt = defstmt </span><span class="s2">is </span><span class="s1">stmt </span><span class="s2">and </span><span class="s1">isinstance(</span>
                        <span class="s1">node, (astroid.DelName, astroid.AssignName)</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s1">recursive_klass</span>
                        <span class="s2">or </span><span class="s1">defined_by_stmt</span>
                        <span class="s2">or </span><span class="s1">annotation_return</span>
                        <span class="s2">or </span><span class="s1">isinstance(defstmt, astroid.Delete)</span>
                    <span class="s1">):</span>
                        <span class="s2">if not </span><span class="s1">utils.node_ignores_exception(node, NameError):</span>

                            <span class="s0"># Handle postponed evaluation of annotations</span>
                            <span class="s2">if not </span><span class="s1">(</span>
                                <span class="s1">self._postponed_evaluation_enabled</span>
                                <span class="s2">and </span><span class="s1">isinstance(</span>
                                    <span class="s1">stmt,</span>
                                    <span class="s1">(</span>
                                        <span class="s1">astroid.AnnAssign,</span>
                                        <span class="s1">astroid.FunctionDef,</span>
                                        <span class="s1">astroid.Arguments,</span>
                                    <span class="s1">),</span>
                                <span class="s1">)</span>
                                <span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">node.root().locals</span>
                            <span class="s1">):</span>
                                <span class="s1">self.add_message(</span>
                                    <span class="s3">&quot;undefined-variable&quot;</span><span class="s1">, args=name, node=node</span>
                                <span class="s1">)</span>
                    <span class="s2">elif </span><span class="s1">base_scope_type != </span><span class="s3">&quot;lambda&quot;</span><span class="s1">:</span>
                        <span class="s0"># E0601 may *not* occurs in lambda scope.</span>

                        <span class="s0"># Handle postponed evaluation of annotations</span>
                        <span class="s2">if not </span><span class="s1">(</span>
                            <span class="s1">self._postponed_evaluation_enabled</span>
                            <span class="s2">and </span><span class="s1">isinstance(</span>
                                <span class="s1">stmt, (astroid.AnnAssign, astroid.FunctionDef)</span>
                            <span class="s1">)</span>
                        <span class="s1">):</span>
                            <span class="s1">self.add_message(</span>
                                <span class="s3">&quot;used-before-assignment&quot;</span><span class="s1">, args=name, node=node</span>
                            <span class="s1">)</span>
                    <span class="s2">elif </span><span class="s1">base_scope_type == </span><span class="s3">&quot;lambda&quot;</span><span class="s1">:</span>
                        <span class="s0"># E0601 can occur in class-level scope in lambdas, as in</span>
                        <span class="s0"># the following example:</span>
                        <span class="s0">#   class A:</span>
                        <span class="s0">#      x = lambda attr: f + attr</span>
                        <span class="s0">#      f = 42</span>
                        <span class="s2">if </span><span class="s1">isinstance(frame, astroid.ClassDef) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">frame.locals:</span>
                            <span class="s2">if </span><span class="s1">isinstance(node.parent, astroid.Arguments):</span>
                                <span class="s2">if </span><span class="s1">stmt.fromlineno &lt;= defstmt.fromlineno:</span>
                                    <span class="s0"># Doing the following is fine:</span>
                                    <span class="s0">#   class A:</span>
                                    <span class="s0">#      x = 42</span>
                                    <span class="s0">#      y = lambda attr=x: attr</span>
                                    <span class="s1">self.add_message(</span>
                                        <span class="s3">&quot;used-before-assignment&quot;</span><span class="s1">, args=name, node=node</span>
                                    <span class="s1">)</span>
                            <span class="s2">else</span><span class="s1">:</span>
                                <span class="s1">self.add_message(</span>
                                    <span class="s3">&quot;undefined-variable&quot;</span><span class="s1">, args=name, node=node</span>
                                <span class="s1">)</span>
                        <span class="s2">elif </span><span class="s1">current_consumer.scope_type == </span><span class="s3">&quot;lambda&quot;</span><span class="s1">:</span>
                            <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-variable&quot;</span><span class="s1">, node=node, args=name)</span>

            <span class="s1">current_consumer.mark_as_consumed(name, found_node)</span>
            <span class="s0"># check it's not a loop variable used outside the loop</span>
            <span class="s1">self._loopvar_name(node, name)</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># we have not found the name, if it isn't a builtin, that's an</span>
            <span class="s0"># undefined name !</span>
            <span class="s2">if </span><span class="s1">undefined_variable_is_enabled </span><span class="s2">and not </span><span class="s1">(</span>
                <span class="s1">name </span><span class="s2">in </span><span class="s1">astroid.Module.scope_attrs</span>
                <span class="s2">or </span><span class="s1">utils.is_builtin(name)</span>
                <span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.config.additional_builtins</span>
                <span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">name == </span><span class="s3">&quot;__class__&quot;</span>
                    <span class="s2">and </span><span class="s1">isinstance(frame, astroid.FunctionDef)</span>
                    <span class="s2">and </span><span class="s1">frame.is_method()</span>
                <span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s2">if not </span><span class="s1">utils.node_ignores_exception(node, NameError):</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-variable&quot;</span><span class="s1">, args=name, node=node)</span>

    <span class="s1">@utils.check_messages(</span><span class="s3">&quot;no-name-in-module&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">visit_import(self, node):</span>
        <span class="s0">&quot;&quot;&quot;check modules attribute accesses&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._analyse_fallback_blocks </span><span class="s2">and </span><span class="s1">utils.is_from_fallback_block(node):</span>
            <span class="s0"># No need to verify this, since ImportError is already</span>
            <span class="s0"># handled by the client code.</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">name, _ </span><span class="s2">in </span><span class="s1">node.names:</span>
            <span class="s1">parts = name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">module = next(_infer_name_module(node, parts[</span><span class="s4">0</span><span class="s1">]))</span>
            <span class="s2">except </span><span class="s1">astroid.ResolveError:</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">isinstance(module, astroid.Module):</span>
                <span class="s2">continue</span>
            <span class="s1">self._check_module_attrs(node, module, parts[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s1">@utils.check_messages(</span><span class="s3">&quot;no-name-in-module&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">visit_importfrom(self, node):</span>
        <span class="s0">&quot;&quot;&quot;check modules attribute accesses&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._analyse_fallback_blocks </span><span class="s2">and </span><span class="s1">utils.is_from_fallback_block(node):</span>
            <span class="s0"># No need to verify this, since ImportError is already</span>
            <span class="s0"># handled by the client code.</span>
            <span class="s2">return</span>

        <span class="s1">name_parts = node.modname.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">module = node.do_import_module(name_parts[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">astroid.AstroidBuildingException:</span>
            <span class="s2">return</span>
        <span class="s1">module = self._check_module_attrs(node, module, name_parts[</span><span class="s4">1</span><span class="s1">:])</span>
        <span class="s2">if not </span><span class="s1">module:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">name, _ </span><span class="s2">in </span><span class="s1">node.names:</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s1">self._check_module_attrs(node, module, name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">))</span>

    <span class="s1">@utils.check_messages(</span>
        <span class="s3">&quot;unbalanced-tuple-unpacking&quot;</span><span class="s1">, </span><span class="s3">&quot;unpacking-non-sequence&quot;</span><span class="s1">, </span><span class="s3">&quot;self-cls-assignment&quot;</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">visit_assign(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Check unbalanced tuple unpacking for assignments 
        and unpacking non-sequences as well as in case self/cls 
        get assigned. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._check_self_cls_assign(node)</span>
        <span class="s2">if not </span><span class="s1">isinstance(node.targets[</span><span class="s4">0</span><span class="s1">], (astroid.Tuple, astroid.List)):</span>
            <span class="s2">return</span>

        <span class="s1">targets = node.targets[</span><span class="s4">0</span><span class="s1">].itered()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">inferred = utils.safe_infer(node.value)</span>
            <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._check_unpacking(inferred, node, targets)</span>
        <span class="s2">except </span><span class="s1">astroid.InferenceError:</span>
            <span class="s2">return</span>

    <span class="s0"># listcomp have now also their scope</span>
    <span class="s2">def </span><span class="s1">visit_listcomp(self, node):</span>
        <span class="s0">&quot;&quot;&quot;visit dictcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s1">self._to_consume.append(NamesConsumer(node, </span><span class="s3">&quot;comprehension&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">leave_listcomp(self, _):</span>
        <span class="s0">&quot;&quot;&quot;leave dictcomp: update consumption analysis variable&quot;&quot;&quot;</span>
        <span class="s0"># do not check for not used locals here</span>
        <span class="s1">self._to_consume.pop()</span>

    <span class="s2">def </span><span class="s1">leave_assign(self, node):</span>
        <span class="s1">self._store_type_annotation_names(node)</span>

    <span class="s2">def </span><span class="s1">leave_with(self, node):</span>
        <span class="s1">self._store_type_annotation_names(node)</span>

    <span class="s2">def </span><span class="s1">visit_arguments(self, node):</span>
        <span class="s2">for </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">node.type_comment_args:</span>
            <span class="s1">self._store_type_annotation_node(annotation)</span>

    <span class="s0"># Relying on other checker's options, which might not have been initialized yet.</span>
    <span class="s1">@astroid.decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">_analyse_fallback_blocks(self):</span>
        <span class="s2">return </span><span class="s1">get_global_option(self, </span><span class="s3">&quot;analyse-fallback-blocks&quot;</span><span class="s1">, default=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@astroid.decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">_ignored_modules(self):</span>
        <span class="s2">return </span><span class="s1">get_global_option(self, </span><span class="s3">&quot;ignored-modules&quot;</span><span class="s1">, default=[])</span>

    <span class="s1">@astroid.decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">_allow_global_unused_variables(self):</span>
        <span class="s2">return </span><span class="s1">get_global_option(self, </span><span class="s3">&quot;allow-global-unused-variables&quot;</span><span class="s1">, default=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_defined_in_function_definition(node, frame):</span>
        <span class="s1">in_annotation_or_default_or_decorator = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">isinstance(frame, astroid.FunctionDef) </span><span class="s2">and </span><span class="s1">node.statement() </span><span class="s2">is </span><span class="s1">frame:</span>
            <span class="s1">in_annotation_or_default_or_decorator = (</span>
                <span class="s1">(</span>
                    <span class="s1">node </span><span class="s2">in </span><span class="s1">frame.args.annotations</span>
                    <span class="s2">or </span><span class="s1">node </span><span class="s2">in </span><span class="s1">frame.args.posonlyargs_annotations</span>
                    <span class="s2">or </span><span class="s1">node </span><span class="s2">in </span><span class="s1">frame.args.kwonlyargs_annotations</span>
                    <span class="s2">or </span><span class="s1">node </span><span class="s2">is </span><span class="s1">frame.args.varargannotation</span>
                    <span class="s2">or </span><span class="s1">node </span><span class="s2">is </span><span class="s1">frame.args.kwargannotation</span>
                <span class="s1">)</span>
                <span class="s2">or </span><span class="s1">frame.args.parent_of(node)</span>
                <span class="s2">or </span><span class="s1">(frame.decorators </span><span class="s2">and </span><span class="s1">frame.decorators.parent_of(node))</span>
                <span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">frame.returns</span>
                    <span class="s2">and </span><span class="s1">(node </span><span class="s2">is </span><span class="s1">frame.returns </span><span class="s2">or </span><span class="s1">frame.returns.parent_of(node))</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">in_annotation_or_default_or_decorator</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_in_lambda_or_comprehension_body(</span>
        <span class="s1">node: astroid.node_classes.NodeNG, frame: astroid.node_classes.NodeNG</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;return True if node within a lambda/comprehension body (or similar) and thus should not have access to class attributes in frame&quot;&quot;&quot;</span>
        <span class="s1">child = node</span>
        <span class="s1">parent = node.parent</span>
        <span class="s2">while </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">parent </span><span class="s2">is </span><span class="s1">frame:</span>
                <span class="s2">return False</span>
            <span class="s2">if </span><span class="s1">isinstance(parent, astroid.Lambda) </span><span class="s2">and </span><span class="s1">child </span><span class="s2">is not </span><span class="s1">parent.args:</span>
                <span class="s0"># Body of lambda should not have access to class attributes.</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(parent, astroid.node_classes.Comprehension)</span>
                <span class="s2">and </span><span class="s1">child </span><span class="s2">is not </span><span class="s1">parent.iter</span>
            <span class="s1">):</span>
                <span class="s0"># Only iter of list/set/dict/generator comprehension should have access.</span>
                <span class="s2">return True</span>
            <span class="s2">if </span><span class="s1">isinstance(parent, astroid.scoped_nodes.ComprehensionScope) </span><span class="s2">and not </span><span class="s1">(</span>
                <span class="s1">parent.generators </span><span class="s2">and </span><span class="s1">child </span><span class="s2">is </span><span class="s1">parent.generators[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s0"># Body of list/set/dict/generator comprehension should not have access to class attributes.</span>
                <span class="s0"># Furthermore, only the first generator (if multiple) in comprehension should have access.</span>
                <span class="s2">return True</span>
            <span class="s1">child = parent</span>
            <span class="s1">parent = parent.parent</span>
        <span class="s2">return False</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_is_variable_violation(</span>
        <span class="s1">node,</span>
        <span class="s1">name,</span>
        <span class="s1">defnode,</span>
        <span class="s1">stmt,</span>
        <span class="s1">defstmt,</span>
        <span class="s1">frame,</span>
        <span class="s1">defframe,</span>
        <span class="s1">base_scope_type,</span>
        <span class="s1">recursive_klass,</span>
    <span class="s1">):</span>
        <span class="s0"># pylint: disable=too-many-nested-blocks</span>
        <span class="s0"># node: Node to check for violation</span>
        <span class="s0"># name: name of node to check violation for</span>
        <span class="s0"># frame: Scope of statement of node</span>
        <span class="s0"># base_scope_type: local scope type</span>
        <span class="s1">maybee0601 = </span><span class="s2">True</span>
        <span class="s1">annotation_return = </span><span class="s2">False</span>
        <span class="s1">use_outer_definition = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">frame </span><span class="s2">is not </span><span class="s1">defframe:</span>
            <span class="s1">maybee0601 = _detect_global_scope(node, frame, defframe)</span>
        <span class="s2">elif </span><span class="s1">defframe.parent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># we are at the module level, check the name is not</span>
            <span class="s0"># defined in builtins</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">defframe.scope_attrs </span><span class="s2">or </span><span class="s1">astroid.builtin_lookup(name)[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">maybee0601 = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># we are in a local scope, check the name is not</span>
            <span class="s0"># defined in global or builtin scope</span>
            <span class="s0"># skip this lookup if name is assigned later in function scope/lambda</span>
            <span class="s0"># Note: the node.frame() is not the same as the `frame` argument which is</span>
            <span class="s0"># equivalent to frame.statement().scope()</span>
            <span class="s1">forbid_lookup = (</span>
                <span class="s1">isinstance(frame, astroid.FunctionDef)</span>
                <span class="s2">or </span><span class="s1">isinstance(node.frame(), astroid.Lambda)</span>
            <span class="s1">) </span><span class="s2">and </span><span class="s1">_assigned_locally(node)</span>
            <span class="s2">if not </span><span class="s1">forbid_lookup </span><span class="s2">and </span><span class="s1">defframe.root().lookup(name)[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">maybee0601 = </span><span class="s2">False</span>
                <span class="s1">use_outer_definition = stmt == defstmt </span><span class="s2">and not </span><span class="s1">isinstance(</span>
                    <span class="s1">defnode, astroid.node_classes.Comprehension</span>
                <span class="s1">)</span>
            <span class="s0"># check if we have a nonlocal</span>
            <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">defframe.locals:</span>
                <span class="s1">maybee0601 = </span><span class="s2">not </span><span class="s1">any(</span>
                    <span class="s1">isinstance(child, astroid.Nonlocal) </span><span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">child.names</span>
                    <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">defframe.get_children()</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">base_scope_type == </span><span class="s3">&quot;lambda&quot;</span>
            <span class="s2">and </span><span class="s1">isinstance(frame, astroid.ClassDef)</span>
            <span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">frame.locals</span>
        <span class="s1">):</span>

            <span class="s0"># This rule verifies that if the definition node of the</span>
            <span class="s0"># checked name is an Arguments node and if the name</span>
            <span class="s0"># is used a default value in the arguments defaults</span>
            <span class="s0"># and the actual definition of the variable label</span>
            <span class="s0"># is happening before the Arguments definition.</span>
            <span class="s0">#</span>
            <span class="s0"># bar = None</span>
            <span class="s0"># foo = lambda bar=bar: bar</span>
            <span class="s0">#</span>
            <span class="s0"># In this case, maybee0601 should be False, otherwise</span>
            <span class="s0"># it should be True.</span>
            <span class="s1">maybee0601 = </span><span class="s2">not </span><span class="s1">(</span>
                <span class="s1">isinstance(defnode, astroid.Arguments)</span>
                <span class="s2">and </span><span class="s1">node </span><span class="s2">in </span><span class="s1">defnode.defaults</span>
                <span class="s2">and </span><span class="s1">frame.locals[name][</span><span class="s4">0</span><span class="s1">].fromlineno &lt; defstmt.fromlineno</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(defframe, astroid.ClassDef) </span><span class="s2">and </span><span class="s1">isinstance(</span>
            <span class="s1">frame, astroid.FunctionDef</span>
        <span class="s1">):</span>
            <span class="s0"># Special rule for function return annotations,</span>
            <span class="s0"># which uses the same name as the class where</span>
            <span class="s0"># the function lives.</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s2">is </span><span class="s1">frame.returns </span><span class="s2">and </span><span class="s1">defframe.parent_of(frame.returns):</span>
                <span class="s1">maybee0601 = annotation_return = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">maybee0601</span>
                <span class="s2">and </span><span class="s1">defframe.name </span><span class="s2">in </span><span class="s1">defframe.locals</span>
                <span class="s2">and </span><span class="s1">defframe.locals[name][</span><span class="s4">0</span><span class="s1">].lineno &lt; frame.lineno</span>
            <span class="s1">):</span>
                <span class="s0"># Detect class assignments with the same</span>
                <span class="s0"># name as the class. In this case, no warning</span>
                <span class="s0"># should be raised.</span>
                <span class="s1">maybee0601 = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">isinstance(node.parent, astroid.Arguments):</span>
                <span class="s1">maybee0601 = stmt.fromlineno &lt;= defstmt.fromlineno</span>
        <span class="s2">elif </span><span class="s1">recursive_klass:</span>
            <span class="s1">maybee0601 = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">maybee0601 = maybee0601 </span><span class="s2">and </span><span class="s1">stmt.fromlineno &lt;= defstmt.fromlineno</span>
            <span class="s2">if </span><span class="s1">maybee0601 </span><span class="s2">and </span><span class="s1">stmt.fromlineno == defstmt.fromlineno:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(defframe, astroid.FunctionDef)</span>
                    <span class="s2">and </span><span class="s1">frame </span><span class="s2">is </span><span class="s1">defframe</span>
                    <span class="s2">and </span><span class="s1">defframe.parent_of(node)</span>
                    <span class="s2">and </span><span class="s1">stmt </span><span class="s2">is not </span><span class="s1">defstmt</span>
                <span class="s1">):</span>
                    <span class="s0"># Single statement function, with the statement on the</span>
                    <span class="s0"># same line as the function definition</span>
                    <span class="s1">maybee0601 = </span><span class="s2">False</span>
                <span class="s2">elif </span><span class="s1">(</span>
                    <span class="s1">isinstance(</span>
                        <span class="s1">defstmt,</span>
                        <span class="s1">(</span>
                            <span class="s1">astroid.Assign,</span>
                            <span class="s1">astroid.AnnAssign,</span>
                            <span class="s1">astroid.AugAssign,</span>
                            <span class="s1">astroid.Expr,</span>
                        <span class="s1">),</span>
                    <span class="s1">)</span>
                    <span class="s2">and </span><span class="s1">isinstance(defstmt.value, astroid.IfExp)</span>
                    <span class="s2">and </span><span class="s1">frame </span><span class="s2">is </span><span class="s1">defframe</span>
                    <span class="s2">and </span><span class="s1">defframe.parent_of(node)</span>
                    <span class="s2">and </span><span class="s1">stmt </span><span class="s2">is </span><span class="s1">defstmt</span>
                <span class="s1">):</span>
                    <span class="s0"># Single statement if, with assingment expression on same</span>
                    <span class="s0"># line as assigment</span>
                    <span class="s0"># x = b if (b := True) else False</span>
                    <span class="s1">maybee0601 = </span><span class="s2">False</span>
                <span class="s2">elif </span><span class="s1">(</span>
                    <span class="s1">isinstance(  </span><span class="s0"># pylint: disable=too-many-boolean-expressions</span>
                        <span class="s1">defnode, astroid.NamedExpr</span>
                    <span class="s1">)</span>
                    <span class="s2">and </span><span class="s1">frame </span><span class="s2">is </span><span class="s1">defframe</span>
                    <span class="s2">and </span><span class="s1">defframe.parent_of(stmt)</span>
                    <span class="s2">and </span><span class="s1">stmt </span><span class="s2">is </span><span class="s1">defstmt</span>
                    <span class="s2">and </span><span class="s1">(</span>
                        <span class="s1">(</span>
                            <span class="s1">defnode.lineno == node.lineno</span>
                            <span class="s2">and </span><span class="s1">defnode.col_offset &lt; node.col_offset</span>
                        <span class="s1">)</span>
                        <span class="s2">or </span><span class="s1">(defnode.lineno &lt; node.lineno)</span>
                        <span class="s2">or </span><span class="s1">(</span>
                            <span class="s0"># Issue in the `ast` module until py39</span>
                            <span class="s0"># Nodes in a multiline string have the same lineno</span>
                            <span class="s0"># Could be false-positive without check</span>
                            <span class="s2">not </span><span class="s1">PY39_PLUS</span>
                            <span class="s2">and </span><span class="s1">defnode.lineno == node.lineno</span>
                            <span class="s2">and </span><span class="s1">isinstance(</span>
                                <span class="s1">defstmt,</span>
                                <span class="s1">(</span>
                                    <span class="s1">astroid.Assign,</span>
                                    <span class="s1">astroid.AnnAssign,</span>
                                    <span class="s1">astroid.AugAssign,</span>
                                    <span class="s1">astroid.Return,</span>
                                <span class="s1">),</span>
                            <span class="s1">)</span>
                            <span class="s2">and </span><span class="s1">isinstance(defstmt.value, astroid.JoinedStr)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">):</span>
                    <span class="s0"># Expressions, with assignment expressions</span>
                    <span class="s0"># Use only after assignment</span>
                    <span class="s0"># b = (c := 2) and c</span>
                    <span class="s1">maybee0601 = </span><span class="s2">False</span>

            <span class="s0"># Look for type checking definitions inside a type checking guard.</span>
            <span class="s2">if </span><span class="s1">isinstance(defstmt, (astroid.Import, astroid.ImportFrom)):</span>
                <span class="s1">defstmt_parent = defstmt.parent</span>

                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">isinstance(defstmt_parent, astroid.If)</span>
                    <span class="s2">and </span><span class="s1">defstmt_parent.test.as_string() </span><span class="s2">in </span><span class="s1">TYPING_TYPE_CHECKS_GUARDS</span>
                <span class="s1">):</span>
                    <span class="s0"># Exempt those definitions that are used inside the type checking</span>
                    <span class="s0"># guard or that are defined in both type checking guard branches.</span>
                    <span class="s1">used_in_branch = defstmt_parent.parent_of(node)</span>
                    <span class="s1">defined_in_or_else = </span><span class="s2">False</span>

                    <span class="s2">for </span><span class="s1">definition </span><span class="s2">in </span><span class="s1">defstmt_parent.orelse:</span>
                        <span class="s2">if </span><span class="s1">isinstance(definition, astroid.Assign):</span>
                            <span class="s1">defined_in_or_else = any(</span>
                                <span class="s1">target.name == name </span><span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">definition.targets</span>
                            <span class="s1">)</span>
                            <span class="s2">if </span><span class="s1">defined_in_or_else:</span>
                                <span class="s2">break</span>

                    <span class="s2">if not </span><span class="s1">used_in_branch </span><span class="s2">and not </span><span class="s1">defined_in_or_else:</span>
                        <span class="s1">maybee0601 = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">maybee0601, annotation_return, use_outer_definition</span>

    <span class="s2">def </span><span class="s1">_ignore_class_scope(self, node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the node is in a local class scope, as an assignment. 
 
        :param node: Node considered 
        :type node: astroid.Node 
        :return: True if the node is in a local class scope, as an assignment. False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s0"># Detect if we are in a local class scope, as an assignment.</span>
        <span class="s0"># For example, the following is fair game.</span>
        <span class="s0">#</span>
        <span class="s0"># class A:</span>
        <span class="s0">#    b = 1</span>
        <span class="s0">#    c = lambda b=b: b * b</span>
        <span class="s0">#</span>
        <span class="s0"># class B:</span>
        <span class="s0">#    tp = 1</span>
        <span class="s0">#    def func(self, arg: tp):</span>
        <span class="s0">#        ...</span>
        <span class="s0"># class C:</span>
        <span class="s0">#    tp = 2</span>
        <span class="s0">#    def func(self, arg=tp):</span>
        <span class="s0">#        ...</span>
        <span class="s0"># class C:</span>
        <span class="s0">#    class Tp:</span>
        <span class="s0">#        pass</span>
        <span class="s0">#    class D(Tp):</span>
        <span class="s0">#        ...</span>

        <span class="s1">name = node.name</span>
        <span class="s1">frame = node.statement().scope()</span>
        <span class="s1">in_annotation_or_default_or_decorator = self._defined_in_function_definition(</span>
            <span class="s1">node, frame</span>
        <span class="s1">)</span>
        <span class="s1">in_ancestor_list = utils.is_ancestor_name(frame, node)</span>
        <span class="s2">if </span><span class="s1">in_annotation_or_default_or_decorator </span><span class="s2">or </span><span class="s1">in_ancestor_list:</span>
            <span class="s1">frame_locals = frame.parent.scope().locals</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">frame_locals = frame.locals</span>
        <span class="s2">return not </span><span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">isinstance(frame, astroid.ClassDef)</span>
                <span class="s2">or </span><span class="s1">in_annotation_or_default_or_decorator</span>
            <span class="s1">)</span>
            <span class="s2">and not </span><span class="s1">self._in_lambda_or_comprehension_body(node, frame)</span>
            <span class="s2">and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">frame_locals</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_loopvar_name(self, node, name):</span>
        <span class="s0"># filter variables according to node's scope</span>
        <span class="s2">if not </span><span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">astmts = [stmt </span><span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">node.lookup(name)[</span><span class="s4">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">hasattr(stmt, </span><span class="s3">&quot;assign_type&quot;</span><span class="s1">)]</span>
        <span class="s0"># If this variable usage exists inside a function definition</span>
        <span class="s0"># that exists in the same loop,</span>
        <span class="s0"># the usage is safe because the function will not be defined either if</span>
        <span class="s0"># the variable is not defined.</span>
        <span class="s1">scope = node.scope()</span>
        <span class="s2">if </span><span class="s1">isinstance(scope, astroid.FunctionDef) </span><span class="s2">and </span><span class="s1">any(</span>
            <span class="s1">asmt.statement().parent_of(scope) </span><span class="s2">for </span><span class="s1">asmt </span><span class="s2">in </span><span class="s1">astmts</span>
        <span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s0"># filter variables according their respective scope test is_statement</span>
        <span class="s0"># and parent to avoid #74747. This is not a total fix, which would</span>
        <span class="s0"># introduce a mechanism similar to special attribute lookup in</span>
        <span class="s0"># modules. Also, in order to get correct inference in this case, the</span>
        <span class="s0"># scope lookup rules would need to be changed to return the initial</span>
        <span class="s0"># assignment (which does not exist in code per se) as well as any later</span>
        <span class="s0"># modifications.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">astmts</span>
            <span class="s2">or </span><span class="s1">(astmts[</span><span class="s4">0</span><span class="s1">].is_statement </span><span class="s2">or </span><span class="s1">astmts[</span><span class="s4">0</span><span class="s1">].parent)</span>
            <span class="s2">and </span><span class="s1">astmts[</span><span class="s4">0</span><span class="s1">].statement().parent_of(node)</span>
        <span class="s1">):</span>
            <span class="s1">_astmts = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_astmts = astmts[:</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">i, stmt </span><span class="s2">in </span><span class="s1">enumerate(astmts[</span><span class="s4">1</span><span class="s1">:]):</span>
            <span class="s2">if </span><span class="s1">astmts[i].statement().parent_of(stmt) </span><span class="s2">and not </span><span class="s1">in_for_else_branch(</span>
                <span class="s1">astmts[i].statement(), stmt</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s1">_astmts.append(stmt)</span>
        <span class="s1">astmts = _astmts</span>
        <span class="s2">if </span><span class="s1">len(astmts) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">assign = astmts[</span><span class="s4">0</span><span class="s1">].assign_type()</span>
        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">isinstance(</span>
                <span class="s1">assign, (astroid.For, astroid.Comprehension, astroid.GeneratorExp)</span>
            <span class="s1">)</span>
            <span class="s2">and </span><span class="s1">assign.statement() </span><span class="s2">is not </span><span class="s1">node.statement()</span>
        <span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s0"># For functions we can do more by inferring the length of the itered object</span>
        <span class="s2">if not </span><span class="s1">isinstance(assign, astroid.For):</span>
            <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">, args=name, node=node)</span>
            <span class="s2">return</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">inferred = next(assign.iter.infer())</span>
        <span class="s2">except </span><span class="s1">astroid.InferenceError:</span>
            <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">, args=name, node=node)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(inferred, astroid.Instance)</span>
                <span class="s2">and </span><span class="s1">inferred.qname() == BUILTIN_RANGE</span>
            <span class="s1">):</span>
                <span class="s0"># Consider range() objects safe, even if they might not yield any results.</span>
                <span class="s2">return</span>

            <span class="s0"># Consider sequences.</span>
            <span class="s1">sequences = (</span>
                <span class="s1">astroid.List,</span>
                <span class="s1">astroid.Tuple,</span>
                <span class="s1">astroid.Dict,</span>
                <span class="s1">astroid.Set,</span>
                <span class="s1">astroid.objects.FrozenSet,</span>
            <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">isinstance(inferred, sequences):</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">, args=name, node=node)</span>
                <span class="s2">return</span>

            <span class="s1">elements = getattr(inferred, </span><span class="s3">&quot;elts&quot;</span><span class="s1">, getattr(inferred, </span><span class="s3">&quot;items&quot;</span><span class="s1">, []))</span>
            <span class="s2">if not </span><span class="s1">elements:</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-loop-variable&quot;</span><span class="s1">, args=name, node=node)</span>

    <span class="s2">def </span><span class="s1">_check_is_unused(self, name, node, stmt, global_names, nonlocal_names):</span>
        <span class="s0"># pylint: disable=too-many-branches</span>
        <span class="s0"># Ignore some special names specified by user configuration.</span>
        <span class="s2">if </span><span class="s1">self._is_name_ignored(stmt, name):</span>
            <span class="s2">return</span>
        <span class="s0"># Ignore names that were added dynamically to the Function scope</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(node, astroid.FunctionDef)</span>
            <span class="s2">and </span><span class="s1">name == </span><span class="s3">&quot;__class__&quot;</span>
            <span class="s2">and </span><span class="s1">len(node.locals[</span><span class="s3">&quot;__class__&quot;</span><span class="s1">]) == </span><span class="s4">1</span>
            <span class="s2">and </span><span class="s1">isinstance(node.locals[</span><span class="s3">&quot;__class__&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">], astroid.ClassDef)</span>
        <span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s0"># Ignore names imported by the global statement.</span>
        <span class="s2">if </span><span class="s1">isinstance(stmt, (astroid.Global, astroid.Import, astroid.ImportFrom)):</span>
            <span class="s0"># Detect imports, assigned to global statements.</span>
            <span class="s2">if </span><span class="s1">global_names </span><span class="s2">and </span><span class="s1">_import_name_is_global(stmt, global_names):</span>
                <span class="s2">return</span>

        <span class="s1">argnames = list(</span>
            <span class="s1">itertools.chain(node.argnames(), [arg.name </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">node.args.kwonlyargs])</span>
        <span class="s1">)</span>
        <span class="s0"># Care about functions with unknown argument (builtins)</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">argnames:</span>
            <span class="s1">self._check_unused_arguments(name, node, stmt, argnames)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">stmt.parent </span><span class="s2">and </span><span class="s1">isinstance(</span>
                <span class="s1">stmt.parent, (astroid.Assign, astroid.AnnAssign)</span>
            <span class="s1">):</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">nonlocal_names:</span>
                    <span class="s2">return</span>

            <span class="s1">qname = asname = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">isinstance(stmt, (astroid.Import, astroid.ImportFrom)):</span>
                <span class="s0"># Need the complete name, which we don't have in .locals.</span>
                <span class="s2">if </span><span class="s1">len(stmt.names) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">import_names = next(</span>
                        <span class="s1">(names </span><span class="s2">for </span><span class="s1">names </span><span class="s2">in </span><span class="s1">stmt.names </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names), </span><span class="s2">None</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">import_names = stmt.names[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">import_names:</span>
                    <span class="s1">qname, asname = import_names</span>
                    <span class="s1">name = asname </span><span class="s2">or </span><span class="s1">qname</span>

            <span class="s2">if </span><span class="s1">_has_locals_call_after_node(stmt, node.scope()):</span>
                <span class="s1">message_name = </span><span class="s3">&quot;possibly-unused-variable&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(stmt, astroid.Import):</span>
                    <span class="s2">if </span><span class="s1">asname </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">qname</span><span class="s5">} </span><span class="s3">imported as </span><span class="s5">{</span><span class="s1">asname</span><span class="s5">}</span><span class="s3">&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">&quot;import %s&quot; </span><span class="s1">% name</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;unused-import&quot;</span><span class="s1">, args=msg, node=stmt)</span>
                    <span class="s2">return</span>
                <span class="s2">if </span><span class="s1">isinstance(stmt, astroid.ImportFrom):</span>
                    <span class="s2">if </span><span class="s1">asname </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">qname</span><span class="s5">} </span><span class="s3">imported from </span><span class="s5">{</span><span class="s1">stmt.modname</span><span class="s5">} </span><span class="s3">as </span><span class="s5">{</span><span class="s1">asname</span><span class="s5">}</span><span class="s3">&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">name</span><span class="s5">} </span><span class="s3">imported from </span><span class="s5">{</span><span class="s1">stmt.modname</span><span class="s5">}</span><span class="s3">&quot;</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;unused-import&quot;</span><span class="s1">, args=msg, node=stmt)</span>
                    <span class="s2">return</span>
                <span class="s1">message_name = </span><span class="s3">&quot;unused-variable&quot;</span>

            <span class="s2">if </span><span class="s1">isinstance(stmt, astroid.FunctionDef) </span><span class="s2">and </span><span class="s1">stmt.decorators:</span>
                <span class="s2">return</span>

            <span class="s0"># Don't check function stubs created only for type information</span>
            <span class="s2">if </span><span class="s1">utils.is_overload_stub(node):</span>
                <span class="s2">return</span>

            <span class="s1">self.add_message(message_name, args=name, node=stmt)</span>

    <span class="s2">def </span><span class="s1">_is_name_ignored(self, stmt, name):</span>
        <span class="s1">authorized_rgx = self.config.dummy_variables_rgx</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(stmt, astroid.AssignName)</span>
            <span class="s2">and </span><span class="s1">isinstance(stmt.parent, astroid.Arguments)</span>
            <span class="s2">or </span><span class="s1">isinstance(stmt, astroid.Arguments)</span>
        <span class="s1">):</span>
            <span class="s1">regex = self.config.ignored_argument_names</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">regex = authorized_rgx</span>
        <span class="s2">return </span><span class="s1">regex </span><span class="s2">and </span><span class="s1">regex.match(name)</span>

    <span class="s2">def </span><span class="s1">_check_unused_arguments(self, name, node, stmt, argnames):</span>
        <span class="s1">is_method = node.is_method()</span>
        <span class="s1">klass = node.parent.frame()</span>
        <span class="s2">if </span><span class="s1">is_method </span><span class="s2">and </span><span class="s1">isinstance(klass, astroid.ClassDef):</span>
            <span class="s1">confidence = (</span>
                <span class="s1">INFERENCE </span><span class="s2">if </span><span class="s1">utils.has_known_bases(klass) </span><span class="s2">else </span><span class="s1">INFERENCE_FAILURE</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">confidence = HIGH</span>

        <span class="s2">if </span><span class="s1">is_method:</span>
            <span class="s0"># Don't warn for the first argument of a (non static) method</span>
            <span class="s2">if </span><span class="s1">node.type != </span><span class="s3">&quot;staticmethod&quot; </span><span class="s2">and </span><span class="s1">name == argnames[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s2">return</span>
            <span class="s0"># Don't warn for argument of an overridden method</span>
            <span class="s1">overridden = overridden_method(klass, node.name)</span>
            <span class="s2">if </span><span class="s1">overridden </span><span class="s2">is not None and </span><span class="s1">name </span><span class="s2">in </span><span class="s1">overridden.argnames():</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">node.name </span><span class="s2">in </span><span class="s1">utils.PYMETHODS </span><span class="s2">and </span><span class="s1">node.name </span><span class="s2">not in </span><span class="s1">(</span>
                <span class="s3">&quot;__init__&quot;</span><span class="s1">,</span>
                <span class="s3">&quot;__new__&quot;</span><span class="s1">,</span>
            <span class="s1">):</span>
                <span class="s2">return</span>
        <span class="s0"># Don't check callback arguments</span>
        <span class="s2">if </span><span class="s1">any(</span>
            <span class="s1">node.name.startswith(cb) </span><span class="s2">or </span><span class="s1">node.name.endswith(cb)</span>
            <span class="s2">for </span><span class="s1">cb </span><span class="s2">in </span><span class="s1">self.config.callbacks</span>
        <span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s0"># Don't check arguments of singledispatch.register function.</span>
        <span class="s2">if </span><span class="s1">utils.is_registered_in_singledispatch_function(node):</span>
            <span class="s2">return</span>

        <span class="s0"># Don't check function stubs created only for type information</span>
        <span class="s2">if </span><span class="s1">utils.is_overload_stub(node):</span>
            <span class="s2">return</span>

        <span class="s0"># Don't check protocol classes</span>
        <span class="s2">if </span><span class="s1">utils.is_protocol_class(klass):</span>
            <span class="s2">return</span>

        <span class="s1">self.add_message(</span><span class="s3">&quot;unused-argument&quot;</span><span class="s1">, args=name, node=stmt, confidence=confidence)</span>

    <span class="s2">def </span><span class="s1">_check_late_binding_closure(self, node, assignment_node):</span>
        <span class="s2">if not </span><span class="s1">self.linter.is_message_enabled(</span><span class="s3">&quot;cell-var-from-loop&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>

        <span class="s2">def </span><span class="s1">_is_direct_lambda_call():</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">isinstance(node_scope.parent, astroid.Call)</span>
                <span class="s2">and </span><span class="s1">node_scope.parent.func </span><span class="s2">is </span><span class="s1">node_scope</span>
            <span class="s1">)</span>

        <span class="s1">node_scope = node.scope()</span>
        <span class="s2">if not </span><span class="s1">isinstance(node_scope, (astroid.Lambda, astroid.FunctionDef)):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">isinstance(node.parent, astroid.Arguments):</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">isinstance(assignment_node, astroid.Comprehension):</span>
            <span class="s2">if </span><span class="s1">assignment_node.parent.parent_of(node.scope()):</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;cell-var-from-loop&quot;</span><span class="s1">, node=node, args=node.name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assign_scope = assignment_node.scope()</span>
            <span class="s1">maybe_for = assignment_node</span>
            <span class="s2">while </span><span class="s1">maybe_for </span><span class="s2">and not </span><span class="s1">isinstance(maybe_for, astroid.For):</span>
                <span class="s2">if </span><span class="s1">maybe_for </span><span class="s2">is </span><span class="s1">assign_scope:</span>
                    <span class="s2">break</span>
                <span class="s1">maybe_for = maybe_for.parent</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">maybe_for</span>
                    <span class="s2">and </span><span class="s1">maybe_for.parent_of(node_scope)</span>
                    <span class="s2">and not </span><span class="s1">_is_direct_lambda_call()</span>
                    <span class="s2">and not </span><span class="s1">isinstance(node_scope.statement(), astroid.Return)</span>
                <span class="s1">):</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;cell-var-from-loop&quot;</span><span class="s1">, node=node, args=node.name)</span>

    <span class="s2">def </span><span class="s1">_should_ignore_redefined_builtin(self, stmt):</span>
        <span class="s2">if not </span><span class="s1">isinstance(stmt, astroid.ImportFrom):</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">stmt.modname </span><span class="s2">in </span><span class="s1">self.config.redefining_builtins_modules</span>

    <span class="s2">def </span><span class="s1">_allowed_redefined_builtin(self, name):</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.config.allowed_redefined_builtins</span>

    <span class="s2">def </span><span class="s1">_has_homonym_in_upper_function_scope(self, node, index):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if there is a node with the same name in the to_consume dict of an upper scope 
        and if that scope is a function 
 
        :param node: node to check for 
        :type node: astroid.Node 
        :param index: index of the current consumer inside self._to_consume 
        :type index: int 
        :return: True if there is a node with the same name in the to_consume dict of an upper scope 
                 and if that scope is a function 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">_consumer </span><span class="s2">in </span><span class="s1">self._to_consume[index - </span><span class="s4">1 </span><span class="s1">:: -</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">_consumer.scope_type == </span><span class="s3">&quot;function&quot; </span><span class="s2">and </span><span class="s1">node.name </span><span class="s2">in </span><span class="s1">_consumer.to_consume:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_store_type_annotation_node(self, type_annotation):</span>
        <span class="s0">&quot;&quot;&quot;Given a type annotation, store all the name nodes it refers to&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(type_annotation, astroid.Name):</span>
            <span class="s1">self._type_annotation_names.append(type_annotation.name)</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">isinstance(type_annotation, astroid.Subscript):</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(type_annotation.value, astroid.Attribute)</span>
            <span class="s2">and </span><span class="s1">isinstance(type_annotation.value.expr, astroid.Name)</span>
            <span class="s2">and </span><span class="s1">type_annotation.value.expr.name == TYPING_MODULE</span>
        <span class="s1">):</span>
            <span class="s1">self._type_annotation_names.append(TYPING_MODULE)</span>
            <span class="s2">return</span>

        <span class="s1">self._type_annotation_names.extend(</span>
            <span class="s1">annotation.name</span>
            <span class="s2">for </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">type_annotation.nodes_of_class(astroid.Name)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_store_type_annotation_names(self, node):</span>
        <span class="s1">type_annotation = node.type_annotation</span>
        <span class="s2">if not </span><span class="s1">type_annotation:</span>
            <span class="s2">return</span>
        <span class="s1">self._store_type_annotation_node(node.type_annotation)</span>

    <span class="s2">def </span><span class="s1">_check_self_cls_assign(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Check that self/cls don't get assigned&quot;&quot;&quot;</span>
        <span class="s1">assign_names = {</span>
            <span class="s1">target.name</span>
            <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">node.targets</span>
            <span class="s2">if </span><span class="s1">isinstance(target, astroid.AssignName)</span>
        <span class="s1">}</span>
        <span class="s1">scope = node.scope()</span>
        <span class="s1">nonlocals_with_same_name = any(</span>
            <span class="s1">child</span>
            <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">scope.body</span>
            <span class="s2">if </span><span class="s1">isinstance(child, astroid.Nonlocal) </span><span class="s2">and </span><span class="s1">assign_names &amp; set(child.names)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">nonlocals_with_same_name:</span>
            <span class="s1">scope = node.scope().parent.scope()</span>

        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">isinstance(scope, astroid.scoped_nodes.FunctionDef)</span>
            <span class="s2">and </span><span class="s1">scope.is_method()</span>
            <span class="s2">and </span><span class="s3">&quot;builtins.staticmethod&quot; </span><span class="s2">not in </span><span class="s1">scope.decoratornames()</span>
        <span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">argument_names = scope.argnames()</span>
        <span class="s2">if not </span><span class="s1">argument_names:</span>
            <span class="s2">return</span>
        <span class="s1">self_cls_name = argument_names[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">target_assign_names = (</span>
            <span class="s1">target.name</span>
            <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">node.targets</span>
            <span class="s2">if </span><span class="s1">isinstance(target, astroid.node_classes.AssignName)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self_cls_name </span><span class="s2">in </span><span class="s1">target_assign_names:</span>
            <span class="s1">self.add_message(</span><span class="s3">&quot;self-cls-assignment&quot;</span><span class="s1">, node=node, args=(self_cls_name,))</span>

    <span class="s2">def </span><span class="s1">_check_unpacking(self, inferred, node, targets):</span>
        <span class="s0">&quot;&quot;&quot;Check for unbalanced tuple unpacking 
        and unpacking non sequences. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">utils.is_inside_abstract_class(node):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">utils.is_comprehension(node):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is </span><span class="s1">astroid.Uninferable:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(inferred.parent, astroid.Arguments)</span>
            <span class="s2">and </span><span class="s1">isinstance(node.value, astroid.Name)</span>
            <span class="s2">and </span><span class="s1">node.value.name == inferred.parent.vararg</span>
        <span class="s1">):</span>
            <span class="s0"># Variable-length argument, we can't determine the length.</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">isinstance(inferred, (astroid.Tuple, astroid.List)):</span>
            <span class="s0"># attempt to check unpacking is properly balanced</span>
            <span class="s1">values = inferred.itered()</span>
            <span class="s2">if </span><span class="s1">len(targets) != len(values):</span>
                <span class="s0"># Check if we have starred nodes.</span>
                <span class="s2">if </span><span class="s1">any(isinstance(target, astroid.Starred) </span><span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">targets):</span>
                    <span class="s2">return</span>
                <span class="s1">self.add_message(</span>
                    <span class="s3">&quot;unbalanced-tuple-unpacking&quot;</span><span class="s1">,</span>
                    <span class="s1">node=node,</span>
                    <span class="s1">args=(</span>
                        <span class="s1">_get_unpacking_extra_info(node, inferred),</span>
                        <span class="s1">len(targets),</span>
                        <span class="s1">len(values),</span>
                    <span class="s1">),</span>
                <span class="s1">)</span>
        <span class="s0"># attempt to check unpacking may be possible (ie RHS is iterable)</span>
        <span class="s2">elif not </span><span class="s1">utils.is_iterable(inferred):</span>
            <span class="s1">self.add_message(</span>
                <span class="s3">&quot;unpacking-non-sequence&quot;</span><span class="s1">,</span>
                <span class="s1">node=node,</span>
                <span class="s1">args=(_get_unpacking_extra_info(node, inferred),),</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_module_attrs(self, node, module, module_names):</span>
        <span class="s0">&quot;&quot;&quot;check that module_names (list of string) are accessible through the 
        given module 
        if the latest access name corresponds to a module, return it 
        &quot;&quot;&quot;</span>
        <span class="s2">while </span><span class="s1">module_names:</span>
            <span class="s1">name = module_names.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;__dict__&quot;</span><span class="s1">:</span>
                <span class="s1">module = </span><span class="s2">None</span>
                <span class="s2">break</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">module = next(module.getattr(name)[</span><span class="s4">0</span><span class="s1">].infer())</span>
                <span class="s2">if </span><span class="s1">module </span><span class="s2">is </span><span class="s1">astroid.Uninferable:</span>
                    <span class="s2">return None</span>
            <span class="s2">except </span><span class="s1">astroid.NotFoundError:</span>
                <span class="s2">if </span><span class="s1">module.name </span><span class="s2">in </span><span class="s1">self._ignored_modules:</span>
                    <span class="s2">return None</span>
                <span class="s1">self.add_message(</span>
                    <span class="s3">&quot;no-name-in-module&quot;</span><span class="s1">, args=(name, module.name), node=node</span>
                <span class="s1">)</span>
                <span class="s2">return None</span>
            <span class="s2">except </span><span class="s1">astroid.InferenceError:</span>
                <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">module_names:</span>
            <span class="s1">modname = module.name </span><span class="s2">if </span><span class="s1">module </span><span class="s2">else </span><span class="s3">&quot;__dict__&quot;</span>
            <span class="s1">self.add_message(</span>
                <span class="s3">&quot;no-name-in-module&quot;</span><span class="s1">, node=node, args=(</span><span class="s3">&quot;.&quot;</span><span class="s1">.join(module_names), modname)</span>
            <span class="s1">)</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">isinstance(module, astroid.Module):</span>
            <span class="s2">return </span><span class="s1">module</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_check_all(self, node, not_consumed):</span>
        <span class="s1">assigned = next(node.igetattr(</span><span class="s3">&quot;__all__&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">assigned </span><span class="s2">is </span><span class="s1">astroid.Uninferable:</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">getattr(assigned, </span><span class="s3">&quot;elts&quot;</span><span class="s1">, ()):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">elt_name = next(elt.infer())</span>
            <span class="s2">except </span><span class="s1">astroid.InferenceError:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">elt_name </span><span class="s2">is </span><span class="s1">astroid.Uninferable:</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">elt_name.parent:</span>
                <span class="s2">continue</span>

            <span class="s2">if not </span><span class="s1">isinstance(elt_name, astroid.Const) </span><span class="s2">or not </span><span class="s1">isinstance(</span>
                <span class="s1">elt_name.value, str</span>
            <span class="s1">):</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;invalid-all-object&quot;</span><span class="s1">, args=elt.as_string(), node=elt)</span>
                <span class="s2">continue</span>

            <span class="s1">elt_name = elt_name.value</span>
            <span class="s0"># If elt is in not_consumed, remove it from not_consumed</span>
            <span class="s2">if </span><span class="s1">elt_name </span><span class="s2">in </span><span class="s1">not_consumed:</span>
                <span class="s2">del </span><span class="s1">not_consumed[elt_name]</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">elt_name </span><span class="s2">not in </span><span class="s1">node.locals:</span>
                <span class="s2">if not </span><span class="s1">node.package:</span>
                    <span class="s1">self.add_message(</span>
                        <span class="s3">&quot;undefined-all-variable&quot;</span><span class="s1">, args=(elt_name,), node=elt</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">basename = os.path.splitext(node.file)[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">os.path.basename(basename) == </span><span class="s3">&quot;__init__&quot;</span><span class="s1">:</span>
                        <span class="s1">name = node.name + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ elt_name</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">astroid.modutils.file_from_modpath(name.split(</span><span class="s3">&quot;.&quot;</span><span class="s1">))</span>
                        <span class="s2">except </span><span class="s1">ImportError:</span>
                            <span class="s1">self.add_message(</span>
                                <span class="s3">&quot;undefined-all-variable&quot;</span><span class="s1">, args=(elt_name,), node=elt</span>
                            <span class="s1">)</span>
                        <span class="s2">except </span><span class="s1">SyntaxError:</span>
                            <span class="s0"># don't yield a syntax-error warning,</span>
                            <span class="s0"># because it will be later yielded</span>
                            <span class="s0"># when the file will be checked</span>
                            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_check_globals(self, not_consumed):</span>
        <span class="s2">if </span><span class="s1">self._allow_global_unused_variables:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">name, nodes </span><span class="s2">in </span><span class="s1">not_consumed.items():</span>
            <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes:</span>
                <span class="s1">self.add_message(</span><span class="s3">&quot;unused-variable&quot;</span><span class="s1">, args=(name,), node=node)</span>

    <span class="s2">def </span><span class="s1">_check_imports(self, not_consumed):</span>
        <span class="s1">local_names = _fix_dot_imports(not_consumed)</span>
        <span class="s1">checked = set()</span>
        <span class="s2">for </span><span class="s1">name, stmt </span><span class="s2">in </span><span class="s1">local_names:</span>
            <span class="s2">for </span><span class="s1">imports </span><span class="s2">in </span><span class="s1">stmt.names:</span>
                <span class="s1">real_name = imported_name = imports[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">imported_name == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
                    <span class="s1">real_name = name</span>
                <span class="s1">as_name = imports[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">real_name </span><span class="s2">in </span><span class="s1">checked:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">(real_name, as_name):</span>
                    <span class="s2">continue</span>
                <span class="s1">checked.add(real_name)</span>

                <span class="s1">is_type_annotation_import = (</span>
                    <span class="s1">imported_name </span><span class="s2">in </span><span class="s1">self._type_annotation_names</span>
                    <span class="s2">or </span><span class="s1">as_name </span><span class="s2">in </span><span class="s1">self._type_annotation_names</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">isinstance(stmt, astroid.Import) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">isinstance(stmt, astroid.ImportFrom) </span><span class="s2">and not </span><span class="s1">stmt.modname</span>
                <span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">isinstance(stmt, astroid.ImportFrom) </span><span class="s2">and </span><span class="s1">SPECIAL_OBJ.search(</span>
                        <span class="s1">imported_name</span>
                    <span class="s1">):</span>
                        <span class="s0"># Filter special objects (__doc__, __all__) etc.,</span>
                        <span class="s0"># because they can be imported for exporting.</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">is_type_annotation_import:</span>
                        <span class="s0"># Most likely a typing import if it wasn't used so far.</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">as_name == </span><span class="s3">&quot;_&quot;</span><span class="s1">:</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">as_name </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">&quot;import %s&quot; </span><span class="s1">% imported_name</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">imported_name</span><span class="s5">} </span><span class="s3">imported as </span><span class="s5">{</span><span class="s1">as_name</span><span class="s5">}</span><span class="s3">&quot;</span>
                    <span class="s2">if not </span><span class="s1">_is_type_checking_import(stmt):</span>
                        <span class="s1">self.add_message(</span><span class="s3">&quot;unused-import&quot;</span><span class="s1">, args=msg, node=stmt)</span>
                <span class="s2">elif </span><span class="s1">isinstance(stmt, astroid.ImportFrom) </span><span class="s2">and </span><span class="s1">stmt.modname != FUTURE:</span>
                    <span class="s2">if </span><span class="s1">SPECIAL_OBJ.search(imported_name):</span>
                        <span class="s0"># Filter special objects (__doc__, __all__) etc.,</span>
                        <span class="s0"># because they can be imported for exporting.</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">_is_from_future_import(stmt, name):</span>
                        <span class="s0"># Check if the name is in fact loaded from a</span>
                        <span class="s0"># __future__ import in another module.</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">is_type_annotation_import:</span>
                        <span class="s0"># Most likely a typing import if it wasn't used so far.</span>
                        <span class="s2">continue</span>

                    <span class="s2">if </span><span class="s1">imported_name == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
                        <span class="s1">self.add_message(</span><span class="s3">&quot;unused-wildcard-import&quot;</span><span class="s1">, args=name, node=stmt)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">as_name </span><span class="s2">is None</span><span class="s1">:</span>
                            <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">imported_name</span><span class="s5">} </span><span class="s3">imported from </span><span class="s5">{</span><span class="s1">stmt.modname</span><span class="s5">}</span><span class="s3">&quot;</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">fields = (imported_name, stmt.modname, as_name)</span>
                            <span class="s1">msg = </span><span class="s3">&quot;%s imported from %s as %s&quot; </span><span class="s1">% fields</span>
                        <span class="s2">if not </span><span class="s1">_is_type_checking_import(stmt):</span>
                            <span class="s1">self.add_message(</span><span class="s3">&quot;unused-import&quot;</span><span class="s1">, args=msg, node=stmt)</span>
        <span class="s2">del </span><span class="s1">self._to_consume</span>

    <span class="s2">def </span><span class="s1">_check_metaclasses(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Update consumption analysis for metaclasses.&quot;&quot;&quot;</span>
        <span class="s1">consumed = []  </span><span class="s0"># [(scope_locals, consumed_key)]</span>

        <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">node.get_children():</span>
            <span class="s2">if </span><span class="s1">isinstance(child_node, astroid.ClassDef):</span>
                <span class="s1">consumed.extend(self._check_classdef_metaclasses(child_node, node))</span>

        <span class="s0"># Pop the consumed items, in order to avoid having</span>
        <span class="s0"># unused-import and unused-variable false positives</span>
        <span class="s2">for </span><span class="s1">scope_locals, name </span><span class="s2">in </span><span class="s1">consumed:</span>
            <span class="s1">scope_locals.pop(name, </span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_classdef_metaclasses(self, klass, parent_node):</span>
        <span class="s2">if not </span><span class="s1">klass._metaclass:</span>
            <span class="s0"># Skip if this class doesn't use explicitly a metaclass, but inherits it from ancestors</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">consumed = []  </span><span class="s0"># [(scope_locals, consumed_key)]</span>
        <span class="s1">metaclass = klass.metaclass()</span>

        <span class="s1">name = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(klass._metaclass, astroid.Name):</span>
            <span class="s1">name = klass._metaclass.name</span>
        <span class="s2">elif </span><span class="s1">isinstance(klass._metaclass, astroid.Attribute) </span><span class="s2">and </span><span class="s1">klass._metaclass.expr:</span>
            <span class="s1">attr = klass._metaclass.expr</span>
            <span class="s2">while not </span><span class="s1">isinstance(attr, astroid.Name):</span>
                <span class="s1">attr = attr.expr</span>
            <span class="s1">name = attr.name</span>
        <span class="s2">elif </span><span class="s1">metaclass:</span>
            <span class="s1">name = metaclass.root().name</span>

        <span class="s1">found = </span><span class="s2">None</span>
        <span class="s1">name = METACLASS_NAME_TRANSFORMS.get(name, name)</span>
        <span class="s2">if </span><span class="s1">name:</span>
            <span class="s0"># check enclosing scopes starting from most local</span>
            <span class="s2">for </span><span class="s1">scope_locals, _, _ </span><span class="s2">in </span><span class="s1">self._to_consume[::-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">found = scope_locals.get(name)</span>
                <span class="s2">if </span><span class="s1">found:</span>
                    <span class="s1">consumed.append((scope_locals, name))</span>
                    <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">found </span><span class="s2">is None and not </span><span class="s1">metaclass:</span>
            <span class="s1">name = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">isinstance(klass._metaclass, astroid.Name):</span>
                <span class="s1">name = klass._metaclass.name</span>
            <span class="s2">elif </span><span class="s1">(</span>
                <span class="s1">isinstance(klass._metaclass, astroid.Attribute)</span>
                <span class="s2">and </span><span class="s1">klass._metaclass.expr</span>
            <span class="s1">):</span>
                <span class="s1">name = klass._metaclass.expr.name</span>

            <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">(</span>
                    <span class="s1">name </span><span class="s2">in </span><span class="s1">astroid.Module.scope_attrs</span>
                    <span class="s2">or </span><span class="s1">utils.is_builtin(name)</span>
                    <span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.config.additional_builtins</span>
                    <span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">parent_node.locals</span>
                <span class="s1">):</span>
                    <span class="s1">self.add_message(</span><span class="s3">&quot;undefined-variable&quot;</span><span class="s1">, node=klass, args=(name,))</span>

        <span class="s2">return </span><span class="s1">consumed</span>


<span class="s2">def </span><span class="s1">register(linter):</span>
    <span class="s0">&quot;&quot;&quot;required method to auto register this checker&quot;&quot;&quot;</span>
    <span class="s1">linter.register_checker(VariablesChecker(linter))</span>
</pre>
</body>
</html>