<html>
<head>
<title>reports.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #c678dd;}
.s1 { color: #abb2bf;}
.s2 { color: #98c379;}
.s3 { color: #d19a66;}
.s4 { color: #5c6370;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
reports.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">StringIO</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">pprint </span><span class="s0">import </span><span class="s1">pprint</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">attr</span>
<span class="s0">import </span><span class="s1">py</span>

<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ExceptionChainRepr</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ExceptionInfo</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ExceptionRepr</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprEntry</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprEntryNative</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprExceptionInfo</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprFileLocation</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprFuncArgs</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprLocals</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ReprTraceback</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">TerminalRepr</span>
<span class="s0">from </span><span class="s1">_pytest._io </span><span class="s0">import </span><span class="s1">TerminalWriter</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">final</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">_pytest.nodes </span><span class="s0">import </span><span class="s1">Collector</span>
<span class="s0">from </span><span class="s1">_pytest.nodes </span><span class="s0">import </span><span class="s1">Item</span>
<span class="s0">from </span><span class="s1">_pytest.outcomes </span><span class="s0">import </span><span class="s1">skip</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NoReturn</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span>

    <span class="s0">from </span><span class="s1">_pytest.runner </span><span class="s0">import </span><span class="s1">CallInfo</span>


<span class="s0">def </span><span class="s1">getworkerinfoline(node):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node._workerinfocache</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s1">d = node.workerinfo</span>
        <span class="s1">ver = </span><span class="s2">&quot;%s.%s.%s&quot; </span><span class="s1">% d[</span><span class="s2">&quot;version_info&quot;</span><span class="s1">][:</span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">node._workerinfocache = s = </span><span class="s2">&quot;[{}] {} -- Python {} {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">d[</span><span class="s2">&quot;id&quot;</span><span class="s1">], d[</span><span class="s2">&quot;sysplatform&quot;</span><span class="s1">], ver, d[</span><span class="s2">&quot;executable&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">s</span>


<span class="s1">_R = TypeVar(</span><span class="s2">&quot;_R&quot;</span><span class="s1">, bound=</span><span class="s2">&quot;BaseReport&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">BaseReport:</span>
    <span class="s1">when: Optional[str]</span>
    <span class="s1">location: Optional[Tuple[str, Optional[int], str]]</span>
    <span class="s1">longrepr: Union[</span>
        <span class="s0">None</span><span class="s1">, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr</span>
    <span class="s1">]</span>
    <span class="s1">sections: List[Tuple[str, str]]</span>
    <span class="s1">nodeid: str</span>

    <span class="s0">def </span><span class="s1">__init__(self, **kw: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.__dict__.update(kw)</span>

    <span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
        <span class="s4"># Can have arbitrary fields given to __init__().</span>
        <span class="s0">def </span><span class="s1">__getattr__(self, key: str) -&gt; Any:</span>
            <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">toterminal(self, out: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">hasattr(self, </span><span class="s2">&quot;node&quot;</span><span class="s1">):</span>
            <span class="s1">out.line(getworkerinfoline(self.node))</span>

        <span class="s1">longrepr = self.longrepr</span>
        <span class="s0">if </span><span class="s1">longrepr </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">hasattr(longrepr, </span><span class="s2">&quot;toterminal&quot;</span><span class="s1">):</span>
            <span class="s1">longrepr_terminal = cast(TerminalRepr, longrepr)</span>
            <span class="s1">longrepr_terminal.toterminal(out)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">s = str(longrepr)</span>
            <span class="s0">except </span><span class="s1">UnicodeEncodeError:</span>
                <span class="s1">s = </span><span class="s2">&quot;&lt;unprintable longrepr&gt;&quot;</span>
            <span class="s1">out.line(s)</span>

    <span class="s0">def </span><span class="s1">get_sections(self, prefix: str) -&gt; Iterator[Tuple[str, str]]:</span>
        <span class="s0">for </span><span class="s1">name, content </span><span class="s0">in </span><span class="s1">self.sections:</span>
            <span class="s0">if </span><span class="s1">name.startswith(prefix):</span>
                <span class="s0">yield </span><span class="s1">prefix, content</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">longreprtext(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Read-only property that returns the full string representation of 
        ``longrepr``. 
 
        .. versionadded:: 3.0 
        &quot;&quot;&quot;</span>
        <span class="s1">file = StringIO()</span>
        <span class="s1">tw = TerminalWriter(file)</span>
        <span class="s1">tw.hasmarkup = </span><span class="s0">False</span>
        <span class="s1">self.toterminal(tw)</span>
        <span class="s1">exc = file.getvalue()</span>
        <span class="s0">return </span><span class="s1">exc.strip()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">caplog(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Return captured log lines, if log capturing is enabled. 
 
        .. versionadded:: 3.5 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">.join(</span>
            <span class="s1">content </span><span class="s0">for </span><span class="s1">(prefix, content) </span><span class="s0">in </span><span class="s1">self.get_sections(</span><span class="s2">&quot;Captured log&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">capstdout(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Return captured text from stdout, if capturing is enabled. 
 
        .. versionadded:: 3.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(</span>
            <span class="s1">content </span><span class="s0">for </span><span class="s1">(prefix, content) </span><span class="s0">in </span><span class="s1">self.get_sections(</span><span class="s2">&quot;Captured stdout&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">capstderr(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Return captured text from stderr, if capturing is enabled. 
 
        .. versionadded:: 3.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">&quot;&quot;</span><span class="s1">.join(</span>
            <span class="s1">content </span><span class="s0">for </span><span class="s1">(prefix, content) </span><span class="s0">in </span><span class="s1">self.get_sections(</span><span class="s2">&quot;Captured stderr&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">passed = property(</span><span class="s0">lambda </span><span class="s1">x: x.outcome == </span><span class="s2">&quot;passed&quot;</span><span class="s1">)</span>
    <span class="s1">failed = property(</span><span class="s0">lambda </span><span class="s1">x: x.outcome == </span><span class="s2">&quot;failed&quot;</span><span class="s1">)</span>
    <span class="s1">skipped = property(</span><span class="s0">lambda </span><span class="s1">x: x.outcome == </span><span class="s2">&quot;skipped&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fspath(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.nodeid.split(</span><span class="s2">&quot;::&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">count_towards_summary(self) -&gt; bool:</span>
        <span class="s4">&quot;&quot;&quot;**Experimental** Whether this report should be counted towards the 
        totals shown at the end of the test session: &quot;1 passed, 1 failure, etc&quot;. 
 
        .. note:: 
 
            This function is considered **experimental**, so beware that it is subject to changes 
            even in patch releases. 
        &quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">head_line(self) -&gt; Optional[str]:</span>
        <span class="s4">&quot;&quot;&quot;**Experimental** The head line shown with longrepr output for this 
        report, more commonly during traceback representation during 
        failures:: 
 
            ________ Test.foo ________ 
 
 
        In the example above, the head_line is &quot;Test.foo&quot;. 
 
        .. note:: 
 
            This function is considered **experimental**, so beware that it is subject to changes 
            even in patch releases. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.location </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">fspath, lineno, domain = self.location</span>
            <span class="s0">return </span><span class="s1">domain</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">_get_verbose_word(self, config: Config):</span>
        <span class="s1">_category, _short, verbose = config.hook.pytest_report_teststatus(</span>
            <span class="s1">report=self, config=config</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">verbose</span>

    <span class="s0">def </span><span class="s1">_to_json(self) -&gt; Dict[str, Any]:</span>
        <span class="s4">&quot;&quot;&quot;Return the contents of this report as a dict of builtin entries, 
        suitable for serialization. 
 
        This was originally the serialize_report() function from xdist (ca03269). 
 
        Experimental method. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_report_to_json(self)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_json(cls: Type[_R], reportdict: Dict[str, object]) -&gt; _R:</span>
        <span class="s4">&quot;&quot;&quot;Create either a TestReport or CollectReport, depending on the calling class. 
 
        It is the callers responsibility to know which class to pass here. 
 
        This was originally the serialize_report() function from xdist (ca03269). 
 
        Experimental method. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs = _report_kwargs_from_json(reportdict)</span>
        <span class="s0">return </span><span class="s1">cls(**kwargs)</span>


<span class="s0">def </span><span class="s1">_report_unserialization_failure(</span>
    <span class="s1">type_name: str, report_class: Type[BaseReport], reportdict</span>
<span class="s1">) -&gt; </span><span class="s2">&quot;NoReturn&quot;</span><span class="s1">:</span>
    <span class="s1">url = </span><span class="s2">&quot;https://github.com/pytest-dev/pytest/issues&quot;</span>
    <span class="s1">stream = StringIO()</span>
    <span class="s1">pprint(</span><span class="s2">&quot;-&quot; </span><span class="s1">* </span><span class="s3">100</span><span class="s1">, stream=stream)</span>
    <span class="s1">pprint(</span><span class="s2">&quot;INTERNALERROR: Unknown entry type returned: %s&quot; </span><span class="s1">% type_name, stream=stream)</span>
    <span class="s1">pprint(</span><span class="s2">&quot;report_name: %s&quot; </span><span class="s1">% report_class, stream=stream)</span>
    <span class="s1">pprint(reportdict, stream=stream)</span>
    <span class="s1">pprint(</span><span class="s2">&quot;Please report this bug at %s&quot; </span><span class="s1">% url, stream=stream)</span>
    <span class="s1">pprint(</span><span class="s2">&quot;-&quot; </span><span class="s1">* </span><span class="s3">100</span><span class="s1">, stream=stream)</span>
    <span class="s0">raise </span><span class="s1">RuntimeError(stream.getvalue())</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">TestReport(BaseReport):</span>
    <span class="s4">&quot;&quot;&quot;Basic test report object (also used for setup and teardown calls if 
    they fail).&quot;&quot;&quot;</span>

    <span class="s1">__test__ = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">nodeid: str,</span>
        <span class="s1">location: Tuple[str, Optional[int], str],</span>
        <span class="s1">keywords,</span>
        <span class="s1">outcome: </span><span class="s2">&quot;Literal['passed', 'failed', 'skipped']&quot;</span><span class="s1">,</span>
        <span class="s1">longrepr: Union[</span>
            <span class="s0">None</span><span class="s1">, ExceptionInfo[BaseException], Tuple[str, int, str], str, TerminalRepr</span>
        <span class="s1">],</span>
        <span class="s1">when: </span><span class="s2">&quot;Literal['setup', 'call', 'teardown']&quot;</span><span class="s1">,</span>
        <span class="s1">sections: Iterable[Tuple[str, str]] = (),</span>
        <span class="s1">duration: float = </span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">user_properties: Optional[Iterable[Tuple[str, object]]] = </span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">**extra,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">#: Normalized collection nodeid.</span>
        <span class="s1">self.nodeid = nodeid</span>

        <span class="s4">#: A (filesystempath, lineno, domaininfo) tuple indicating the</span>
        <span class="s4">#: actual location of a test item - it might be different from the</span>
        <span class="s4">#: collected one e.g. if a method is inherited from a different module.</span>
        <span class="s1">self.location: Tuple[str, Optional[int], str] = location</span>

        <span class="s4">#: A name -&gt; value dictionary containing all keywords and</span>
        <span class="s4">#: markers associated with a test invocation.</span>
        <span class="s1">self.keywords = keywords</span>

        <span class="s4">#: Test outcome, always one of &quot;passed&quot;, &quot;failed&quot;, &quot;skipped&quot;.</span>
        <span class="s1">self.outcome = outcome</span>

        <span class="s4">#: None or a failure representation.</span>
        <span class="s1">self.longrepr = longrepr</span>

        <span class="s4">#: One of 'setup', 'call', 'teardown' to indicate runtest phase.</span>
        <span class="s1">self.when = when</span>

        <span class="s4">#: User properties is a list of tuples (name, value) that holds user</span>
        <span class="s4">#: defined properties of the test.</span>
        <span class="s1">self.user_properties = list(user_properties </span><span class="s0">or </span><span class="s1">[])</span>

        <span class="s4">#: List of pairs ``(str, str)`` of extra information which needs to</span>
        <span class="s4">#: marshallable. Used by pytest to add captured text</span>
        <span class="s4">#: from ``stdout`` and ``stderr``, but may be used by other plugins</span>
        <span class="s4">#: to add arbitrary information to reports.</span>
        <span class="s1">self.sections = list(sections)</span>

        <span class="s4">#: Time it took to run just the test.</span>
        <span class="s1">self.duration = duration</span>

        <span class="s1">self.__dict__.update(extra)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;{} {!r} when={!r} outcome={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.__class__.__name__, self.nodeid, self.when, self.outcome</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_item_and_call(cls, item: Item, call: </span><span class="s2">&quot;CallInfo[None]&quot;</span><span class="s1">) -&gt; </span><span class="s2">&quot;TestReport&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Create and fill a TestReport with standard item and call info.&quot;&quot;&quot;</span>
        <span class="s1">when = call.when</span>
        <span class="s4"># Remove &quot;collect&quot; from the Literal type -- only for collection calls.</span>
        <span class="s0">assert </span><span class="s1">when != </span><span class="s2">&quot;collect&quot;</span>
        <span class="s1">duration = call.duration</span>
        <span class="s1">keywords = {x: </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">item.keywords}</span>
        <span class="s1">excinfo = call.excinfo</span>
        <span class="s1">sections = []</span>
        <span class="s0">if not </span><span class="s1">call.excinfo:</span>
            <span class="s1">outcome: Literal[</span><span class="s2">&quot;passed&quot;</span><span class="s1">, </span><span class="s2">&quot;failed&quot;</span><span class="s1">, </span><span class="s2">&quot;skipped&quot;</span><span class="s1">] = </span><span class="s2">&quot;passed&quot;</span>
            <span class="s1">longrepr: Union[</span>
                <span class="s0">None</span><span class="s1">,</span>
                <span class="s1">ExceptionInfo[BaseException],</span>
                <span class="s1">Tuple[str, int, str],</span>
                <span class="s1">str,</span>
                <span class="s1">TerminalRepr,</span>
            <span class="s1">] = (</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(excinfo, ExceptionInfo):</span>
                <span class="s1">outcome = </span><span class="s2">&quot;failed&quot;</span>
                <span class="s1">longrepr = excinfo</span>
            <span class="s0">elif </span><span class="s1">isinstance(excinfo.value, skip.Exception):</span>
                <span class="s1">outcome = </span><span class="s2">&quot;skipped&quot;</span>
                <span class="s1">r = excinfo._getreprcrash()</span>
                <span class="s1">longrepr = (str(r.path), r.lineno, r.message)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">outcome = </span><span class="s2">&quot;failed&quot;</span>
                <span class="s0">if </span><span class="s1">call.when == </span><span class="s2">&quot;call&quot;</span><span class="s1">:</span>
                    <span class="s1">longrepr = item.repr_failure(excinfo)</span>
                <span class="s0">else</span><span class="s1">:  </span><span class="s4"># exception in setup or teardown</span>
                    <span class="s1">longrepr = item._repr_failure_py(</span>
                        <span class="s1">excinfo, style=item.config.getoption(</span><span class="s2">&quot;tbstyle&quot;</span><span class="s1">, </span><span class="s2">&quot;auto&quot;</span><span class="s1">)</span>
                    <span class="s1">)</span>
        <span class="s0">for </span><span class="s1">rwhen, key, content </span><span class="s0">in </span><span class="s1">item._report_sections:</span>
            <span class="s1">sections.append((</span><span class="s2">f&quot;Captured </span><span class="s5">{</span><span class="s1">key</span><span class="s5">} {</span><span class="s1">rwhen</span><span class="s5">}</span><span class="s2">&quot;</span><span class="s1">, content))</span>
        <span class="s0">return </span><span class="s1">cls(</span>
            <span class="s1">item.nodeid,</span>
            <span class="s1">item.location,</span>
            <span class="s1">keywords,</span>
            <span class="s1">outcome,</span>
            <span class="s1">longrepr,</span>
            <span class="s1">when,</span>
            <span class="s1">sections,</span>
            <span class="s1">duration,</span>
            <span class="s1">user_properties=item.user_properties,</span>
        <span class="s1">)</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">CollectReport(BaseReport):</span>
    <span class="s4">&quot;&quot;&quot;Collection report object.&quot;&quot;&quot;</span>

    <span class="s1">when = </span><span class="s2">&quot;collect&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">nodeid: str,</span>
        <span class="s1">outcome: </span><span class="s2">&quot;Literal['passed', 'skipped', 'failed']&quot;</span><span class="s1">,</span>
        <span class="s1">longrepr,</span>
        <span class="s1">result: Optional[List[Union[Item, Collector]]],</span>
        <span class="s1">sections: Iterable[Tuple[str, str]] = (),</span>
        <span class="s1">**extra,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">#: Normalized collection nodeid.</span>
        <span class="s1">self.nodeid = nodeid</span>

        <span class="s4">#: Test outcome, always one of &quot;passed&quot;, &quot;failed&quot;, &quot;skipped&quot;.</span>
        <span class="s1">self.outcome = outcome</span>

        <span class="s4">#: None or a failure representation.</span>
        <span class="s1">self.longrepr = longrepr</span>

        <span class="s4">#: The collected items and collection nodes.</span>
        <span class="s1">self.result = result </span><span class="s0">or </span><span class="s1">[]</span>

        <span class="s4">#: List of pairs ``(str, str)`` of extra information which needs to</span>
        <span class="s4">#: marshallable.</span>
        <span class="s4"># Used by pytest to add captured text : from ``stdout`` and ``stderr``,</span>
        <span class="s4"># but may be used by other plugins : to add arbitrary information to</span>
        <span class="s4"># reports.</span>
        <span class="s1">self.sections = list(sections)</span>

        <span class="s1">self.__dict__.update(extra)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">location(self):</span>
        <span class="s0">return </span><span class="s1">(self.fspath, </span><span class="s0">None</span><span class="s1">, self.fspath)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;CollectReport {!r} lenresult={} outcome={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.nodeid, len(self.result), self.outcome</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">CollectErrorRepr(TerminalRepr):</span>
    <span class="s0">def </span><span class="s1">__init__(self, msg: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.longrepr = msg</span>

    <span class="s0">def </span><span class="s1">toterminal(self, out: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">out.line(self.longrepr, red=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">pytest_report_to_serializable(</span>
    <span class="s1">report: Union[CollectReport, TestReport]</span>
<span class="s1">) -&gt; Optional[Dict[str, Any]]:</span>
    <span class="s0">if </span><span class="s1">isinstance(report, (TestReport, CollectReport)):</span>
        <span class="s1">data = report._to_json()</span>
        <span class="s1">data[</span><span class="s2">&quot;$report_type&quot;</span><span class="s1">] = report.__class__.__name__</span>
        <span class="s0">return </span><span class="s1">data</span>
    <span class="s4"># TODO: Check if this is actually reachable.</span>
    <span class="s0">return None  </span><span class="s4"># type: ignore[unreachable]</span>


<span class="s0">def </span><span class="s1">pytest_report_from_serializable(</span>
    <span class="s1">data: Dict[str, Any],</span>
<span class="s1">) -&gt; Optional[Union[CollectReport, TestReport]]:</span>
    <span class="s0">if </span><span class="s2">&quot;$report_type&quot; </span><span class="s0">in </span><span class="s1">data:</span>
        <span class="s0">if </span><span class="s1">data[</span><span class="s2">&quot;$report_type&quot;</span><span class="s1">] == </span><span class="s2">&quot;TestReport&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">TestReport._from_json(data)</span>
        <span class="s0">elif </span><span class="s1">data[</span><span class="s2">&quot;$report_type&quot;</span><span class="s1">] == </span><span class="s2">&quot;CollectReport&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">CollectReport._from_json(data)</span>
        <span class="s0">assert False</span><span class="s1">, </span><span class="s2">&quot;Unknown report_type unserialize data: {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">data[</span><span class="s2">&quot;$report_type&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">_report_to_json(report: BaseReport) -&gt; Dict[str, Any]:</span>
    <span class="s4">&quot;&quot;&quot;Return the contents of this report as a dict of builtin entries, 
    suitable for serialization. 
 
    This was originally the serialize_report() function from xdist (ca03269). 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">serialize_repr_entry(</span>
        <span class="s1">entry: Union[ReprEntry, ReprEntryNative]</span>
    <span class="s1">) -&gt; Dict[str, Any]:</span>
        <span class="s1">data = attr.asdict(entry)</span>
        <span class="s0">for </span><span class="s1">key, value </span><span class="s0">in </span><span class="s1">data.items():</span>
            <span class="s0">if </span><span class="s1">hasattr(value, </span><span class="s2">&quot;__dict__&quot;</span><span class="s1">):</span>
                <span class="s1">data[key] = attr.asdict(value)</span>
        <span class="s1">entry_data = {</span><span class="s2">&quot;type&quot;</span><span class="s1">: type(entry).__name__, </span><span class="s2">&quot;data&quot;</span><span class="s1">: data}</span>
        <span class="s0">return </span><span class="s1">entry_data</span>

    <span class="s0">def </span><span class="s1">serialize_repr_traceback(reprtraceback: ReprTraceback) -&gt; Dict[str, Any]:</span>
        <span class="s1">result = attr.asdict(reprtraceback)</span>
        <span class="s1">result[</span><span class="s2">&quot;reprentries&quot;</span><span class="s1">] = [</span>
            <span class="s1">serialize_repr_entry(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">reprtraceback.reprentries</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">serialize_repr_crash(</span>
        <span class="s1">reprcrash: Optional[ReprFileLocation],</span>
    <span class="s1">) -&gt; Optional[Dict[str, Any]]:</span>
        <span class="s0">if </span><span class="s1">reprcrash </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">attr.asdict(reprcrash)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">serialize_exception_longrepr(rep: BaseReport) -&gt; Dict[str, Any]:</span>
        <span class="s0">assert </span><span class="s1">rep.longrepr </span><span class="s0">is not None</span>
        <span class="s4"># TODO: Investigate whether the duck typing is really necessary here.</span>
        <span class="s1">longrepr = cast(ExceptionRepr, rep.longrepr)</span>
        <span class="s1">result: Dict[str, Any] = {</span>
            <span class="s2">&quot;reprcrash&quot;</span><span class="s1">: serialize_repr_crash(longrepr.reprcrash),</span>
            <span class="s2">&quot;reprtraceback&quot;</span><span class="s1">: serialize_repr_traceback(longrepr.reprtraceback),</span>
            <span class="s2">&quot;sections&quot;</span><span class="s1">: longrepr.sections,</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">isinstance(longrepr, ExceptionChainRepr):</span>
            <span class="s1">result[</span><span class="s2">&quot;chain&quot;</span><span class="s1">] = []</span>
            <span class="s0">for </span><span class="s1">repr_traceback, repr_crash, description </span><span class="s0">in </span><span class="s1">longrepr.chain:</span>
                <span class="s1">result[</span><span class="s2">&quot;chain&quot;</span><span class="s1">].append(</span>
                    <span class="s1">(</span>
                        <span class="s1">serialize_repr_traceback(repr_traceback),</span>
                        <span class="s1">serialize_repr_crash(repr_crash),</span>
                        <span class="s1">description,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result[</span><span class="s2">&quot;chain&quot;</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">d = report.__dict__.copy()</span>
    <span class="s0">if </span><span class="s1">hasattr(report.longrepr, </span><span class="s2">&quot;toterminal&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">hasattr(report.longrepr, </span><span class="s2">&quot;reprtraceback&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">hasattr(</span>
            <span class="s1">report.longrepr, </span><span class="s2">&quot;reprcrash&quot;</span>
        <span class="s1">):</span>
            <span class="s1">d[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">] = serialize_exception_longrepr(report)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">] = str(report.longrepr)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">d[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">] = report.longrepr</span>
    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">d:</span>
        <span class="s0">if </span><span class="s1">isinstance(d[name], (py.path.local, Path)):</span>
            <span class="s1">d[name] = str(d[name])</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s2">&quot;result&quot;</span><span class="s1">:</span>
            <span class="s1">d[name] = </span><span class="s0">None  </span><span class="s4"># for now</span>
    <span class="s0">return </span><span class="s1">d</span>


<span class="s0">def </span><span class="s1">_report_kwargs_from_json(reportdict: Dict[str, Any]) -&gt; Dict[str, Any]:</span>
    <span class="s4">&quot;&quot;&quot;Return **kwargs that can be used to construct a TestReport or 
    CollectReport instance. 
 
    This was originally the serialize_report() function from xdist (ca03269). 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">deserialize_repr_entry(entry_data):</span>
        <span class="s1">data = entry_data[</span><span class="s2">&quot;data&quot;</span><span class="s1">]</span>
        <span class="s1">entry_type = entry_data[</span><span class="s2">&quot;type&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">entry_type == </span><span class="s2">&quot;ReprEntry&quot;</span><span class="s1">:</span>
            <span class="s1">reprfuncargs = </span><span class="s0">None</span>
            <span class="s1">reprfileloc = </span><span class="s0">None</span>
            <span class="s1">reprlocals = </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">data[</span><span class="s2">&quot;reprfuncargs&quot;</span><span class="s1">]:</span>
                <span class="s1">reprfuncargs = ReprFuncArgs(**data[</span><span class="s2">&quot;reprfuncargs&quot;</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">data[</span><span class="s2">&quot;reprfileloc&quot;</span><span class="s1">]:</span>
                <span class="s1">reprfileloc = ReprFileLocation(**data[</span><span class="s2">&quot;reprfileloc&quot;</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">data[</span><span class="s2">&quot;reprlocals&quot;</span><span class="s1">]:</span>
                <span class="s1">reprlocals = ReprLocals(data[</span><span class="s2">&quot;reprlocals&quot;</span><span class="s1">][</span><span class="s2">&quot;lines&quot;</span><span class="s1">])</span>

            <span class="s1">reprentry: Union[ReprEntry, ReprEntryNative] = ReprEntry(</span>
                <span class="s1">lines=data[</span><span class="s2">&quot;lines&quot;</span><span class="s1">],</span>
                <span class="s1">reprfuncargs=reprfuncargs,</span>
                <span class="s1">reprlocals=reprlocals,</span>
                <span class="s1">reprfileloc=reprfileloc,</span>
                <span class="s1">style=data[</span><span class="s2">&quot;style&quot;</span><span class="s1">],</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">entry_type == </span><span class="s2">&quot;ReprEntryNative&quot;</span><span class="s1">:</span>
            <span class="s1">reprentry = ReprEntryNative(data[</span><span class="s2">&quot;lines&quot;</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_report_unserialization_failure(entry_type, TestReport, reportdict)</span>
        <span class="s0">return </span><span class="s1">reprentry</span>

    <span class="s0">def </span><span class="s1">deserialize_repr_traceback(repr_traceback_dict):</span>
        <span class="s1">repr_traceback_dict[</span><span class="s2">&quot;reprentries&quot;</span><span class="s1">] = [</span>
            <span class="s1">deserialize_repr_entry(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">repr_traceback_dict[</span><span class="s2">&quot;reprentries&quot;</span><span class="s1">]</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">ReprTraceback(**repr_traceback_dict)</span>

    <span class="s0">def </span><span class="s1">deserialize_repr_crash(repr_crash_dict: Optional[Dict[str, Any]]):</span>
        <span class="s0">if </span><span class="s1">repr_crash_dict </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">ReprFileLocation(**repr_crash_dict)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return None</span>

    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">]</span>
        <span class="s0">and </span><span class="s2">&quot;reprcrash&quot; </span><span class="s0">in </span><span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">]</span>
        <span class="s0">and </span><span class="s2">&quot;reprtraceback&quot; </span><span class="s0">in </span><span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">]</span>
    <span class="s1">):</span>

        <span class="s1">reprtraceback = deserialize_repr_traceback(</span>
            <span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">][</span><span class="s2">&quot;reprtraceback&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">reprcrash = deserialize_repr_crash(reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">][</span><span class="s2">&quot;reprcrash&quot;</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">][</span><span class="s2">&quot;chain&quot;</span><span class="s1">]:</span>
            <span class="s1">chain = []</span>
            <span class="s0">for </span><span class="s1">repr_traceback_data, repr_crash_data, description </span><span class="s0">in </span><span class="s1">reportdict[</span>
                <span class="s2">&quot;longrepr&quot;</span>
            <span class="s1">][</span><span class="s2">&quot;chain&quot;</span><span class="s1">]:</span>
                <span class="s1">chain.append(</span>
                    <span class="s1">(</span>
                        <span class="s1">deserialize_repr_traceback(repr_traceback_data),</span>
                        <span class="s1">deserialize_repr_crash(repr_crash_data),</span>
                        <span class="s1">description,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">exception_info: Union[</span>
                <span class="s1">ExceptionChainRepr, ReprExceptionInfo</span>
            <span class="s1">] = ExceptionChainRepr(chain)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">exception_info = ReprExceptionInfo(reprtraceback, reprcrash)</span>

        <span class="s0">for </span><span class="s1">section </span><span class="s0">in </span><span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">][</span><span class="s2">&quot;sections&quot;</span><span class="s1">]:</span>
            <span class="s1">exception_info.addsection(*section)</span>
        <span class="s1">reportdict[</span><span class="s2">&quot;longrepr&quot;</span><span class="s1">] = exception_info</span>

    <span class="s0">return </span><span class="s1">reportdict</span>
</pre>
</body>
</html>