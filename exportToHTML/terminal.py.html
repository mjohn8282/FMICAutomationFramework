<html>
<head>
<title>terminal.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #d19a66;}
.s4 { color: #98c379;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
terminal.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Terminal reporting of the full testing process. 
 
This is a good source for looking at the various reporting hooks. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">argparse</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">Counter</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Set</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TextIO</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">attr</span>
<span class="s2">import </span><span class="s1">pluggy</span>
<span class="s2">import </span><span class="s1">py</span>

<span class="s2">import </span><span class="s1">_pytest._version</span>
<span class="s2">from </span><span class="s1">_pytest </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">_pytest </span><span class="s2">import </span><span class="s1">timing</span>
<span class="s2">from </span><span class="s1">_pytest._code </span><span class="s2">import </span><span class="s1">ExceptionInfo</span>
<span class="s2">from </span><span class="s1">_pytest._code.code </span><span class="s2">import </span><span class="s1">ExceptionRepr</span>
<span class="s2">from </span><span class="s1">_pytest._io.wcwidth </span><span class="s2">import </span><span class="s1">wcswidth</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">_PluggyPlugin</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">Config</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">ExitCode</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">hookimpl</span>
<span class="s2">from </span><span class="s1">_pytest.config.argparsing </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">_pytest.nodes </span><span class="s2">import </span><span class="s1">Item</span>
<span class="s2">from </span><span class="s1">_pytest.nodes </span><span class="s2">import </span><span class="s1">Node</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">absolutepath</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">bestrelpath</span>
<span class="s2">from </span><span class="s1">_pytest.reports </span><span class="s2">import </span><span class="s1">BaseReport</span>
<span class="s2">from </span><span class="s1">_pytest.reports </span><span class="s2">import </span><span class="s1">CollectReport</span>
<span class="s2">from </span><span class="s1">_pytest.reports </span><span class="s2">import </span><span class="s1">TestReport</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Literal</span>

    <span class="s2">from </span><span class="s1">_pytest.main </span><span class="s2">import </span><span class="s1">Session</span>


<span class="s1">REPORT_COLLECTING_RESOLUTION = </span><span class="s3">0.5</span>

<span class="s1">KNOWN_TYPES = (</span>
    <span class="s4">&quot;failed&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;passed&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;skipped&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;deselected&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;xfailed&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;xpassed&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;warnings&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;error&quot;</span><span class="s1">,</span>
<span class="s1">)</span>

<span class="s1">_REPORTCHARS_DEFAULT = </span><span class="s4">&quot;fE&quot;</span>


<span class="s2">class </span><span class="s1">MoreQuietAction(argparse.Action):</span>
    <span class="s0">&quot;&quot;&quot;A modified copy of the argparse count action which counts down and updates 
    the legacy quiet attribute at the same time. 
 
    Used to unify verbosity handling. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">option_strings: Sequence[str],</span>
        <span class="s1">dest: str,</span>
        <span class="s1">default: object = </span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">required: bool = </span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help: Optional[str] = </span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">option_strings=option_strings,</span>
            <span class="s1">dest=dest,</span>
            <span class="s1">nargs=</span><span class="s3">0</span><span class="s1">,</span>
            <span class="s1">default=default,</span>
            <span class="s1">required=required,</span>
            <span class="s1">help=help,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self,</span>
        <span class="s1">parser: argparse.ArgumentParser,</span>
        <span class="s1">namespace: argparse.Namespace,</span>
        <span class="s1">values: Union[str, Sequence[object], </span><span class="s2">None</span><span class="s1">],</span>
        <span class="s1">option_string: Optional[str] = </span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">new_count = getattr(namespace, self.dest, </span><span class="s3">0</span><span class="s1">) - </span><span class="s3">1</span>
        <span class="s1">setattr(namespace, self.dest, new_count)</span>
        <span class="s0"># todo Deprecate config.quiet</span>
        <span class="s1">namespace.quiet = getattr(namespace, </span><span class="s4">&quot;quiet&quot;</span><span class="s1">, </span><span class="s3">0</span><span class="s1">) + </span><span class="s3">1</span>


<span class="s2">def </span><span class="s1">pytest_addoption(parser: Parser) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">group = parser.getgroup(</span><span class="s4">&quot;terminal reporting&quot;</span><span class="s1">, </span><span class="s4">&quot;reporting&quot;</span><span class="s1">, after=</span><span class="s4">&quot;general&quot;</span><span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;-v&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;--verbose&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;count&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;verbose&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;increase verbosity.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--no-header&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;no_header&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;disable header&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--no-summary&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;no_summary&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;disable summary&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;-q&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;--quiet&quot;</span><span class="s1">,</span>
        <span class="s1">action=MoreQuietAction,</span>
        <span class="s1">default=</span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;verbose&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;decrease verbosity.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--verbosity&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;verbose&quot;</span><span class="s1">,</span>
        <span class="s1">type=int,</span>
        <span class="s1">default=</span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;set verbosity. Default is 0.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;-r&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;reportchars&quot;</span><span class="s1">,</span>
        <span class="s1">default=_REPORTCHARS_DEFAULT,</span>
        <span class="s1">metavar=</span><span class="s4">&quot;chars&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;show extra test summary info as specified by chars: (f)ailed, &quot;</span>
        <span class="s4">&quot;(E)rror, (s)kipped, (x)failed, (X)passed, &quot;</span>
        <span class="s4">&quot;(p)assed, (P)assed with output, (a)ll except passed (p/P), or (A)ll. &quot;</span>
        <span class="s4">&quot;(w)arnings are enabled by default (see --disable-warnings), &quot;</span>
        <span class="s4">&quot;'N' can be used to reset the list. (default: 'fE').&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--disable-warnings&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;--disable-pytest-warnings&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;disable_warnings&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;disable warnings summary&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;-l&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;--showlocals&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;showlocals&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;show locals in tracebacks (disabled by default).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--tb&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s4">&quot;style&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;tbstyle&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s4">&quot;auto&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s4">&quot;auto&quot;</span><span class="s1">, </span><span class="s4">&quot;long&quot;</span><span class="s1">, </span><span class="s4">&quot;short&quot;</span><span class="s1">, </span><span class="s4">&quot;no&quot;</span><span class="s1">, </span><span class="s4">&quot;line&quot;</span><span class="s1">, </span><span class="s4">&quot;native&quot;</span><span class="s1">],</span>
        <span class="s1">help=</span><span class="s4">&quot;traceback print mode (auto/long/short/line/native/no).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--show-capture&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;showcapture&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s4">&quot;no&quot;</span><span class="s1">, </span><span class="s4">&quot;stdout&quot;</span><span class="s1">, </span><span class="s4">&quot;stderr&quot;</span><span class="s1">, </span><span class="s4">&quot;log&quot;</span><span class="s1">, </span><span class="s4">&quot;all&quot;</span><span class="s1">],</span>
        <span class="s1">default=</span><span class="s4">&quot;all&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;Controls how captured stdout/stderr/log is shown on failed tests. &quot;</span>
        <span class="s4">&quot;Default is 'all'.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--fulltrace&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;--full-trace&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">&quot;don't cut any tracebacks (default is to cut).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--color&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s4">&quot;color&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s4">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s4">&quot;color&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s4">&quot;auto&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s4">&quot;yes&quot;</span><span class="s1">, </span><span class="s4">&quot;no&quot;</span><span class="s1">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">],</span>
        <span class="s1">help=</span><span class="s4">&quot;color terminal output (yes/no/auto).&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s4">&quot;--code-highlight&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s4">&quot;yes&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s4">&quot;yes&quot;</span><span class="s1">, </span><span class="s4">&quot;no&quot;</span><span class="s1">],</span>
        <span class="s1">help=</span><span class="s4">&quot;Whether code should be highlighted (only if --color is also enabled)&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>

    <span class="s1">parser.addini(</span>
        <span class="s4">&quot;console_output_style&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s4">'console output: &quot;classic&quot;, or with additional progress information (&quot;progress&quot; (percentage) | &quot;count&quot;).'</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s4">&quot;progress&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">pytest_configure(config: Config) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">reporter = TerminalReporter(config, sys.stdout)</span>
    <span class="s1">config.pluginmanager.register(reporter, </span><span class="s4">&quot;terminalreporter&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">config.option.debug </span><span class="s2">or </span><span class="s1">config.option.traceconfig:</span>

        <span class="s2">def </span><span class="s1">mywriter(tags, args):</span>
            <span class="s1">msg = </span><span class="s4">&quot; &quot;</span><span class="s1">.join(map(str, args))</span>
            <span class="s1">reporter.write_line(</span><span class="s4">&quot;[traceconfig] &quot; </span><span class="s1">+ msg)</span>

        <span class="s1">config.trace.root.setprocessor(</span><span class="s4">&quot;pytest:config&quot;</span><span class="s1">, mywriter)</span>


<span class="s2">def </span><span class="s1">getreportopt(config: Config) -&gt; str:</span>
    <span class="s1">reportchars: str = config.option.reportchars</span>

    <span class="s1">old_aliases = {</span><span class="s4">&quot;F&quot;</span><span class="s1">, </span><span class="s4">&quot;S&quot;</span><span class="s1">}</span>
    <span class="s1">reportopts = </span><span class="s4">&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">reportchars:</span>
        <span class="s2">if </span><span class="s1">char </span><span class="s2">in </span><span class="s1">old_aliases:</span>
            <span class="s1">char = char.lower()</span>
        <span class="s2">if </span><span class="s1">char == </span><span class="s4">&quot;a&quot;</span><span class="s1">:</span>
            <span class="s1">reportopts = </span><span class="s4">&quot;sxXEf&quot;</span>
        <span class="s2">elif </span><span class="s1">char == </span><span class="s4">&quot;A&quot;</span><span class="s1">:</span>
            <span class="s1">reportopts = </span><span class="s4">&quot;PpsxXEf&quot;</span>
        <span class="s2">elif </span><span class="s1">char == </span><span class="s4">&quot;N&quot;</span><span class="s1">:</span>
            <span class="s1">reportopts = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">elif </span><span class="s1">char </span><span class="s2">not in </span><span class="s1">reportopts:</span>
            <span class="s1">reportopts += char</span>

    <span class="s2">if not </span><span class="s1">config.option.disable_warnings </span><span class="s2">and </span><span class="s4">&quot;w&quot; </span><span class="s2">not in </span><span class="s1">reportopts:</span>
        <span class="s1">reportopts = </span><span class="s4">&quot;w&quot; </span><span class="s1">+ reportopts</span>
    <span class="s2">elif </span><span class="s1">config.option.disable_warnings </span><span class="s2">and </span><span class="s4">&quot;w&quot; </span><span class="s2">in </span><span class="s1">reportopts:</span>
        <span class="s1">reportopts = reportopts.replace(</span><span class="s4">&quot;w&quot;</span><span class="s1">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">reportopts</span>


<span class="s1">@hookimpl(trylast=</span><span class="s2">True</span><span class="s1">)  </span><span class="s0"># after _pytest.runner</span>
<span class="s2">def </span><span class="s1">pytest_report_teststatus(report: BaseReport) -&gt; Tuple[str, str, str]:</span>
    <span class="s1">letter = </span><span class="s4">&quot;F&quot;</span>
    <span class="s2">if </span><span class="s1">report.passed:</span>
        <span class="s1">letter = </span><span class="s4">&quot;.&quot;</span>
    <span class="s2">elif </span><span class="s1">report.skipped:</span>
        <span class="s1">letter = </span><span class="s4">&quot;s&quot;</span>

    <span class="s1">outcome: str = report.outcome</span>
    <span class="s2">if </span><span class="s1">report.when </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;collect&quot;</span><span class="s1">, </span><span class="s4">&quot;setup&quot;</span><span class="s1">, </span><span class="s4">&quot;teardown&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">outcome == </span><span class="s4">&quot;failed&quot;</span><span class="s1">:</span>
        <span class="s1">outcome = </span><span class="s4">&quot;error&quot;</span>
        <span class="s1">letter = </span><span class="s4">&quot;E&quot;</span>

    <span class="s2">return </span><span class="s1">outcome, letter, outcome.upper()</span>


<span class="s1">@attr.s</span>
<span class="s2">class </span><span class="s1">WarningReport:</span>
    <span class="s0">&quot;&quot;&quot;Simple structure to hold warnings information captured by ``pytest_warning_recorded``. 
 
    :ivar str message: 
        User friendly message about the warning. 
    :ivar str|None nodeid: 
        nodeid that generated the warning (see ``get_location``). 
    :ivar tuple|py.path.local fslocation: 
        File system location of the source of the warning (see ``get_location``). 
    &quot;&quot;&quot;</span>

    <span class="s1">message = attr.ib(type=str)</span>
    <span class="s1">nodeid = attr.ib(type=Optional[str], default=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">fslocation = attr.ib(</span>
        <span class="s1">type=Optional[Union[Tuple[str, int], py.path.local]], default=</span><span class="s2">None</span>
    <span class="s1">)</span>
    <span class="s1">count_towards_summary = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_location(self, config: Config) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot;Return the more user-friendly information about the location of a warning, or None.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.nodeid:</span>
            <span class="s2">return </span><span class="s1">self.nodeid</span>
        <span class="s2">if </span><span class="s1">self.fslocation:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.fslocation, tuple) </span><span class="s2">and </span><span class="s1">len(self.fslocation) &gt;= </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s1">filename, linenum = self.fslocation[:</span><span class="s3">2</span><span class="s1">]</span>
                <span class="s1">relpath = bestrelpath(</span>
                    <span class="s1">config.invocation_params.dir, absolutepath(filename)</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">relpath</span><span class="s5">}</span><span class="s4">:</span><span class="s5">{</span><span class="s1">linenum</span><span class="s5">}</span><span class="s4">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">str(self.fslocation)</span>
        <span class="s2">return None</span>


<span class="s1">@final</span>
<span class="s2">class </span><span class="s1">TerminalReporter:</span>
    <span class="s2">def </span><span class="s1">__init__(self, config: Config, file: Optional[TextIO] = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">_pytest.config</span>

        <span class="s1">self.config = config</span>
        <span class="s1">self._numcollected = </span><span class="s3">0</span>
        <span class="s1">self._session: Optional[Session] = </span><span class="s2">None</span>
        <span class="s1">self._showfspath: Optional[bool] = </span><span class="s2">None</span>

        <span class="s1">self.stats: Dict[str, List[Any]] = {}</span>
        <span class="s1">self._main_color: Optional[str] = </span><span class="s2">None</span>
        <span class="s1">self._known_types: Optional[List[str]] = </span><span class="s2">None</span>
        <span class="s1">self.startdir = config.invocation_dir</span>
        <span class="s1">self.startpath = config.invocation_params.dir</span>
        <span class="s2">if </span><span class="s1">file </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">file = sys.stdout</span>
        <span class="s1">self._tw = _pytest.config.create_terminal_writer(config, file)</span>
        <span class="s1">self._screen_width = self._tw.fullwidth</span>
        <span class="s1">self.currentfspath: Union[</span><span class="s2">None</span><span class="s1">, Path, str, int] = </span><span class="s2">None</span>
        <span class="s1">self.reportchars = getreportopt(config)</span>
        <span class="s1">self.hasmarkup = self._tw.hasmarkup</span>
        <span class="s1">self.isatty = file.isatty()</span>
        <span class="s1">self._progress_nodeids_reported: Set[str] = set()</span>
        <span class="s1">self._show_progress_info = self._determine_show_progress_info()</span>
        <span class="s1">self._collect_report_last_write: Optional[float] = </span><span class="s2">None</span>
        <span class="s1">self._already_displayed_warnings: Optional[int] = </span><span class="s2">None</span>
        <span class="s1">self._keyboardinterrupt_memo: Optional[ExceptionRepr] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_determine_show_progress_info(self) -&gt; </span><span class="s4">&quot;Literal['progress', 'count', False]&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Return whether we should display progress information based on the current config.&quot;&quot;&quot;</span>
        <span class="s0"># do not show progress if we are not capturing output (#3038)</span>
        <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s4">&quot;capture&quot;</span><span class="s1">, </span><span class="s4">&quot;no&quot;</span><span class="s1">) == </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s0"># do not show progress if we are showing fixture setup/teardown</span>
        <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s4">&quot;setupshow&quot;</span><span class="s1">, </span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">return False</span>
        <span class="s1">cfg: str = self.config.getini(</span><span class="s4">&quot;console_output_style&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">cfg == </span><span class="s4">&quot;progress&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;progress&quot;</span>
        <span class="s2">elif </span><span class="s1">cfg == </span><span class="s4">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;count&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">verbosity(self) -&gt; int:</span>
        <span class="s1">verbosity: int = self.config.option.verbose</span>
        <span class="s2">return </span><span class="s1">verbosity</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">showheader(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.verbosity &gt;= </span><span class="s3">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">no_header(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.config.option.no_header)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">no_summary(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">bool(self.config.option.no_summary)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">showfspath(self) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">self._showfspath </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.verbosity &gt;= </span><span class="s3">0</span>
        <span class="s2">return </span><span class="s1">self._showfspath</span>

    <span class="s1">@showfspath.setter</span>
    <span class="s2">def </span><span class="s1">showfspath(self, value: Optional[bool]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._showfspath = value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">showlongtestinfo(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.verbosity &gt; </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">hasopt(self, char: str) -&gt; bool:</span>
        <span class="s1">char = {</span><span class="s4">&quot;xfailed&quot;</span><span class="s1">: </span><span class="s4">&quot;x&quot;</span><span class="s1">, </span><span class="s4">&quot;skipped&quot;</span><span class="s1">: </span><span class="s4">&quot;s&quot;</span><span class="s1">}.get(char, char)</span>
        <span class="s2">return </span><span class="s1">char </span><span class="s2">in </span><span class="s1">self.reportchars</span>

    <span class="s2">def </span><span class="s1">write_fspath_result(self, nodeid: str, res, **markup: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">fspath = self.config.rootpath / nodeid.split(</span><span class="s4">&quot;::&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self.currentfspath </span><span class="s2">is None or </span><span class="s1">fspath != self.currentfspath:</span>
            <span class="s2">if </span><span class="s1">self.currentfspath </span><span class="s2">is not None and </span><span class="s1">self._show_progress_info:</span>
                <span class="s1">self._write_progress_information_filling_space()</span>
            <span class="s1">self.currentfspath = fspath</span>
            <span class="s1">relfspath = bestrelpath(self.startpath, fspath)</span>
            <span class="s1">self._tw.line()</span>
            <span class="s1">self._tw.write(relfspath + </span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
        <span class="s1">self._tw.write(res, flush=</span><span class="s2">True</span><span class="s1">, **markup)</span>

    <span class="s2">def </span><span class="s1">write_ensure_prefix(self, prefix: str, extra: str = </span><span class="s4">&quot;&quot;</span><span class="s1">, **kwargs) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.currentfspath != prefix:</span>
            <span class="s1">self._tw.line()</span>
            <span class="s1">self.currentfspath = prefix</span>
            <span class="s1">self._tw.write(prefix)</span>
        <span class="s2">if </span><span class="s1">extra:</span>
            <span class="s1">self._tw.write(extra, **kwargs)</span>
            <span class="s1">self.currentfspath = -</span><span class="s3">2</span>

    <span class="s2">def </span><span class="s1">ensure_newline(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.currentfspath:</span>
            <span class="s1">self._tw.line()</span>
            <span class="s1">self.currentfspath = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">write(self, content: str, *, flush: bool = </span><span class="s2">False</span><span class="s1">, **markup: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._tw.write(content, flush=flush, **markup)</span>

    <span class="s2">def </span><span class="s1">flush(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._tw.flush()</span>

    <span class="s2">def </span><span class="s1">write_line(self, line: Union[str, bytes], **markup: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(line, str):</span>
            <span class="s1">line = str(line, errors=</span><span class="s4">&quot;replace&quot;</span><span class="s1">)</span>
        <span class="s1">self.ensure_newline()</span>
        <span class="s1">self._tw.line(line, **markup)</span>

    <span class="s2">def </span><span class="s1">rewrite(self, line: str, **markup: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Rewinds the terminal cursor to the beginning and writes the given line. 
 
        :param erase: 
            If True, will also add spaces until the full terminal width to ensure 
            previous lines are properly erased. 
 
        The rest of the keyword arguments are markup instructions. 
        &quot;&quot;&quot;</span>
        <span class="s1">erase = markup.pop(</span><span class="s4">&quot;erase&quot;</span><span class="s1">, </span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">erase:</span>
            <span class="s1">fill_count = self._tw.fullwidth - len(line) - </span><span class="s3">1</span>
            <span class="s1">fill = </span><span class="s4">&quot; &quot; </span><span class="s1">* fill_count</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fill = </span><span class="s4">&quot;&quot;</span>
        <span class="s1">line = str(line)</span>
        <span class="s1">self._tw.write(</span><span class="s4">&quot;</span><span class="s5">\r</span><span class="s4">&quot; </span><span class="s1">+ line + fill, **markup)</span>

    <span class="s2">def </span><span class="s1">write_sep(</span>
        <span class="s1">self,</span>
        <span class="s1">sep: str,</span>
        <span class="s1">title: Optional[str] = </span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">fullwidth: Optional[int] = </span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">**markup: bool,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.ensure_newline()</span>
        <span class="s1">self._tw.sep(sep, title, fullwidth, **markup)</span>

    <span class="s2">def </span><span class="s1">section(self, title: str, sep: str = </span><span class="s4">&quot;=&quot;</span><span class="s1">, **kw: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._tw.sep(sep, title, **kw)</span>

    <span class="s2">def </span><span class="s1">line(self, msg: str, **kw: bool) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._tw.line(msg, **kw)</span>

    <span class="s2">def </span><span class="s1">_add_stats(self, category: str, items: Sequence[Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">set_main_color = category </span><span class="s2">not in </span><span class="s1">self.stats</span>
        <span class="s1">self.stats.setdefault(category, []).extend(items)</span>
        <span class="s2">if </span><span class="s1">set_main_color:</span>
            <span class="s1">self._set_main_color()</span>

    <span class="s2">def </span><span class="s1">pytest_internalerror(self, excrepr: ExceptionRepr) -&gt; bool:</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">str(excrepr).split(</span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">):</span>
            <span class="s1">self.write_line(</span><span class="s4">&quot;INTERNALERROR&gt; &quot; </span><span class="s1">+ line)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">pytest_warning_recorded(</span>
        <span class="s1">self, warning_message: warnings.WarningMessage, nodeid: str,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">_pytest.warnings </span><span class="s2">import </span><span class="s1">warning_record_to_str</span>

        <span class="s1">fslocation = warning_message.filename, warning_message.lineno</span>
        <span class="s1">message = warning_record_to_str(warning_message)</span>

        <span class="s1">warning_report = WarningReport(</span>
            <span class="s1">fslocation=fslocation, message=message, nodeid=nodeid</span>
        <span class="s1">)</span>
        <span class="s1">self._add_stats(</span><span class="s4">&quot;warnings&quot;</span><span class="s1">, [warning_report])</span>

    <span class="s2">def </span><span class="s1">pytest_plugin_registered(self, plugin: _PluggyPlugin) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.config.option.traceconfig:</span>
            <span class="s1">msg = </span><span class="s4">f&quot;PLUGIN registered: </span><span class="s5">{</span><span class="s1">plugin</span><span class="s5">}</span><span class="s4">&quot;</span>
            <span class="s0"># XXX This event may happen during setup/teardown time</span>
            <span class="s0">#     which unfortunately captures our output here</span>
            <span class="s0">#     which garbles our output if we use self.write_line.</span>
            <span class="s1">self.write_line(msg)</span>

    <span class="s2">def </span><span class="s1">pytest_deselected(self, items: Sequence[Item]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._add_stats(</span><span class="s4">&quot;deselected&quot;</span><span class="s1">, items)</span>

    <span class="s2">def </span><span class="s1">pytest_runtest_logstart(</span>
        <span class="s1">self, nodeid: str, location: Tuple[str, Optional[int], str]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0"># Ensure that the path is printed before the</span>
        <span class="s0"># 1st test of a module starts running.</span>
        <span class="s2">if </span><span class="s1">self.showlongtestinfo:</span>
            <span class="s1">line = self._locationline(nodeid, *location)</span>
            <span class="s1">self.write_ensure_prefix(line, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.flush()</span>
        <span class="s2">elif </span><span class="s1">self.showfspath:</span>
            <span class="s1">self.write_fspath_result(nodeid, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.flush()</span>

    <span class="s2">def </span><span class="s1">pytest_runtest_logreport(self, report: TestReport) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._tests_ran = </span><span class="s2">True</span>
        <span class="s1">rep = report</span>
        <span class="s1">res: Tuple[</span>
            <span class="s1">str, str, Union[str, Tuple[str, Mapping[str, bool]]]</span>
        <span class="s1">] = self.config.hook.pytest_report_teststatus(report=rep, config=self.config)</span>
        <span class="s1">category, letter, word = res</span>
        <span class="s2">if not </span><span class="s1">isinstance(word, tuple):</span>
            <span class="s1">markup = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">word, markup = word</span>
        <span class="s1">self._add_stats(category, [rep])</span>
        <span class="s2">if not </span><span class="s1">letter </span><span class="s2">and not </span><span class="s1">word:</span>
            <span class="s0"># Probably passed setup/teardown.</span>
            <span class="s2">return</span>
        <span class="s1">running_xdist = hasattr(rep, </span><span class="s4">&quot;node&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">markup </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">was_xfail = hasattr(report, </span><span class="s4">&quot;wasxfail&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">rep.passed </span><span class="s2">and not </span><span class="s1">was_xfail:</span>
                <span class="s1">markup = {</span><span class="s4">&quot;green&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
            <span class="s2">elif </span><span class="s1">rep.passed </span><span class="s2">and </span><span class="s1">was_xfail:</span>
                <span class="s1">markup = {</span><span class="s4">&quot;yellow&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
            <span class="s2">elif </span><span class="s1">rep.failed:</span>
                <span class="s1">markup = {</span><span class="s4">&quot;red&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
            <span class="s2">elif </span><span class="s1">rep.skipped:</span>
                <span class="s1">markup = {</span><span class="s4">&quot;yellow&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">}</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">markup = {}</span>
        <span class="s2">if </span><span class="s1">self.verbosity &lt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self._tw.write(letter, **markup)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._progress_nodeids_reported.add(rep.nodeid)</span>
            <span class="s1">line = self._locationline(rep.nodeid, *rep.location)</span>
            <span class="s2">if not </span><span class="s1">running_xdist:</span>
                <span class="s1">self.write_ensure_prefix(line, word, **markup)</span>
                <span class="s2">if </span><span class="s1">rep.skipped </span><span class="s2">or </span><span class="s1">hasattr(report, </span><span class="s4">&quot;wasxfail&quot;</span><span class="s1">):</span>
                    <span class="s1">available_width = (</span>
                        <span class="s1">(self._tw.fullwidth - self._tw.width_of_current_line)</span>
                        <span class="s1">- len(</span><span class="s4">&quot; [100%]&quot;</span><span class="s1">)</span>
                        <span class="s1">- </span><span class="s3">1</span>
                    <span class="s1">)</span>
                    <span class="s1">reason = _get_raw_skip_reason(rep)</span>
                    <span class="s1">reason_ = _format_trimmed(</span><span class="s4">&quot; ({})&quot;</span><span class="s1">, reason, available_width)</span>
                    <span class="s2">if </span><span class="s1">reason </span><span class="s2">and </span><span class="s1">reason_ </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">self._tw.write(reason_)</span>
                <span class="s2">if </span><span class="s1">self._show_progress_info:</span>
                    <span class="s1">self._write_progress_information_filling_space()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.ensure_newline()</span>
                <span class="s1">self._tw.write(</span><span class="s4">&quot;[%s]&quot; </span><span class="s1">% rep.node.gateway.id)</span>
                <span class="s2">if </span><span class="s1">self._show_progress_info:</span>
                    <span class="s1">self._tw.write(</span>
                        <span class="s1">self._get_progress_information_message() + </span><span class="s4">&quot; &quot;</span><span class="s1">, cyan=</span><span class="s2">True</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._tw.write(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
                <span class="s1">self._tw.write(word, **markup)</span>
                <span class="s1">self._tw.write(</span><span class="s4">&quot; &quot; </span><span class="s1">+ line)</span>
                <span class="s1">self.currentfspath = -</span><span class="s3">2</span>
        <span class="s1">self.flush()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_last_item(self) -&gt; bool:</span>
        <span class="s2">assert </span><span class="s1">self._session </span><span class="s2">is not None</span>
        <span class="s2">return </span><span class="s1">len(self._progress_nodeids_reported) == self._session.testscollected</span>

    <span class="s2">def </span><span class="s1">pytest_runtest_logfinish(self, nodeid: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">self._session</span>
        <span class="s2">if </span><span class="s1">self.verbosity &lt;= </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self._show_progress_info:</span>
            <span class="s2">if </span><span class="s1">self._show_progress_info == </span><span class="s4">&quot;count&quot;</span><span class="s1">:</span>
                <span class="s1">num_tests = self._session.testscollected</span>
                <span class="s1">progress_length = len(</span><span class="s4">&quot; [{}/{}]&quot;</span><span class="s1">.format(str(num_tests), str(num_tests)))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">progress_length = len(</span><span class="s4">&quot; [100%]&quot;</span><span class="s1">)</span>

            <span class="s1">self._progress_nodeids_reported.add(nodeid)</span>

            <span class="s2">if </span><span class="s1">self._is_last_item:</span>
                <span class="s1">self._write_progress_information_filling_space()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">main_color, _ = self._get_main_color()</span>
                <span class="s1">w = self._width_of_current_line</span>
                <span class="s1">past_edge = w + progress_length + </span><span class="s3">1 </span><span class="s1">&gt;= self._screen_width</span>
                <span class="s2">if </span><span class="s1">past_edge:</span>
                    <span class="s1">msg = self._get_progress_information_message()</span>
                    <span class="s1">self._tw.write(msg + </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">, **{main_color: </span><span class="s2">True</span><span class="s1">})</span>

    <span class="s2">def </span><span class="s1">_get_progress_information_message(self) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">self._session</span>
        <span class="s1">collected = self._session.testscollected</span>
        <span class="s2">if </span><span class="s1">self._show_progress_info == </span><span class="s4">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">collected:</span>
                <span class="s1">progress = self._progress_nodeids_reported</span>
                <span class="s1">counter_format = </span><span class="s4">&quot;{{:{}d}}&quot;</span><span class="s1">.format(len(str(collected)))</span>
                <span class="s1">format_string = </span><span class="s4">f&quot; [</span><span class="s5">{</span><span class="s1">counter_format</span><span class="s5">}</span><span class="s4">/{{}}]&quot;</span>
                <span class="s2">return </span><span class="s1">format_string.format(len(progress), collected)</span>
            <span class="s2">return </span><span class="s4">f&quot; [ </span><span class="s5">{</span><span class="s1">collected</span><span class="s5">} </span><span class="s4">/ </span><span class="s5">{</span><span class="s1">collected</span><span class="s5">} </span><span class="s4">]&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">collected:</span>
                <span class="s2">return </span><span class="s4">&quot; [{:3d}%]&quot;</span><span class="s1">.format(</span>
                    <span class="s1">len(self._progress_nodeids_reported) * </span><span class="s3">100 </span><span class="s1">// collected</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s4">&quot; [100%]&quot;</span>

    <span class="s2">def </span><span class="s1">_write_progress_information_filling_space(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">color, _ = self._get_main_color()</span>
        <span class="s1">msg = self._get_progress_information_message()</span>
        <span class="s1">w = self._width_of_current_line</span>
        <span class="s1">fill = self._tw.fullwidth - w - </span><span class="s3">1</span>
        <span class="s1">self.write(msg.rjust(fill), flush=</span><span class="s2">True</span><span class="s1">, **{color: </span><span class="s2">True</span><span class="s1">})</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_width_of_current_line(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Return the width of the current line.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._tw.width_of_current_line</span>

    <span class="s2">def </span><span class="s1">pytest_collection(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.isatty:</span>
            <span class="s2">if </span><span class="s1">self.config.option.verbose &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;collecting ... &quot;</span><span class="s1">, flush=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">self._collect_report_last_write = timing.time()</span>
        <span class="s2">elif </span><span class="s1">self.config.option.verbose &gt;= </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot;collecting ... &quot;</span><span class="s1">, flush=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">pytest_collectreport(self, report: CollectReport) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">report.failed:</span>
            <span class="s1">self._add_stats(</span><span class="s4">&quot;error&quot;</span><span class="s1">, [report])</span>
        <span class="s2">elif </span><span class="s1">report.skipped:</span>
            <span class="s1">self._add_stats(</span><span class="s4">&quot;skipped&quot;</span><span class="s1">, [report])</span>
        <span class="s1">items = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">report.result </span><span class="s2">if </span><span class="s1">isinstance(x, Item)]</span>
        <span class="s1">self._numcollected += len(items)</span>
        <span class="s2">if </span><span class="s1">self.isatty:</span>
            <span class="s1">self.report_collect()</span>

    <span class="s2">def </span><span class="s1">report_collect(self, final: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.config.option.verbose &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">final:</span>
            <span class="s0"># Only write &quot;collecting&quot; report every 0.5s.</span>
            <span class="s1">t = timing.time()</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self._collect_report_last_write </span><span class="s2">is not None</span>
                <span class="s2">and </span><span class="s1">self._collect_report_last_write &gt; t - REPORT_COLLECTING_RESOLUTION</span>
            <span class="s1">):</span>
                <span class="s2">return</span>
            <span class="s1">self._collect_report_last_write = t</span>

        <span class="s1">errors = len(self.stats.get(</span><span class="s4">&quot;error&quot;</span><span class="s1">, []))</span>
        <span class="s1">skipped = len(self.stats.get(</span><span class="s4">&quot;skipped&quot;</span><span class="s1">, []))</span>
        <span class="s1">deselected = len(self.stats.get(</span><span class="s4">&quot;deselected&quot;</span><span class="s1">, []))</span>
        <span class="s1">selected = self._numcollected - errors - skipped - deselected</span>
        <span class="s2">if </span><span class="s1">final:</span>
            <span class="s1">line = </span><span class="s4">&quot;collected &quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">line = </span><span class="s4">&quot;collecting &quot;</span>
        <span class="s1">line += (</span>
            <span class="s1">str(self._numcollected) + </span><span class="s4">&quot; item&quot; </span><span class="s1">+ (</span><span class="s4">&quot;&quot; </span><span class="s2">if </span><span class="s1">self._numcollected == </span><span class="s3">1 </span><span class="s2">else </span><span class="s4">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">errors:</span>
            <span class="s1">line += </span><span class="s4">&quot; / %d error%s&quot; </span><span class="s1">% (errors, </span><span class="s4">&quot;s&quot; </span><span class="s2">if </span><span class="s1">errors != </span><span class="s3">1 </span><span class="s2">else </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">deselected:</span>
            <span class="s1">line += </span><span class="s4">&quot; / %d deselected&quot; </span><span class="s1">% deselected</span>
        <span class="s2">if </span><span class="s1">skipped:</span>
            <span class="s1">line += </span><span class="s4">&quot; / %d skipped&quot; </span><span class="s1">% skipped</span>
        <span class="s2">if </span><span class="s1">self._numcollected &gt; selected &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">line += </span><span class="s4">&quot; / %d selected&quot; </span><span class="s1">% selected</span>
        <span class="s2">if </span><span class="s1">self.isatty:</span>
            <span class="s1">self.rewrite(line, bold=</span><span class="s2">True</span><span class="s1">, erase=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">final:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_line(line)</span>

    <span class="s1">@hookimpl(trylast=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_sessionstart(self, session: </span><span class="s4">&quot;Session&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._session = session</span>
        <span class="s1">self._sessionstarttime = timing.time()</span>
        <span class="s2">if not </span><span class="s1">self.showheader:</span>
            <span class="s2">return</span>
        <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, </span><span class="s4">&quot;test session starts&quot;</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">verinfo = platform.python_version()</span>
        <span class="s2">if not </span><span class="s1">self.no_header:</span>
            <span class="s1">msg = </span><span class="s4">f&quot;platform </span><span class="s5">{</span><span class="s1">sys.platform</span><span class="s5">} </span><span class="s4">-- Python </span><span class="s5">{</span><span class="s1">verinfo</span><span class="s5">}</span><span class="s4">&quot;</span>
            <span class="s1">pypy_version_info = getattr(sys, </span><span class="s4">&quot;pypy_version_info&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">pypy_version_info:</span>
                <span class="s1">verinfo = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(map(str, pypy_version_info[:</span><span class="s3">3</span><span class="s1">]))</span>
                <span class="s1">msg += </span><span class="s4">&quot;[pypy-{}-{}]&quot;</span><span class="s1">.format(verinfo, pypy_version_info[</span><span class="s3">3</span><span class="s1">])</span>
            <span class="s1">msg += </span><span class="s4">&quot;, pytest-{}, py-{}, pluggy-{}&quot;</span><span class="s1">.format(</span>
                <span class="s1">_pytest._version.version, py.__version__, pluggy.__version__</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.verbosity &gt; </span><span class="s3">0</span>
                <span class="s2">or </span><span class="s1">self.config.option.debug</span>
                <span class="s2">or </span><span class="s1">getattr(self.config.option, </span><span class="s4">&quot;pastebin&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s1">msg += </span><span class="s4">&quot; -- &quot; </span><span class="s1">+ str(sys.executable)</span>
            <span class="s1">self.write_line(msg)</span>
            <span class="s1">lines = self.config.hook.pytest_report_header(</span>
                <span class="s1">config=self.config, startdir=self.startdir</span>
            <span class="s1">)</span>
            <span class="s1">self._write_report_lines_from_hooks(lines)</span>

    <span class="s2">def </span><span class="s1">_write_report_lines_from_hooks(</span>
        <span class="s1">self, lines: Sequence[Union[str, Sequence[str]]]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">line_or_lines </span><span class="s2">in </span><span class="s1">reversed(lines):</span>
            <span class="s2">if </span><span class="s1">isinstance(line_or_lines, str):</span>
                <span class="s1">self.write_line(line_or_lines)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">line_or_lines:</span>
                    <span class="s1">self.write_line(line)</span>

    <span class="s2">def </span><span class="s1">pytest_report_header(self, config: Config) -&gt; List[str]:</span>
        <span class="s1">line = </span><span class="s4">&quot;rootdir: %s&quot; </span><span class="s1">% config.rootpath</span>

        <span class="s2">if </span><span class="s1">config.inipath:</span>
            <span class="s1">line += </span><span class="s4">&quot;, configfile: &quot; </span><span class="s1">+ bestrelpath(config.rootpath, config.inipath)</span>

        <span class="s1">testpaths: List[str] = config.getini(</span><span class="s4">&quot;testpaths&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">config.invocation_params.dir == config.rootpath </span><span class="s2">and </span><span class="s1">config.args == testpaths:</span>
            <span class="s1">line += </span><span class="s4">&quot;, testpaths: {}&quot;</span><span class="s1">.format(</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(testpaths))</span>

        <span class="s1">result = [line]</span>

        <span class="s1">plugininfo = config.pluginmanager.list_plugin_distinfo()</span>
        <span class="s2">if </span><span class="s1">plugininfo:</span>
            <span class="s1">result.append(</span><span class="s4">&quot;plugins: %s&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_plugin_nameversions(plugininfo)))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">pytest_collection_finish(self, session: </span><span class="s4">&quot;Session&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.report_collect(</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">lines = self.config.hook.pytest_report_collectionfinish(</span>
            <span class="s1">config=self.config, startdir=self.startdir, items=session.items</span>
        <span class="s1">)</span>
        <span class="s1">self._write_report_lines_from_hooks(lines)</span>

        <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s4">&quot;collectonly&quot;</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">session.items:</span>
                <span class="s2">if </span><span class="s1">self.config.option.verbose &gt; -</span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">self._tw.line(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">self._printcollecteditems(session.items)</span>

            <span class="s1">failed = self.stats.get(</span><span class="s4">&quot;failed&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">failed:</span>
                <span class="s1">self._tw.sep(</span><span class="s4">&quot;!&quot;</span><span class="s1">, </span><span class="s4">&quot;collection failures&quot;</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">failed:</span>
                    <span class="s1">rep.toterminal(self._tw)</span>

    <span class="s2">def </span><span class="s1">_printcollecteditems(self, items: Sequence[Item]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0"># To print out items and their parent collectors</span>
        <span class="s0"># we take care to leave out Instances aka ()</span>
        <span class="s0"># because later versions are going to get rid of them anyway.</span>
        <span class="s2">if </span><span class="s1">self.config.option.verbose &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.config.option.verbose &lt; -</span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">counts = Counter(item.nodeid.split(</span><span class="s4">&quot;::&quot;</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items)</span>
                <span class="s2">for </span><span class="s1">name, count </span><span class="s2">in </span><span class="s1">sorted(counts.items()):</span>
                    <span class="s1">self._tw.line(</span><span class="s4">&quot;%s: %d&quot; </span><span class="s1">% (name, count))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items:</span>
                    <span class="s1">self._tw.line(item.nodeid)</span>
            <span class="s2">return</span>
        <span class="s1">stack: List[Node] = []</span>
        <span class="s1">indent = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s1">needed_collectors = item.listchain()[</span><span class="s3">1</span><span class="s1">:]  </span><span class="s0"># strip root node</span>
            <span class="s2">while </span><span class="s1">stack:</span>
                <span class="s2">if </span><span class="s1">stack == needed_collectors[: len(stack)]:</span>
                    <span class="s2">break</span>
                <span class="s1">stack.pop()</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">needed_collectors[len(stack) :]:</span>
                <span class="s1">stack.append(col)</span>
                <span class="s2">if </span><span class="s1">col.name == </span><span class="s4">&quot;()&quot;</span><span class="s1">:  </span><span class="s0"># Skip Instances.</span>
                    <span class="s2">continue</span>
                <span class="s1">indent = (len(stack) - </span><span class="s3">1</span><span class="s1">) * </span><span class="s4">&quot;  &quot;</span>
                <span class="s1">self._tw.line(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">indent</span><span class="s5">}{</span><span class="s1">col</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.config.option.verbose &gt;= </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">obj = getattr(col, </span><span class="s4">&quot;obj&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s1">doc = inspect.getdoc(obj) </span><span class="s2">if </span><span class="s1">obj </span><span class="s2">else None</span>
                    <span class="s2">if </span><span class="s1">doc:</span>
                        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">doc.splitlines():</span>
                            <span class="s1">self._tw.line(</span><span class="s4">&quot;{}{}&quot;</span><span class="s1">.format(indent + </span><span class="s4">&quot;  &quot;</span><span class="s1">, line))</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_sessionfinish(</span>
        <span class="s1">self, session: </span><span class="s4">&quot;Session&quot;</span><span class="s1">, exitstatus: Union[int, ExitCode]</span>
    <span class="s1">):</span>
        <span class="s1">outcome = </span><span class="s2">yield</span>
        <span class="s1">outcome.get_result()</span>
        <span class="s1">self._tw.line(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">summary_exit_codes = (</span>
            <span class="s1">ExitCode.OK,</span>
            <span class="s1">ExitCode.TESTS_FAILED,</span>
            <span class="s1">ExitCode.INTERRUPTED,</span>
            <span class="s1">ExitCode.USAGE_ERROR,</span>
            <span class="s1">ExitCode.NO_TESTS_COLLECTED,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exitstatus </span><span class="s2">in </span><span class="s1">summary_exit_codes </span><span class="s2">and not </span><span class="s1">self.no_summary:</span>
            <span class="s1">self.config.hook.pytest_terminal_summary(</span>
                <span class="s1">terminalreporter=self, exitstatus=exitstatus, config=self.config</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">session.shouldfail:</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;!&quot;</span><span class="s1">, str(session.shouldfail), red=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">exitstatus == ExitCode.INTERRUPTED:</span>
            <span class="s1">self._report_keyboardinterrupt()</span>
            <span class="s1">self._keyboardinterrupt_memo = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">session.shouldstop:</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;!&quot;</span><span class="s1">, str(session.shouldstop), red=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.summary_stats()</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_terminal_summary(self) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s1">self.summary_errors()</span>
        <span class="s1">self.summary_failures()</span>
        <span class="s1">self.summary_warnings()</span>
        <span class="s1">self.summary_passes()</span>
        <span class="s2">yield</span>
        <span class="s1">self.short_test_summary()</span>
        <span class="s0"># Display any extra warnings from teardown here (if any).</span>
        <span class="s1">self.summary_warnings()</span>

    <span class="s2">def </span><span class="s1">pytest_keyboard_interrupt(self, excinfo: ExceptionInfo[BaseException]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._keyboardinterrupt_memo = excinfo.getrepr(funcargs=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">pytest_unconfigure(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._keyboardinterrupt_memo </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._report_keyboardinterrupt()</span>

    <span class="s2">def </span><span class="s1">_report_keyboardinterrupt(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">excrepr = self._keyboardinterrupt_memo</span>
        <span class="s2">assert </span><span class="s1">excrepr </span><span class="s2">is not None</span>
        <span class="s2">assert </span><span class="s1">excrepr.reprcrash </span><span class="s2">is not None</span>
        <span class="s1">msg = excrepr.reprcrash.message</span>
        <span class="s1">self.write_sep(</span><span class="s4">&quot;!&quot;</span><span class="s1">, msg)</span>
        <span class="s2">if </span><span class="s4">&quot;KeyboardInterrupt&quot; </span><span class="s2">in </span><span class="s1">msg:</span>
            <span class="s2">if </span><span class="s1">self.config.option.fulltrace:</span>
                <span class="s1">excrepr.toterminal(self._tw)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">excrepr.reprcrash.toterminal(self._tw)</span>
                <span class="s1">self._tw.line(</span>
                    <span class="s4">&quot;(to show a full traceback on KeyboardInterrupt use --full-trace)&quot;</span><span class="s1">,</span>
                    <span class="s1">yellow=</span><span class="s2">True</span><span class="s1">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_locationline(self, nodeid, fspath, lineno, domain):</span>
        <span class="s2">def </span><span class="s1">mkrel(nodeid):</span>
            <span class="s1">line = self.config.cwd_relative_nodeid(nodeid)</span>
            <span class="s2">if </span><span class="s1">domain </span><span class="s2">and </span><span class="s1">line.endswith(domain):</span>
                <span class="s1">line = line[: -len(domain)]</span>
                <span class="s1">values = domain.split(</span><span class="s4">&quot;[&quot;</span><span class="s1">)</span>
                <span class="s1">values[</span><span class="s3">0</span><span class="s1">] = values[</span><span class="s3">0</span><span class="s1">].replace(</span><span class="s4">&quot;.&quot;</span><span class="s1">, </span><span class="s4">&quot;::&quot;</span><span class="s1">)  </span><span class="s0"># don't replace '.' in params</span>
                <span class="s1">line += </span><span class="s4">&quot;[&quot;</span><span class="s1">.join(values)</span>
            <span class="s2">return </span><span class="s1">line</span>

        <span class="s0"># collect_fspath comes from testid which has a &quot;/&quot;-normalized path.</span>

        <span class="s2">if </span><span class="s1">fspath:</span>
            <span class="s1">res = mkrel(nodeid)</span>
            <span class="s2">if </span><span class="s1">self.verbosity &gt;= </span><span class="s3">2 </span><span class="s2">and </span><span class="s1">nodeid.split(</span><span class="s4">&quot;::&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] != fspath.replace(</span>
                <span class="s4">&quot;</span><span class="s5">\\</span><span class="s4">&quot;</span><span class="s1">, nodes.SEP</span>
            <span class="s1">):</span>
                <span class="s1">res += </span><span class="s4">&quot; &lt;- &quot; </span><span class="s1">+ bestrelpath(self.startpath, fspath)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">res = </span><span class="s4">&quot;[location]&quot;</span>
        <span class="s2">return </span><span class="s1">res + </span><span class="s4">&quot; &quot;</span>

    <span class="s2">def </span><span class="s1">_getfailureheadline(self, rep):</span>
        <span class="s1">head_line = rep.head_line</span>
        <span class="s2">if </span><span class="s1">head_line:</span>
            <span class="s2">return </span><span class="s1">head_line</span>
        <span class="s2">return </span><span class="s4">&quot;test session&quot;  </span><span class="s0"># XXX?</span>

    <span class="s2">def </span><span class="s1">_getcrashline(self, rep):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">str(rep.longrepr.reprcrash)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">str(rep.longrepr)[:</span><span class="s3">50</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">return </span><span class="s4">&quot;&quot;</span>

    <span class="s0">#</span>
    <span class="s0"># Summaries for sessionfinish.</span>
    <span class="s0">#</span>
    <span class="s2">def </span><span class="s1">getreports(self, name: str):</span>
        <span class="s1">values = []</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.stats.get(name, []):</span>
            <span class="s2">if not </span><span class="s1">hasattr(x, </span><span class="s4">&quot;_pdbshown&quot;</span><span class="s1">):</span>
                <span class="s1">values.append(x)</span>
        <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">def </span><span class="s1">summary_warnings(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.hasopt(</span><span class="s4">&quot;w&quot;</span><span class="s1">):</span>
            <span class="s1">all_warnings: Optional[List[WarningReport]] = self.stats.get(</span><span class="s4">&quot;warnings&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">all_warnings:</span>
                <span class="s2">return</span>

            <span class="s1">final = self._already_displayed_warnings </span><span class="s2">is not None</span>
            <span class="s2">if </span><span class="s1">final:</span>
                <span class="s1">warning_reports = all_warnings[self._already_displayed_warnings :]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">warning_reports = all_warnings</span>
            <span class="s1">self._already_displayed_warnings = len(warning_reports)</span>
            <span class="s2">if not </span><span class="s1">warning_reports:</span>
                <span class="s2">return</span>

            <span class="s1">reports_grouped_by_message: Dict[str, List[WarningReport]] = {}</span>
            <span class="s2">for </span><span class="s1">wr </span><span class="s2">in </span><span class="s1">warning_reports:</span>
                <span class="s1">reports_grouped_by_message.setdefault(wr.message, []).append(wr)</span>

            <span class="s2">def </span><span class="s1">collapsed_location_report(reports: List[WarningReport]) -&gt; str:</span>
                <span class="s1">locations = []</span>
                <span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">reports:</span>
                    <span class="s1">location = w.get_location(self.config)</span>
                    <span class="s2">if </span><span class="s1">location:</span>
                        <span class="s1">locations.append(location)</span>

                <span class="s2">if </span><span class="s1">len(locations) &lt; </span><span class="s3">10</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">.join(map(str, locations))</span>

                <span class="s1">counts_by_filename = Counter(</span>
                    <span class="s1">str(loc).split(</span><span class="s4">&quot;::&quot;</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">loc </span><span class="s2">in </span><span class="s1">locations</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span>
                    <span class="s4">&quot;{}: {} warning{}&quot;</span><span class="s1">.format(k, v, </span><span class="s4">&quot;s&quot; </span><span class="s2">if </span><span class="s1">v &gt; </span><span class="s3">1 </span><span class="s2">else </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">counts_by_filename.items()</span>
                <span class="s1">)</span>

            <span class="s1">title = </span><span class="s4">&quot;warnings summary (final)&quot; </span><span class="s2">if </span><span class="s1">final </span><span class="s2">else </span><span class="s4">&quot;warnings summary&quot;</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, title, yellow=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">message, message_reports </span><span class="s2">in </span><span class="s1">reports_grouped_by_message.items():</span>
                <span class="s1">maybe_location = collapsed_location_report(message_reports)</span>
                <span class="s2">if </span><span class="s1">maybe_location:</span>
                    <span class="s1">self._tw.line(maybe_location)</span>
                    <span class="s1">lines = message.splitlines()</span>
                    <span class="s1">indented = </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span><span class="s4">&quot;  &quot; </span><span class="s1">+ x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">lines)</span>
                    <span class="s1">message = indented.rstrip()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">message = message.rstrip()</span>
                <span class="s1">self._tw.line(message)</span>
                <span class="s1">self._tw.line()</span>
            <span class="s1">self._tw.line(</span><span class="s4">&quot;-- Docs: https://docs.pytest.org/en/stable/warnings.html&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">summary_passes(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.config.option.tbstyle != </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.hasopt(</span><span class="s4">&quot;P&quot;</span><span class="s1">):</span>
                <span class="s1">reports: List[TestReport] = self.getreports(</span><span class="s4">&quot;passed&quot;</span><span class="s1">)</span>
                <span class="s2">if not </span><span class="s1">reports:</span>
                    <span class="s2">return</span>
                <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, </span><span class="s4">&quot;PASSES&quot;</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">reports:</span>
                    <span class="s2">if </span><span class="s1">rep.sections:</span>
                        <span class="s1">msg = self._getfailureheadline(rep)</span>
                        <span class="s1">self.write_sep(</span><span class="s4">&quot;_&quot;</span><span class="s1">, msg, green=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>
                        <span class="s1">self._outrep_summary(rep)</span>
                    <span class="s1">self._handle_teardown_sections(rep.nodeid)</span>

    <span class="s2">def </span><span class="s1">_get_teardown_reports(self, nodeid: str) -&gt; List[TestReport]:</span>
        <span class="s1">reports = self.getreports(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">report</span>
            <span class="s2">for </span><span class="s1">report </span><span class="s2">in </span><span class="s1">reports</span>
            <span class="s2">if </span><span class="s1">report.when == </span><span class="s4">&quot;teardown&quot; </span><span class="s2">and </span><span class="s1">report.nodeid == nodeid</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_handle_teardown_sections(self, nodeid: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">report </span><span class="s2">in </span><span class="s1">self._get_teardown_reports(nodeid):</span>
            <span class="s1">self.print_teardown_sections(report)</span>

    <span class="s2">def </span><span class="s1">print_teardown_sections(self, rep: TestReport) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">showcapture = self.config.option.showcapture</span>
        <span class="s2">if </span><span class="s1">showcapture == </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">secname, content </span><span class="s2">in </span><span class="s1">rep.sections:</span>
            <span class="s2">if </span><span class="s1">showcapture != </span><span class="s4">&quot;all&quot; </span><span class="s2">and </span><span class="s1">showcapture </span><span class="s2">not in </span><span class="s1">secname:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s4">&quot;teardown&quot; </span><span class="s2">in </span><span class="s1">secname:</span>
                <span class="s1">self._tw.sep(</span><span class="s4">&quot;-&quot;</span><span class="s1">, secname)</span>
                <span class="s2">if </span><span class="s1">content[-</span><span class="s3">1</span><span class="s1">:] == </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
                    <span class="s1">content = content[:-</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">self._tw.line(content)</span>

    <span class="s2">def </span><span class="s1">summary_failures(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.config.option.tbstyle != </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s1">reports: List[BaseReport] = self.getreports(</span><span class="s4">&quot;failed&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">reports:</span>
                <span class="s2">return</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, </span><span class="s4">&quot;FAILURES&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.config.option.tbstyle == </span><span class="s4">&quot;line&quot;</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">reports:</span>
                    <span class="s1">line = self._getcrashline(rep)</span>
                    <span class="s1">self.write_line(line)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">reports:</span>
                    <span class="s1">msg = self._getfailureheadline(rep)</span>
                    <span class="s1">self.write_sep(</span><span class="s4">&quot;_&quot;</span><span class="s1">, msg, red=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">self._outrep_summary(rep)</span>
                    <span class="s1">self._handle_teardown_sections(rep.nodeid)</span>

    <span class="s2">def </span><span class="s1">summary_errors(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.config.option.tbstyle != </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s1">reports: List[BaseReport] = self.getreports(</span><span class="s4">&quot;error&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">reports:</span>
                <span class="s2">return</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, </span><span class="s4">&quot;ERRORS&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">self.stats[</span><span class="s4">&quot;error&quot;</span><span class="s1">]:</span>
                <span class="s1">msg = self._getfailureheadline(rep)</span>
                <span class="s2">if </span><span class="s1">rep.when == </span><span class="s4">&quot;collect&quot;</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;ERROR collecting &quot; </span><span class="s1">+ msg</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">msg = </span><span class="s4">f&quot;ERROR at </span><span class="s5">{</span><span class="s1">rep.when</span><span class="s5">} </span><span class="s4">of </span><span class="s5">{</span><span class="s1">msg</span><span class="s5">}</span><span class="s4">&quot;</span>
                <span class="s1">self.write_sep(</span><span class="s4">&quot;_&quot;</span><span class="s1">, msg, red=</span><span class="s2">True</span><span class="s1">, bold=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">self._outrep_summary(rep)</span>

    <span class="s2">def </span><span class="s1">_outrep_summary(self, rep: BaseReport) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">rep.toterminal(self._tw)</span>
        <span class="s1">showcapture = self.config.option.showcapture</span>
        <span class="s2">if </span><span class="s1">showcapture == </span><span class="s4">&quot;no&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">secname, content </span><span class="s2">in </span><span class="s1">rep.sections:</span>
            <span class="s2">if </span><span class="s1">showcapture != </span><span class="s4">&quot;all&quot; </span><span class="s2">and </span><span class="s1">showcapture </span><span class="s2">not in </span><span class="s1">secname:</span>
                <span class="s2">continue</span>
            <span class="s1">self._tw.sep(</span><span class="s4">&quot;-&quot;</span><span class="s1">, secname)</span>
            <span class="s2">if </span><span class="s1">content[-</span><span class="s3">1</span><span class="s1">:] == </span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">:</span>
                <span class="s1">content = content[:-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">self._tw.line(content)</span>

    <span class="s2">def </span><span class="s1">summary_stats(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self.verbosity &lt; -</span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">session_duration = timing.time() - self._sessionstarttime</span>
        <span class="s1">(parts, main_color) = self.build_summary_stats_line()</span>
        <span class="s1">line_parts = []</span>

        <span class="s1">display_sep = self.verbosity &gt;= </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">display_sep:</span>
            <span class="s1">fullwidth = self._tw.fullwidth</span>
        <span class="s2">for </span><span class="s1">text, markup </span><span class="s2">in </span><span class="s1">parts:</span>
            <span class="s1">with_markup = self._tw.markup(text, **markup)</span>
            <span class="s2">if </span><span class="s1">display_sep:</span>
                <span class="s1">fullwidth += len(with_markup) - len(text)</span>
            <span class="s1">line_parts.append(with_markup)</span>
        <span class="s1">msg = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(line_parts)</span>

        <span class="s1">main_markup = {main_color: </span><span class="s2">True</span><span class="s1">}</span>
        <span class="s1">duration = </span><span class="s4">&quot; in {}&quot;</span><span class="s1">.format(format_session_duration(session_duration))</span>
        <span class="s1">duration_with_markup = self._tw.markup(duration, **main_markup)</span>
        <span class="s2">if </span><span class="s1">display_sep:</span>
            <span class="s1">fullwidth += len(duration_with_markup) - len(duration)</span>
        <span class="s1">msg += duration_with_markup</span>

        <span class="s2">if </span><span class="s1">display_sep:</span>
            <span class="s1">markup_for_end_sep = self._tw.markup(</span><span class="s4">&quot;&quot;</span><span class="s1">, **main_markup)</span>
            <span class="s2">if </span><span class="s1">markup_for_end_sep.endswith(</span><span class="s4">&quot;</span><span class="s5">\x1b</span><span class="s4">[0m&quot;</span><span class="s1">):</span>
                <span class="s1">markup_for_end_sep = markup_for_end_sep[:-</span><span class="s3">4</span><span class="s1">]</span>
            <span class="s1">fullwidth += len(markup_for_end_sep)</span>
            <span class="s1">msg += markup_for_end_sep</span>

        <span class="s2">if </span><span class="s1">display_sep:</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, msg, fullwidth=fullwidth, **main_markup)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.write_line(msg, **main_markup)</span>

    <span class="s2">def </span><span class="s1">short_test_summary(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">self.reportchars:</span>
            <span class="s2">return</span>

        <span class="s2">def </span><span class="s1">show_simple(stat, lines: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">failed = self.stats.get(stat, [])</span>
            <span class="s2">if not </span><span class="s1">failed:</span>
                <span class="s2">return</span>
            <span class="s1">termwidth = self._tw.fullwidth</span>
            <span class="s1">config = self.config</span>
            <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">failed:</span>
                <span class="s1">line = _get_line_with_reprcrash_message(config, rep, termwidth)</span>
                <span class="s1">lines.append(line)</span>

        <span class="s2">def </span><span class="s1">show_xfailed(lines: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">xfailed = self.stats.get(</span><span class="s4">&quot;xfailed&quot;</span><span class="s1">, [])</span>
            <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">xfailed:</span>
                <span class="s1">verbose_word = rep._get_verbose_word(self.config)</span>
                <span class="s1">pos = _get_pos(self.config, rep)</span>
                <span class="s1">lines.append(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">verbose_word</span><span class="s5">} {</span><span class="s1">pos</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">reason = rep.wasxfail</span>
                <span class="s2">if </span><span class="s1">reason:</span>
                    <span class="s1">lines.append(</span><span class="s4">&quot;  &quot; </span><span class="s1">+ str(reason))</span>

        <span class="s2">def </span><span class="s1">show_xpassed(lines: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">xpassed = self.stats.get(</span><span class="s4">&quot;xpassed&quot;</span><span class="s1">, [])</span>
            <span class="s2">for </span><span class="s1">rep </span><span class="s2">in </span><span class="s1">xpassed:</span>
                <span class="s1">verbose_word = rep._get_verbose_word(self.config)</span>
                <span class="s1">pos = _get_pos(self.config, rep)</span>
                <span class="s1">reason = rep.wasxfail</span>
                <span class="s1">lines.append(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">verbose_word</span><span class="s5">} {</span><span class="s1">pos</span><span class="s5">} {</span><span class="s1">reason</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">show_skipped(lines: List[str]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
            <span class="s1">skipped: List[CollectReport] = self.stats.get(</span><span class="s4">&quot;skipped&quot;</span><span class="s1">, [])</span>
            <span class="s1">fskips = _folded_skips(self.startpath, skipped) </span><span class="s2">if </span><span class="s1">skipped </span><span class="s2">else </span><span class="s1">[]</span>
            <span class="s2">if not </span><span class="s1">fskips:</span>
                <span class="s2">return</span>
            <span class="s1">verbose_word = skipped[</span><span class="s3">0</span><span class="s1">]._get_verbose_word(self.config)</span>
            <span class="s2">for </span><span class="s1">num, fspath, lineno, reason </span><span class="s2">in </span><span class="s1">fskips:</span>
                <span class="s2">if </span><span class="s1">reason.startswith(</span><span class="s4">&quot;Skipped: &quot;</span><span class="s1">):</span>
                    <span class="s1">reason = reason[</span><span class="s3">9</span><span class="s1">:]</span>
                <span class="s2">if </span><span class="s1">lineno </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span>
                        <span class="s4">&quot;%s [%d] %s:%d: %s&quot;</span>
                        <span class="s1">% (verbose_word, num, fspath, lineno, reason)</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">lines.append(</span><span class="s4">&quot;%s [%d] %s: %s&quot; </span><span class="s1">% (verbose_word, num, fspath, reason))</span>

        <span class="s1">REPORTCHAR_ACTIONS: Mapping[str, Callable[[List[str]], </span><span class="s2">None</span><span class="s1">]] = {</span>
            <span class="s4">&quot;x&quot;</span><span class="s1">: show_xfailed,</span>
            <span class="s4">&quot;X&quot;</span><span class="s1">: show_xpassed,</span>
            <span class="s4">&quot;f&quot;</span><span class="s1">: partial(show_simple, </span><span class="s4">&quot;failed&quot;</span><span class="s1">),</span>
            <span class="s4">&quot;s&quot;</span><span class="s1">: show_skipped,</span>
            <span class="s4">&quot;p&quot;</span><span class="s1">: partial(show_simple, </span><span class="s4">&quot;passed&quot;</span><span class="s1">),</span>
            <span class="s4">&quot;E&quot;</span><span class="s1">: partial(show_simple, </span><span class="s4">&quot;error&quot;</span><span class="s1">),</span>
        <span class="s1">}</span>

        <span class="s1">lines: List[str] = []</span>
        <span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">self.reportchars:</span>
            <span class="s1">action = REPORTCHAR_ACTIONS.get(char)</span>
            <span class="s2">if </span><span class="s1">action:  </span><span class="s0"># skipping e.g. &quot;P&quot; (passed with output) here.</span>
                <span class="s1">action(lines)</span>

        <span class="s2">if </span><span class="s1">lines:</span>
            <span class="s1">self.write_sep(</span><span class="s4">&quot;=&quot;</span><span class="s1">, </span><span class="s4">&quot;short test summary info&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
                <span class="s1">self.write_line(line)</span>

    <span class="s2">def </span><span class="s1">_get_main_color(self) -&gt; Tuple[str, List[str]]:</span>
        <span class="s2">if </span><span class="s1">self._main_color </span><span class="s2">is None or </span><span class="s1">self._known_types </span><span class="s2">is None or </span><span class="s1">self._is_last_item:</span>
            <span class="s1">self._set_main_color()</span>
            <span class="s2">assert </span><span class="s1">self._main_color</span>
            <span class="s2">assert </span><span class="s1">self._known_types</span>
        <span class="s2">return </span><span class="s1">self._main_color, self._known_types</span>

    <span class="s2">def </span><span class="s1">_determine_main_color(self, unknown_type_seen: bool) -&gt; str:</span>
        <span class="s1">stats = self.stats</span>
        <span class="s2">if </span><span class="s4">&quot;failed&quot; </span><span class="s2">in </span><span class="s1">stats </span><span class="s2">or </span><span class="s4">&quot;error&quot; </span><span class="s2">in </span><span class="s1">stats:</span>
            <span class="s1">main_color = </span><span class="s4">&quot;red&quot;</span>
        <span class="s2">elif </span><span class="s4">&quot;warnings&quot; </span><span class="s2">in </span><span class="s1">stats </span><span class="s2">or </span><span class="s4">&quot;xpassed&quot; </span><span class="s2">in </span><span class="s1">stats </span><span class="s2">or </span><span class="s1">unknown_type_seen:</span>
            <span class="s1">main_color = </span><span class="s4">&quot;yellow&quot;</span>
        <span class="s2">elif </span><span class="s4">&quot;passed&quot; </span><span class="s2">in </span><span class="s1">stats </span><span class="s2">or not </span><span class="s1">self._is_last_item:</span>
            <span class="s1">main_color = </span><span class="s4">&quot;green&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">main_color = </span><span class="s4">&quot;yellow&quot;</span>
        <span class="s2">return </span><span class="s1">main_color</span>

    <span class="s2">def </span><span class="s1">_set_main_color(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">unknown_types: List[str] = []</span>
        <span class="s2">for </span><span class="s1">found_type </span><span class="s2">in </span><span class="s1">self.stats.keys():</span>
            <span class="s2">if </span><span class="s1">found_type:  </span><span class="s0"># setup/teardown reports have an empty key, ignore them</span>
                <span class="s2">if </span><span class="s1">found_type </span><span class="s2">not in </span><span class="s1">KNOWN_TYPES </span><span class="s2">and </span><span class="s1">found_type </span><span class="s2">not in </span><span class="s1">unknown_types:</span>
                    <span class="s1">unknown_types.append(found_type)</span>
        <span class="s1">self._known_types = list(KNOWN_TYPES) + unknown_types</span>
        <span class="s1">self._main_color = self._determine_main_color(bool(unknown_types))</span>

    <span class="s2">def </span><span class="s1">build_summary_stats_line(self) -&gt; Tuple[List[Tuple[str, Dict[str, bool]]], str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Build the parts used in the last summary stats line. 
 
        The summary stats line is the line shown at the end, &quot;=== 12 passed, 2 errors in Xs===&quot;. 
 
        This function builds a list of the &quot;parts&quot; that make up for the text in that line, in 
        the example above it would be: 
 
            [ 
                (&quot;12 passed&quot;, {&quot;green&quot;: True}), 
                (&quot;2 errors&quot;, {&quot;red&quot;: True} 
            ] 
 
        That last dict for each line is a &quot;markup dictionary&quot;, used by TerminalWriter to 
        color output. 
 
        The final color of the line is also determined by this function, and is the second 
        element of the returned tuple. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s4">&quot;collectonly&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._build_collect_only_summary_stats_line()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._build_normal_summary_stats_line()</span>

    <span class="s2">def </span><span class="s1">_get_reports_to_display(self, key: str) -&gt; List[Any]:</span>
        <span class="s0">&quot;&quot;&quot;Get test/collection reports for the given status key, such as `passed` or `error`.&quot;&quot;&quot;</span>
        <span class="s1">reports = self.stats.get(key, [])</span>
        <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">reports </span><span class="s2">if </span><span class="s1">getattr(x, </span><span class="s4">&quot;count_towards_summary&quot;</span><span class="s1">, </span><span class="s2">True</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">_build_normal_summary_stats_line(</span>
        <span class="s1">self,</span>
    <span class="s1">) -&gt; Tuple[List[Tuple[str, Dict[str, bool]]], str]:</span>
        <span class="s1">main_color, known_types = self._get_main_color()</span>
        <span class="s1">parts = []</span>

        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">known_types:</span>
            <span class="s1">reports = self._get_reports_to_display(key)</span>
            <span class="s2">if </span><span class="s1">reports:</span>
                <span class="s1">count = len(reports)</span>
                <span class="s1">color = _color_for_type.get(key, _color_for_type_default)</span>
                <span class="s1">markup = {color: </span><span class="s2">True</span><span class="s1">, </span><span class="s4">&quot;bold&quot;</span><span class="s1">: color == main_color}</span>
                <span class="s1">parts.append((</span><span class="s4">&quot;%d %s&quot; </span><span class="s1">% pluralize(count, key), markup))</span>

        <span class="s2">if not </span><span class="s1">parts:</span>
            <span class="s1">parts = [(</span><span class="s4">&quot;no tests ran&quot;</span><span class="s1">, {_color_for_type_default: </span><span class="s2">True</span><span class="s1">})]</span>

        <span class="s2">return </span><span class="s1">parts, main_color</span>

    <span class="s2">def </span><span class="s1">_build_collect_only_summary_stats_line(</span>
        <span class="s1">self,</span>
    <span class="s1">) -&gt; Tuple[List[Tuple[str, Dict[str, bool]]], str]:</span>
        <span class="s1">deselected = len(self._get_reports_to_display(</span><span class="s4">&quot;deselected&quot;</span><span class="s1">))</span>
        <span class="s1">errors = len(self._get_reports_to_display(</span><span class="s4">&quot;error&quot;</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">self._numcollected == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">parts = [(</span><span class="s4">&quot;no tests collected&quot;</span><span class="s1">, {</span><span class="s4">&quot;yellow&quot;</span><span class="s1">: </span><span class="s2">True</span><span class="s1">})]</span>
            <span class="s1">main_color = </span><span class="s4">&quot;yellow&quot;</span>

        <span class="s2">elif </span><span class="s1">deselected == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">main_color = </span><span class="s4">&quot;green&quot;</span>
            <span class="s1">collected_output = </span><span class="s4">&quot;%d %s collected&quot; </span><span class="s1">% pluralize(self._numcollected, </span><span class="s4">&quot;test&quot;</span><span class="s1">)</span>
            <span class="s1">parts = [(collected_output, {main_color: </span><span class="s2">True</span><span class="s1">})]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">all_tests_were_deselected = self._numcollected == deselected</span>
            <span class="s2">if </span><span class="s1">all_tests_were_deselected:</span>
                <span class="s1">main_color = </span><span class="s4">&quot;yellow&quot;</span>
                <span class="s1">collected_output = </span><span class="s4">f&quot;no tests collected (</span><span class="s5">{</span><span class="s1">deselected</span><span class="s5">} </span><span class="s4">deselected)&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">main_color = </span><span class="s4">&quot;green&quot;</span>
                <span class="s1">selected = self._numcollected - deselected</span>
                <span class="s1">collected_output = </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">selected</span><span class="s5">}</span><span class="s4">/</span><span class="s5">{</span><span class="s1">self._numcollected</span><span class="s5">} </span><span class="s4">tests collected (</span><span class="s5">{</span><span class="s1">deselected</span><span class="s5">} </span><span class="s4">deselected)&quot;</span>

            <span class="s1">parts = [(collected_output, {main_color: </span><span class="s2">True</span><span class="s1">})]</span>

        <span class="s2">if </span><span class="s1">errors:</span>
            <span class="s1">main_color = _color_for_type[</span><span class="s4">&quot;error&quot;</span><span class="s1">]</span>
            <span class="s1">parts += [(</span><span class="s4">&quot;%d %s&quot; </span><span class="s1">% pluralize(errors, </span><span class="s4">&quot;error&quot;</span><span class="s1">), {main_color: </span><span class="s2">True</span><span class="s1">})]</span>

        <span class="s2">return </span><span class="s1">parts, main_color</span>


<span class="s2">def </span><span class="s1">_get_pos(config: Config, rep: BaseReport):</span>
    <span class="s1">nodeid = config.cwd_relative_nodeid(rep.nodeid)</span>
    <span class="s2">return </span><span class="s1">nodeid</span>


<span class="s2">def </span><span class="s1">_format_trimmed(format: str, msg: str, available_width: int) -&gt; Optional[str]:</span>
    <span class="s0">&quot;&quot;&quot;Format msg into format, ellipsizing it if doesn't fit in available_width. 
 
    Returns None if even the ellipsis can't fit. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Only use the first line.</span>
    <span class="s1">i = msg.find(</span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">i != -</span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">msg = msg[:i]</span>

    <span class="s1">ellipsis = </span><span class="s4">&quot;...&quot;</span>
    <span class="s1">format_width = wcswidth(format.format(</span><span class="s4">&quot;&quot;</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">format_width + len(ellipsis) &gt; available_width:</span>
        <span class="s2">return None</span>

    <span class="s2">if </span><span class="s1">format_width + wcswidth(msg) &gt; available_width:</span>
        <span class="s1">available_width -= len(ellipsis)</span>
        <span class="s1">msg = msg[:available_width]</span>
        <span class="s2">while </span><span class="s1">format_width + wcswidth(msg) &gt; available_width:</span>
            <span class="s1">msg = msg[:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">msg += ellipsis</span>

    <span class="s2">return </span><span class="s1">format.format(msg)</span>


<span class="s2">def </span><span class="s1">_get_line_with_reprcrash_message(</span>
    <span class="s1">config: Config, rep: BaseReport, termwidth: int</span>
<span class="s1">) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Get summary line for a report, trying to add reprcrash message.&quot;&quot;&quot;</span>
    <span class="s1">verbose_word = rep._get_verbose_word(config)</span>
    <span class="s1">pos = _get_pos(config, rep)</span>

    <span class="s1">line = </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">verbose_word</span><span class="s5">} {</span><span class="s1">pos</span><span class="s5">}</span><span class="s4">&quot;</span>
    <span class="s1">line_width = wcswidth(line)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s0"># Type ignored intentionally -- possible AttributeError expected.</span>
        <span class="s1">msg = rep.longrepr.reprcrash.message  </span><span class="s0"># type: ignore[union-attr]</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">available_width = termwidth - line_width</span>
        <span class="s1">msg = _format_trimmed(</span><span class="s4">&quot; - {}&quot;</span><span class="s1">, msg, available_width)</span>
        <span class="s2">if </span><span class="s1">msg </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">line += msg</span>

    <span class="s2">return </span><span class="s1">line</span>


<span class="s2">def </span><span class="s1">_folded_skips(</span>
    <span class="s1">startpath: Path, skipped: Sequence[CollectReport],</span>
<span class="s1">) -&gt; List[Tuple[int, str, Optional[int], str]]:</span>
    <span class="s1">d: Dict[Tuple[str, Optional[int], str], List[CollectReport]] = {}</span>
    <span class="s2">for </span><span class="s1">event </span><span class="s2">in </span><span class="s1">skipped:</span>
        <span class="s2">assert </span><span class="s1">event.longrepr </span><span class="s2">is not None</span>
        <span class="s2">assert </span><span class="s1">isinstance(event.longrepr, tuple), (event, event.longrepr)</span>
        <span class="s2">assert </span><span class="s1">len(event.longrepr) == </span><span class="s3">3</span><span class="s1">, (event, event.longrepr)</span>
        <span class="s1">fspath, lineno, reason = event.longrepr</span>
        <span class="s0"># For consistency, report all fspaths in relative form.</span>
        <span class="s1">fspath = bestrelpath(startpath, Path(fspath))</span>
        <span class="s1">keywords = getattr(event, </span><span class="s4">&quot;keywords&quot;</span><span class="s1">, {})</span>
        <span class="s0"># Folding reports with global pytestmark variable.</span>
        <span class="s0"># This is a workaround, because for now we cannot identify the scope of a skip marker</span>
        <span class="s0"># TODO: Revisit after marks scope would be fixed.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">event.when == </span><span class="s4">&quot;setup&quot;</span>
            <span class="s2">and </span><span class="s4">&quot;skip&quot; </span><span class="s2">in </span><span class="s1">keywords</span>
            <span class="s2">and </span><span class="s4">&quot;pytestmark&quot; </span><span class="s2">not in </span><span class="s1">keywords</span>
        <span class="s1">):</span>
            <span class="s1">key: Tuple[str, Optional[int], str] = (fspath, </span><span class="s2">None</span><span class="s1">, reason)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">key = (fspath, lineno, reason)</span>
        <span class="s1">d.setdefault(key, []).append(event)</span>
    <span class="s1">values: List[Tuple[int, str, Optional[int], str]] = []</span>
    <span class="s2">for </span><span class="s1">key, events </span><span class="s2">in </span><span class="s1">d.items():</span>
        <span class="s1">values.append((len(events), *key))</span>
    <span class="s2">return </span><span class="s1">values</span>


<span class="s1">_color_for_type = {</span>
    <span class="s4">&quot;failed&quot;</span><span class="s1">: </span><span class="s4">&quot;red&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;error&quot;</span><span class="s1">: </span><span class="s4">&quot;red&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;warnings&quot;</span><span class="s1">: </span><span class="s4">&quot;yellow&quot;</span><span class="s1">,</span>
    <span class="s4">&quot;passed&quot;</span><span class="s1">: </span><span class="s4">&quot;green&quot;</span><span class="s1">,</span>
<span class="s1">}</span>
<span class="s1">_color_for_type_default = </span><span class="s4">&quot;yellow&quot;</span>


<span class="s2">def </span><span class="s1">pluralize(count: int, noun: str) -&gt; Tuple[int, str]:</span>
    <span class="s0"># No need to pluralize words such as `failed` or `passed`.</span>
    <span class="s2">if </span><span class="s1">noun </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">&quot;error&quot;</span><span class="s1">, </span><span class="s4">&quot;warnings&quot;</span><span class="s1">, </span><span class="s4">&quot;test&quot;</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">count, noun</span>

    <span class="s0"># The `warnings` key is plural. To avoid API breakage, we keep it that way but</span>
    <span class="s0"># set it to singular here so we can determine plurality in the same way as we do</span>
    <span class="s0"># for `error`.</span>
    <span class="s1">noun = noun.replace(</span><span class="s4">&quot;warnings&quot;</span><span class="s1">, </span><span class="s4">&quot;warning&quot;</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">count, noun + </span><span class="s4">&quot;s&quot; </span><span class="s2">if </span><span class="s1">count != </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">noun</span>


<span class="s2">def </span><span class="s1">_plugin_nameversions(plugininfo) -&gt; List[str]:</span>
    <span class="s1">values: List[str] = []</span>
    <span class="s2">for </span><span class="s1">plugin, dist </span><span class="s2">in </span><span class="s1">plugininfo:</span>
        <span class="s0"># Gets us name and version!</span>
        <span class="s1">name = </span><span class="s4">&quot;{dist.project_name}-{dist.version}&quot;</span><span class="s1">.format(dist=dist)</span>
        <span class="s0"># Questionable convenience, but it keeps things short.</span>
        <span class="s2">if </span><span class="s1">name.startswith(</span><span class="s4">&quot;pytest-&quot;</span><span class="s1">):</span>
            <span class="s1">name = name[</span><span class="s3">7</span><span class="s1">:]</span>
        <span class="s0"># We decided to print python package names they can have more than one plugin.</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">values:</span>
            <span class="s1">values.append(name)</span>
    <span class="s2">return </span><span class="s1">values</span>


<span class="s2">def </span><span class="s1">format_session_duration(seconds: float) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Format the given seconds in a human readable manner to show in the final summary.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">seconds &lt; </span><span class="s3">60</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">seconds</span><span class="s5">:</span><span class="s4">.2f</span><span class="s5">}</span><span class="s4">s&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dt = datetime.timedelta(seconds=int(seconds))</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">seconds</span><span class="s5">:</span><span class="s4">.2f</span><span class="s5">}</span><span class="s4">s (</span><span class="s5">{</span><span class="s1">dt</span><span class="s5">}</span><span class="s4">)&quot;</span>


<span class="s2">def </span><span class="s1">_get_raw_skip_reason(report: TestReport) -&gt; str:</span>
    <span class="s0">&quot;&quot;&quot;Get the reason string of a skip/xfail/xpass test report. 
 
    The string is just the part given by the user. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(report, </span><span class="s4">&quot;wasxfail&quot;</span><span class="s1">):</span>
        <span class="s1">reason = cast(str, report.wasxfail)</span>
        <span class="s2">if </span><span class="s1">reason.startswith(</span><span class="s4">&quot;reason: &quot;</span><span class="s1">):</span>
            <span class="s1">reason = reason[len(</span><span class="s4">&quot;reason: &quot;</span><span class="s1">) :]</span>
        <span class="s2">return </span><span class="s1">reason</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">report.skipped</span>
        <span class="s2">assert </span><span class="s1">isinstance(report.longrepr, tuple)</span>
        <span class="s1">_, _, reason = report.longrepr</span>
        <span class="s2">if </span><span class="s1">reason.startswith(</span><span class="s4">&quot;Skipped: &quot;</span><span class="s1">):</span>
            <span class="s1">reason = reason[len(</span><span class="s4">&quot;Skipped: &quot;</span><span class="s1">) :]</span>
        <span class="s2">elif </span><span class="s1">reason == </span><span class="s4">&quot;Skipped&quot;</span><span class="s1">:</span>
            <span class="s1">reason = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">reason</span>
</pre>
</body>
</html>