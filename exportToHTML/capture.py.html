<html>
<head>
<title>capture.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
capture.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Per-test stdout/stderr capturing mechanism.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">UnsupportedOperation</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">TemporaryFile</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">AnyStr</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generic</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TextIO</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">Config</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">hookimpl</span>
<span class="s2">from </span><span class="s1">_pytest.config.argparsing </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">_pytest.deprecated </span><span class="s2">import </span><span class="s1">check_ispytest</span>
<span class="s2">from </span><span class="s1">_pytest.fixtures </span><span class="s2">import </span><span class="s1">fixture</span>
<span class="s2">from </span><span class="s1">_pytest.fixtures </span><span class="s2">import </span><span class="s1">SubRequest</span>
<span class="s2">from </span><span class="s1">_pytest.nodes </span><span class="s2">import </span><span class="s1">Collector</span>
<span class="s2">from </span><span class="s1">_pytest.nodes </span><span class="s2">import </span><span class="s1">File</span>
<span class="s2">from </span><span class="s1">_pytest.nodes </span><span class="s2">import </span><span class="s1">Item</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Literal</span>

    <span class="s1">_CaptureMethod = Literal[</span><span class="s3">&quot;fd&quot;</span><span class="s1">, </span><span class="s3">&quot;sys&quot;</span><span class="s1">, </span><span class="s3">&quot;no&quot;</span><span class="s1">, </span><span class="s3">&quot;tee-sys&quot;</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">pytest_addoption(parser: Parser) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;general&quot;</span><span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;--capture&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store&quot;</span><span class="s1">,</span>
        <span class="s1">default=</span><span class="s3">&quot;fd&quot;</span><span class="s1">,</span>
        <span class="s1">metavar=</span><span class="s3">&quot;method&quot;</span><span class="s1">,</span>
        <span class="s1">choices=[</span><span class="s3">&quot;fd&quot;</span><span class="s1">, </span><span class="s3">&quot;sys&quot;</span><span class="s1">, </span><span class="s3">&quot;no&quot;</span><span class="s1">, </span><span class="s3">&quot;tee-sys&quot;</span><span class="s1">],</span>
        <span class="s1">help=</span><span class="s3">&quot;per-test capturing method: one of fd|sys|no|tee-sys.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">group._addoption(</span>
        <span class="s3">&quot;-s&quot;</span><span class="s1">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_const&quot;</span><span class="s1">,</span>
        <span class="s1">const=</span><span class="s3">&quot;no&quot;</span><span class="s1">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;capture&quot;</span><span class="s1">,</span>
        <span class="s1">help=</span><span class="s3">&quot;shortcut for --capture=no.&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_colorama_workaround() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Ensure colorama is imported so that it attaches to the correct stdio 
    handles on Windows. 
 
    colorama uses the terminal on import time. So if something does the 
    first import of colorama while I/O capture is active, colorama will 
    fail in various ways. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">&quot;win32&quot;</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">colorama  </span><span class="s0"># noqa: F401</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_readline_workaround() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Ensure readline is imported so that it attaches to the correct stdio 
    handles on Windows. 
 
    Pdb uses readline support where available--when not running from the Python 
    prompt, the readline module is not imported until running the pdb REPL.  If 
    running pytest with the --pdb option this means the readline module is not 
    imported until after I/O capture has been started. 
 
    This is a problem for pyreadline, which is often used to implement readline 
    support on Windows, as it does not attach to the correct handles for stdout 
    and/or stdin if they have been redirected by the FDCapture mechanism.  This 
    workaround ensures that readline is imported before I/O capture is setup so 
    that it can attach to the actual stdin/out for the console. 
 
    See https://github.com/pytest-dev/pytest/pull/1281. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">sys.platform.startswith(</span><span class="s3">&quot;win32&quot;</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">readline  </span><span class="s0"># noqa: F401</span>
        <span class="s2">except </span><span class="s1">ImportError:</span>
            <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_py36_windowsconsoleio_workaround(stream: TextIO) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Workaround for Windows Unicode console handling on Python&gt;=3.6. 
 
    Python 3.6 implemented Unicode console handling for Windows. This works 
    by reading/writing to the raw console handle using 
    ``{Read,Write}ConsoleW``. 
 
    The problem is that we are going to ``dup2`` over the stdio file 
    descriptors when doing ``FDCapture`` and this will ``CloseHandle`` the 
    handles used by Python to write to the console. Though there is still some 
    weirdness and the console handle seems to only be closed randomly and not 
    on the first call to ``CloseHandle``, or maybe it gets reopened with the 
    same handle value when we suspend capturing. 
 
    The workaround in this case will reopen stdio with a different fd which 
    also means a different handle by replicating the logic in 
    &quot;Py_lifecycle.c:initstdio/create_stdio&quot;. 
 
    :param stream: 
        In practice ``sys.stdout`` or ``sys.stderr``, but given 
        here as parameter for unittesting purposes. 
 
    See https://github.com/pytest-dev/py/issues/103. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">sys.platform.startswith(</span><span class="s3">&quot;win32&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">hasattr(sys, </span><span class="s3">&quot;pypy_version_info&quot;</span><span class="s1">):</span>
        <span class="s2">return</span>

    <span class="s0"># Bail out if ``stream`` doesn't seem like a proper ``io`` stream (#2666).</span>
    <span class="s2">if not </span><span class="s1">hasattr(stream, </span><span class="s3">&quot;buffer&quot;</span><span class="s1">):  </span><span class="s0"># type: ignore[unreachable]</span>
        <span class="s2">return</span>

    <span class="s1">buffered = hasattr(stream.buffer, </span><span class="s3">&quot;raw&quot;</span><span class="s1">)</span>
    <span class="s1">raw_stdout = stream.buffer.raw </span><span class="s2">if </span><span class="s1">buffered </span><span class="s2">else </span><span class="s1">stream.buffer  </span><span class="s0"># type: ignore[attr-defined]</span>

    <span class="s2">if not </span><span class="s1">isinstance(raw_stdout, io._WindowsConsoleIO):  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">_reopen_stdio(f, mode):</span>
        <span class="s2">if not </span><span class="s1">buffered </span><span class="s2">and </span><span class="s1">mode[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">&quot;w&quot;</span><span class="s1">:</span>
            <span class="s1">buffering = </span><span class="s4">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">buffering = -</span><span class="s4">1</span>

        <span class="s2">return </span><span class="s1">io.TextIOWrapper(</span>
            <span class="s1">open(os.dup(f.fileno()), mode, buffering),  </span><span class="s0"># type: ignore[arg-type]</span>
            <span class="s1">f.encoding,</span>
            <span class="s1">f.errors,</span>
            <span class="s1">f.newlines,</span>
            <span class="s1">f.line_buffering,</span>
        <span class="s1">)</span>

    <span class="s1">sys.stdin = _reopen_stdio(sys.stdin, </span><span class="s3">&quot;rb&quot;</span><span class="s1">)</span>
    <span class="s1">sys.stdout = _reopen_stdio(sys.stdout, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>
    <span class="s1">sys.stderr = _reopen_stdio(sys.stderr, </span><span class="s3">&quot;wb&quot;</span><span class="s1">)</span>


<span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">pytest_load_initial_conftests(early_config: Config):</span>
    <span class="s1">ns = early_config.known_args_namespace</span>
    <span class="s2">if </span><span class="s1">ns.capture == </span><span class="s3">&quot;fd&quot;</span><span class="s1">:</span>
        <span class="s1">_py36_windowsconsoleio_workaround(sys.stdout)</span>
    <span class="s1">_colorama_workaround()</span>
    <span class="s1">_readline_workaround()</span>
    <span class="s1">pluginmanager = early_config.pluginmanager</span>
    <span class="s1">capman = CaptureManager(ns.capture)</span>
    <span class="s1">pluginmanager.register(capman, </span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>

    <span class="s0"># Make sure that capturemanager is properly reset at final shutdown.</span>
    <span class="s1">early_config.add_cleanup(capman.stop_global_capturing)</span>

    <span class="s0"># Finally trigger conftest loading but while capturing (issue #93).</span>
    <span class="s1">capman.start_global_capturing()</span>
    <span class="s1">outcome = </span><span class="s2">yield</span>
    <span class="s1">capman.suspend_global_capture()</span>
    <span class="s2">if </span><span class="s1">outcome.excinfo </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">out, err = capman.read_global_capture()</span>
        <span class="s1">sys.stdout.write(out)</span>
        <span class="s1">sys.stderr.write(err)</span>


<span class="s0"># IO Helpers.</span>


<span class="s2">class </span><span class="s1">EncodedFile(io.TextIOWrapper):</span>
    <span class="s1">__slots__ = ()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0"># Ensure that file.name is a string. Workaround for a Python bug</span>
        <span class="s0"># fixed in &gt;=3.7.4: https://bugs.python.org/issue36015</span>
        <span class="s2">return </span><span class="s1">repr(self.buffer)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">mode(self) -&gt; str:</span>
        <span class="s0"># TextIOWrapper doesn't expose a mode, but at least some of our</span>
        <span class="s0"># tests check it.</span>
        <span class="s2">return </span><span class="s1">self.buffer.mode.replace(</span><span class="s3">&quot;b&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CaptureIO(io.TextIOWrapper):</span>
    <span class="s2">def </span><span class="s1">__init__(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(io.BytesIO(), encoding=</span><span class="s3">&quot;UTF-8&quot;</span><span class="s1">, newline=</span><span class="s3">&quot;&quot;</span><span class="s1">, write_through=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">getvalue(self) -&gt; str:</span>
        <span class="s2">assert </span><span class="s1">isinstance(self.buffer, io.BytesIO)</span>
        <span class="s2">return </span><span class="s1">self.buffer.getvalue().decode(</span><span class="s3">&quot;UTF-8&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TeeCaptureIO(CaptureIO):</span>
    <span class="s2">def </span><span class="s1">__init__(self, other: TextIO) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._other = other</span>
        <span class="s1">super().__init__()</span>

    <span class="s2">def </span><span class="s1">write(self, s: str) -&gt; int:</span>
        <span class="s1">super().write(s)</span>
        <span class="s2">return </span><span class="s1">self._other.write(s)</span>


<span class="s2">class </span><span class="s1">DontReadFromInput:</span>
    <span class="s1">encoding = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">read(self, *args):</span>
        <span class="s2">raise </span><span class="s1">OSError(</span>
            <span class="s3">&quot;pytest: reading from stdin while output is captured!  Consider using `-s`.&quot;</span>
        <span class="s1">)</span>

    <span class="s1">readline = read</span>
    <span class="s1">readlines = read</span>
    <span class="s1">__next__ = read</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">fileno(self) -&gt; int:</span>
        <span class="s2">raise </span><span class="s1">UnsupportedOperation(</span><span class="s3">&quot;redirected stdin is pseudofile, has no fileno()&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">isatty(self) -&gt; bool:</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">pass</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">buffer(self):</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s0"># Capture classes.</span>


<span class="s1">patchsysdict = {</span><span class="s4">0</span><span class="s1">: </span><span class="s3">&quot;stdin&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">: </span><span class="s3">&quot;stdout&quot;</span><span class="s1">, </span><span class="s4">2</span><span class="s1">: </span><span class="s3">&quot;stderr&quot;</span><span class="s1">}</span>


<span class="s2">class </span><span class="s1">NoCapture:</span>
    <span class="s1">EMPTY_BUFFER = </span><span class="s2">None</span>
    <span class="s1">__init__ = start = done = suspend = resume = </span><span class="s2">lambda </span><span class="s1">*args: </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">SysCaptureBinary:</span>

    <span class="s1">EMPTY_BUFFER = </span><span class="s3">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, fd: int, tmpfile=</span><span class="s2">None</span><span class="s1">, *, tee: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">name = patchsysdict[fd]</span>
        <span class="s1">self._old = getattr(sys, name)</span>
        <span class="s1">self.name = name</span>
        <span class="s2">if </span><span class="s1">tmpfile </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;stdin&quot;</span><span class="s1">:</span>
                <span class="s1">tmpfile = DontReadFromInput()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tmpfile = CaptureIO() </span><span class="s2">if not </span><span class="s1">tee </span><span class="s2">else </span><span class="s1">TeeCaptureIO(self._old)</span>
        <span class="s1">self.tmpfile = tmpfile</span>
        <span class="s1">self._state = </span><span class="s3">&quot;initialized&quot;</span>

    <span class="s2">def </span><span class="s1">repr(self, class_name: str) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;{} {} _old={} _state={!r} tmpfile={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">class_name,</span>
            <span class="s1">self.name,</span>
            <span class="s1">hasattr(self, </span><span class="s3">&quot;_old&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">repr(self._old) </span><span class="s2">or </span><span class="s3">&quot;&lt;UNSET&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">self._state,</span>
            <span class="s1">self.tmpfile,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;{} {} _old={} _state={!r} tmpfile={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.__class__.__name__,</span>
            <span class="s1">self.name,</span>
            <span class="s1">hasattr(self, </span><span class="s3">&quot;_old&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">repr(self._old) </span><span class="s2">or </span><span class="s3">&quot;&lt;UNSET&gt;&quot;</span><span class="s1">,</span>
            <span class="s1">self._state,</span>
            <span class="s1">self.tmpfile,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_assert_state(self, op: str, states: Tuple[str, ...]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">self._state </span><span class="s2">in </span><span class="s1">states</span>
        <span class="s1">), </span><span class="s3">&quot;cannot {} in state {!r}: expected one of {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">op, self._state, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(states)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">start(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;start&quot;</span><span class="s1">, (</span><span class="s3">&quot;initialized&quot;</span><span class="s1">,))</span>
        <span class="s1">setattr(sys, self.name, self.tmpfile)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>

    <span class="s2">def </span><span class="s1">snap(self):</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;snap&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res = self.tmpfile.buffer.read()</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.tmpfile.truncate()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">done(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;done&quot;</span><span class="s1">, (</span><span class="s3">&quot;initialized&quot;</span><span class="s1">, </span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">, </span><span class="s3">&quot;done&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;done&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">setattr(sys, self.name, self._old)</span>
        <span class="s2">del </span><span class="s1">self._old</span>
        <span class="s1">self.tmpfile.close()</span>
        <span class="s1">self._state = </span><span class="s3">&quot;done&quot;</span>

    <span class="s2">def </span><span class="s1">suspend(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;suspend&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">setattr(sys, self.name, self._old)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;suspended&quot;</span>

    <span class="s2">def </span><span class="s1">resume(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;resume&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;started&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">setattr(sys, self.name, self.tmpfile)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>

    <span class="s2">def </span><span class="s1">writeorg(self, data) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;writeorg&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">self._old.flush()</span>
        <span class="s1">self._old.buffer.write(data)</span>
        <span class="s1">self._old.buffer.flush()</span>


<span class="s2">class </span><span class="s1">SysCapture(SysCaptureBinary):</span>
    <span class="s1">EMPTY_BUFFER = </span><span class="s3">&quot;&quot;  </span><span class="s0"># type: ignore[assignment]</span>

    <span class="s2">def </span><span class="s1">snap(self):</span>
        <span class="s1">res = self.tmpfile.getvalue()</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.tmpfile.truncate()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">writeorg(self, data):</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;writeorg&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">self._old.write(data)</span>
        <span class="s1">self._old.flush()</span>


<span class="s2">class </span><span class="s1">FDCaptureBinary:</span>
    <span class="s0">&quot;&quot;&quot;Capture IO to/from a given OS-level file descriptor. 
 
    snap() produces `bytes`. 
    &quot;&quot;&quot;</span>

    <span class="s1">EMPTY_BUFFER = </span><span class="s3">b&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, targetfd: int) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.targetfd = targetfd</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">os.fstat(targetfd)</span>
        <span class="s2">except </span><span class="s1">OSError:</span>
            <span class="s0"># FD capturing is conceptually simple -- create a temporary file,</span>
            <span class="s0"># redirect the FD to it, redirect back when done. But when the</span>
            <span class="s0"># target FD is invalid it throws a wrench into this loveley scheme.</span>
            <span class="s0">#</span>
            <span class="s0"># Tests themselves shouldn't care if the FD is valid, FD capturing</span>
            <span class="s0"># should work regardless of external circumstances. So falling back</span>
            <span class="s0"># to just sys capturing is not a good option.</span>
            <span class="s0">#</span>
            <span class="s0"># Further complications are the need to support suspend() and the</span>
            <span class="s0"># possibility of FD reuse (e.g. the tmpfile getting the very same</span>
            <span class="s0"># target FD). The following approach is robust, I believe.</span>
            <span class="s1">self.targetfd_invalid: Optional[int] = os.open(os.devnull, os.O_RDWR)</span>
            <span class="s1">os.dup2(self.targetfd_invalid, targetfd)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.targetfd_invalid = </span><span class="s2">None</span>
        <span class="s1">self.targetfd_save = os.dup(targetfd)</span>

        <span class="s2">if </span><span class="s1">targetfd == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.tmpfile = open(os.devnull)</span>
            <span class="s1">self.syscapture = SysCapture(targetfd)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.tmpfile = EncodedFile(</span>
                <span class="s1">TemporaryFile(buffering=</span><span class="s4">0</span><span class="s1">),</span>
                <span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">,</span>
                <span class="s1">errors=</span><span class="s3">&quot;replace&quot;</span><span class="s1">,</span>
                <span class="s1">newline=</span><span class="s3">&quot;&quot;</span><span class="s1">,</span>
                <span class="s1">write_through=</span><span class="s2">True</span><span class="s1">,</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">targetfd </span><span class="s2">in </span><span class="s1">patchsysdict:</span>
                <span class="s1">self.syscapture = SysCapture(targetfd, self.tmpfile)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.syscapture = NoCapture()</span>

        <span class="s1">self._state = </span><span class="s3">&quot;initialized&quot;</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;{} {} oldfd={} _state={!r} tmpfile={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.__class__.__name__,</span>
            <span class="s1">self.targetfd,</span>
            <span class="s1">self.targetfd_save,</span>
            <span class="s1">self._state,</span>
            <span class="s1">self.tmpfile,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_assert_state(self, op: str, states: Tuple[str, ...]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">self._state </span><span class="s2">in </span><span class="s1">states</span>
        <span class="s1">), </span><span class="s3">&quot;cannot {} in state {!r}: expected one of {}&quot;</span><span class="s1">.format(</span>
            <span class="s1">op, self._state, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(states)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">start(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Start capturing on targetfd using memorized tmpfile.&quot;&quot;&quot;</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;start&quot;</span><span class="s1">, (</span><span class="s3">&quot;initialized&quot;</span><span class="s1">,))</span>
        <span class="s1">os.dup2(self.tmpfile.fileno(), self.targetfd)</span>
        <span class="s1">self.syscapture.start()</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>

    <span class="s2">def </span><span class="s1">snap(self):</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;snap&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res = self.tmpfile.buffer.read()</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.tmpfile.truncate()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">done(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Stop capturing, restore streams, return original capture file, 
        seeked to position zero.&quot;&quot;&quot;</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;done&quot;</span><span class="s1">, (</span><span class="s3">&quot;initialized&quot;</span><span class="s1">, </span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">, </span><span class="s3">&quot;done&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;done&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">os.dup2(self.targetfd_save, self.targetfd)</span>
        <span class="s1">os.close(self.targetfd_save)</span>
        <span class="s2">if </span><span class="s1">self.targetfd_invalid </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.targetfd_invalid != self.targetfd:</span>
                <span class="s1">os.close(self.targetfd)</span>
            <span class="s1">os.close(self.targetfd_invalid)</span>
        <span class="s1">self.syscapture.done()</span>
        <span class="s1">self.tmpfile.close()</span>
        <span class="s1">self._state = </span><span class="s3">&quot;done&quot;</span>

    <span class="s2">def </span><span class="s1">suspend(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;suspend&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;suspended&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">self.syscapture.suspend()</span>
        <span class="s1">os.dup2(self.targetfd_save, self.targetfd)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;suspended&quot;</span>

    <span class="s2">def </span><span class="s1">resume(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;resume&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;started&quot;</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">self.syscapture.resume()</span>
        <span class="s1">os.dup2(self.tmpfile.fileno(), self.targetfd)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>

    <span class="s2">def </span><span class="s1">writeorg(self, data):</span>
        <span class="s0">&quot;&quot;&quot;Write to original file descriptor.&quot;&quot;&quot;</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;writeorg&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">os.write(self.targetfd_save, data)</span>


<span class="s2">class </span><span class="s1">FDCapture(FDCaptureBinary):</span>
    <span class="s0">&quot;&quot;&quot;Capture IO to/from a given OS-level file descriptor. 
 
    snap() produces text. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Ignore type because it doesn't match the type in the superclass (bytes).</span>
    <span class="s1">EMPTY_BUFFER = </span><span class="s3">&quot;&quot;  </span><span class="s0"># type: ignore</span>

    <span class="s2">def </span><span class="s1">snap(self):</span>
        <span class="s1">self._assert_state(</span><span class="s3">&quot;snap&quot;</span><span class="s1">, (</span><span class="s3">&quot;started&quot;</span><span class="s1">, </span><span class="s3">&quot;suspended&quot;</span><span class="s1">))</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res = self.tmpfile.read()</span>
        <span class="s1">self.tmpfile.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.tmpfile.truncate()</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s2">def </span><span class="s1">writeorg(self, data):</span>
        <span class="s0">&quot;&quot;&quot;Write to original file descriptor.&quot;&quot;&quot;</span>
        <span class="s1">super().writeorg(data.encode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">))  </span><span class="s0"># XXX use encoding of original stream</span>


<span class="s0"># MultiCapture</span>


<span class="s0"># This class was a namedtuple, but due to mypy limitation[0] it could not be</span>
<span class="s0"># made generic, so was replaced by a regular class which tries to emulate the</span>
<span class="s0"># pertinent parts of a namedtuple. If the mypy limitation is ever lifted, can</span>
<span class="s0"># make it a namedtuple again.</span>
<span class="s0"># [0]: https://github.com/python/mypy/issues/685</span>
<span class="s1">@final</span>
<span class="s1">@functools.total_ordering</span>
<span class="s2">class </span><span class="s1">CaptureResult(Generic[AnyStr]):</span>
    <span class="s0">&quot;&quot;&quot;The result of :method:`CaptureFixture.readouterr`.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ = (</span><span class="s3">&quot;out&quot;</span><span class="s1">, </span><span class="s3">&quot;err&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self, out: AnyStr, err: AnyStr) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.out: AnyStr = out</span>
        <span class="s1">self.err: AnyStr = err</span>

    <span class="s2">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">__iter__(self) -&gt; Iterator[AnyStr]:</span>
        <span class="s2">return </span><span class="s1">iter((self.out, self.err))</span>

    <span class="s2">def </span><span class="s1">__getitem__(self, item: int) -&gt; AnyStr:</span>
        <span class="s2">return </span><span class="s1">tuple(self)[item]</span>

    <span class="s2">def </span><span class="s1">_replace(</span>
        <span class="s1">self, *, out: Optional[AnyStr] = </span><span class="s2">None</span><span class="s1">, err: Optional[AnyStr] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;CaptureResult[AnyStr]&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">CaptureResult(</span>
            <span class="s1">out=self.out </span><span class="s2">if </span><span class="s1">out </span><span class="s2">is None else </span><span class="s1">out, err=self.err </span><span class="s2">if </span><span class="s1">err </span><span class="s2">is None else </span><span class="s1">err</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">count(self, value: AnyStr) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">tuple(self).count(value)</span>

    <span class="s2">def </span><span class="s1">index(self, value) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">tuple(self).index(value)</span>

    <span class="s2">def </span><span class="s1">__eq__(self, other: object) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">isinstance(other, (CaptureResult, tuple)):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">tuple(self) == tuple(other)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self))</span>

    <span class="s2">def </span><span class="s1">__lt__(self, other: object) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">isinstance(other, (CaptureResult, tuple)):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">tuple(self) &lt; tuple(other)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">f&quot;CaptureResult(out=</span><span class="s5">{</span><span class="s1">self.out</span><span class="s5">!r}</span><span class="s3">, err=</span><span class="s5">{</span><span class="s1">self.err</span><span class="s5">!r}</span><span class="s3">)&quot;</span>


<span class="s2">class </span><span class="s1">MultiCapture(Generic[AnyStr]):</span>
    <span class="s1">_state = </span><span class="s2">None</span>
    <span class="s1">_in_suspended = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self, in_, out, err) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.in_ = in_</span>
        <span class="s1">self.out = out</span>
        <span class="s1">self.err = err</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;MultiCapture out={!r} err={!r} in_={!r} _state={!r} _in_suspended={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.out, self.err, self.in_, self._state, self._in_suspended,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">start_capturing(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>
        <span class="s2">if </span><span class="s1">self.in_:</span>
            <span class="s1">self.in_.start()</span>
        <span class="s2">if </span><span class="s1">self.out:</span>
            <span class="s1">self.out.start()</span>
        <span class="s2">if </span><span class="s1">self.err:</span>
            <span class="s1">self.err.start()</span>

    <span class="s2">def </span><span class="s1">pop_outerr_to_orig(self) -&gt; Tuple[AnyStr, AnyStr]:</span>
        <span class="s0">&quot;&quot;&quot;Pop current snapshot out/err capture and flush to orig streams.&quot;&quot;&quot;</span>
        <span class="s1">out, err = self.readouterr()</span>
        <span class="s2">if </span><span class="s1">out:</span>
            <span class="s1">self.out.writeorg(out)</span>
        <span class="s2">if </span><span class="s1">err:</span>
            <span class="s1">self.err.writeorg(err)</span>
        <span class="s2">return </span><span class="s1">out, err</span>

    <span class="s2">def </span><span class="s1">suspend_capturing(self, in_: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._state = </span><span class="s3">&quot;suspended&quot;</span>
        <span class="s2">if </span><span class="s1">self.out:</span>
            <span class="s1">self.out.suspend()</span>
        <span class="s2">if </span><span class="s1">self.err:</span>
            <span class="s1">self.err.suspend()</span>
        <span class="s2">if </span><span class="s1">in_ </span><span class="s2">and </span><span class="s1">self.in_:</span>
            <span class="s1">self.in_.suspend()</span>
            <span class="s1">self._in_suspended = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">resume_capturing(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._state = </span><span class="s3">&quot;started&quot;</span>
        <span class="s2">if </span><span class="s1">self.out:</span>
            <span class="s1">self.out.resume()</span>
        <span class="s2">if </span><span class="s1">self.err:</span>
            <span class="s1">self.err.resume()</span>
        <span class="s2">if </span><span class="s1">self._in_suspended:</span>
            <span class="s1">self.in_.resume()</span>
            <span class="s1">self._in_suspended = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">stop_capturing(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Stop capturing and reset capturing streams.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._state == </span><span class="s3">&quot;stopped&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;was already stopped&quot;</span><span class="s1">)</span>
        <span class="s1">self._state = </span><span class="s3">&quot;stopped&quot;</span>
        <span class="s2">if </span><span class="s1">self.out:</span>
            <span class="s1">self.out.done()</span>
        <span class="s2">if </span><span class="s1">self.err:</span>
            <span class="s1">self.err.done()</span>
        <span class="s2">if </span><span class="s1">self.in_:</span>
            <span class="s1">self.in_.done()</span>

    <span class="s2">def </span><span class="s1">is_started(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether actively capturing -- not suspended or stopped.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._state == </span><span class="s3">&quot;started&quot;</span>

    <span class="s2">def </span><span class="s1">readouterr(self) -&gt; CaptureResult[AnyStr]:</span>
        <span class="s2">if </span><span class="s1">self.out:</span>
            <span class="s1">out = self.out.snap()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">out = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.err:</span>
            <span class="s1">err = self.err.snap()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">err = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">CaptureResult(out, err)</span>


<span class="s2">def </span><span class="s1">_get_multicapture(method: </span><span class="s3">&quot;_CaptureMethod&quot;</span><span class="s1">) -&gt; MultiCapture[str]:</span>
    <span class="s2">if </span><span class="s1">method == </span><span class="s3">&quot;fd&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">MultiCapture(in_=FDCapture(</span><span class="s4">0</span><span class="s1">), out=FDCapture(</span><span class="s4">1</span><span class="s1">), err=FDCapture(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s3">&quot;sys&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">MultiCapture(in_=SysCapture(</span><span class="s4">0</span><span class="s1">), out=SysCapture(</span><span class="s4">1</span><span class="s1">), err=SysCapture(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s3">&quot;no&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">MultiCapture(in_=</span><span class="s2">None</span><span class="s1">, out=</span><span class="s2">None</span><span class="s1">, err=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">method == </span><span class="s3">&quot;tee-sys&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">MultiCapture(</span>
            <span class="s1">in_=</span><span class="s2">None</span><span class="s1">, out=SysCapture(</span><span class="s4">1</span><span class="s1">, tee=</span><span class="s2">True</span><span class="s1">), err=SysCapture(</span><span class="s4">2</span><span class="s1">, tee=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;unknown capturing method: </span><span class="s5">{</span><span class="s1">method</span><span class="s5">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s0"># CaptureManager and CaptureFixture</span>


<span class="s2">class </span><span class="s1">CaptureManager:</span>
    <span class="s0">&quot;&quot;&quot;The capture plugin. 
 
    Manages that the appropriate capture method is enabled/disabled during 
    collection and each test phase (setup, call, teardown). After each of 
    those points, the captured output is obtained and attached to the 
    collection/runtest report. 
 
    There are two levels of capture: 
 
    * global: enabled by default and can be suppressed by the ``-s`` 
      option. This is always enabled/disabled during collection and each test 
      phase. 
 
    * fixture: when a test function or one of its fixture depend on the 
      ``capsys`` or ``capfd`` fixtures. In this case special handling is 
      needed to ensure the fixtures take precedence over the global capture. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, method: </span><span class="s3">&quot;_CaptureMethod&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._method = method</span>
        <span class="s1">self._global_capturing: Optional[MultiCapture[str]] = </span><span class="s2">None</span>
        <span class="s1">self._capture_fixture: Optional[CaptureFixture[Any]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;CaptureManager _method={!r} _global_capturing={!r} _capture_fixture={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self._method, self._global_capturing, self._capture_fixture</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">is_capturing(self) -&gt; Union[str, bool]:</span>
        <span class="s2">if </span><span class="s1">self.is_globally_capturing():</span>
            <span class="s2">return </span><span class="s3">&quot;global&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s2">return </span><span class="s3">&quot;fixture %s&quot; </span><span class="s1">% self._capture_fixture.request.fixturename</span>
        <span class="s2">return False</span>

    <span class="s0"># Global capturing control</span>

    <span class="s2">def </span><span class="s1">is_globally_capturing(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._method != </span><span class="s3">&quot;no&quot;</span>

    <span class="s2">def </span><span class="s1">start_global_capturing(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">self._global_capturing </span><span class="s2">is None</span>
        <span class="s1">self._global_capturing = _get_multicapture(self._method)</span>
        <span class="s1">self._global_capturing.start_capturing()</span>

    <span class="s2">def </span><span class="s1">stop_global_capturing(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._global_capturing </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._global_capturing.pop_outerr_to_orig()</span>
            <span class="s1">self._global_capturing.stop_capturing()</span>
            <span class="s1">self._global_capturing = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">resume_global_capture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0"># During teardown of the python process, and on rare occasions, capture</span>
        <span class="s0"># attributes can be `None` while trying to resume global capture.</span>
        <span class="s2">if </span><span class="s1">self._global_capturing </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._global_capturing.resume_capturing()</span>

    <span class="s2">def </span><span class="s1">suspend_global_capture(self, in_: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._global_capturing </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._global_capturing.suspend_capturing(in_=in_)</span>

    <span class="s2">def </span><span class="s1">suspend(self, in_: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0"># Need to undo local capsys-et-al if it exists before disabling global capture.</span>
        <span class="s1">self.suspend_fixture()</span>
        <span class="s1">self.suspend_global_capture(in_)</span>

    <span class="s2">def </span><span class="s1">resume(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.resume_global_capture()</span>
        <span class="s1">self.resume_fixture()</span>

    <span class="s2">def </span><span class="s1">read_global_capture(self) -&gt; CaptureResult[str]:</span>
        <span class="s2">assert </span><span class="s1">self._global_capturing </span><span class="s2">is not None</span>
        <span class="s2">return </span><span class="s1">self._global_capturing.readouterr()</span>

    <span class="s0"># Fixture Control</span>

    <span class="s2">def </span><span class="s1">set_fixture(self, capture_fixture: </span><span class="s3">&quot;CaptureFixture[Any]&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s1">current_fixture = self._capture_fixture.request.fixturename</span>
            <span class="s1">requested_fixture = capture_fixture.request.fixturename</span>
            <span class="s1">capture_fixture.request.raiseerror(</span>
                <span class="s3">&quot;cannot use {} and {} at the same time&quot;</span><span class="s1">.format(</span>
                    <span class="s1">requested_fixture, current_fixture</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">self._capture_fixture = capture_fixture</span>

    <span class="s2">def </span><span class="s1">unset_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._capture_fixture = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">activate_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;If the current item is using ``capsys`` or ``capfd``, activate 
        them so they take precedence over the global capture.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s1">self._capture_fixture._start()</span>

    <span class="s2">def </span><span class="s1">deactivate_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Deactivate the ``capsys`` or ``capfd`` fixture of this item, if any.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s1">self._capture_fixture.close()</span>

    <span class="s2">def </span><span class="s1">suspend_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s1">self._capture_fixture._suspend()</span>

    <span class="s2">def </span><span class="s1">resume_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._capture_fixture:</span>
            <span class="s1">self._capture_fixture._resume()</span>

    <span class="s0"># Helper context managers</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">global_and_fixture_disabled(self) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Context manager to temporarily disable global and current fixture capturing.&quot;&quot;&quot;</span>
        <span class="s1">do_fixture = self._capture_fixture </span><span class="s2">and </span><span class="s1">self._capture_fixture._is_started()</span>
        <span class="s2">if </span><span class="s1">do_fixture:</span>
            <span class="s1">self.suspend_fixture()</span>
        <span class="s1">do_global = self._global_capturing </span><span class="s2">and </span><span class="s1">self._global_capturing.is_started()</span>
        <span class="s2">if </span><span class="s1">do_global:</span>
            <span class="s1">self.suspend_global_capture()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">do_global:</span>
                <span class="s1">self.resume_global_capture()</span>
            <span class="s2">if </span><span class="s1">do_fixture:</span>
                <span class="s1">self.resume_fixture()</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">item_capture(self, when: str, item: Item) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s1">self.resume_global_capture()</span>
        <span class="s1">self.activate_fixture()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.deactivate_fixture()</span>
            <span class="s1">self.suspend_global_capture(in_=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">out, err = self.read_global_capture()</span>
        <span class="s1">item.add_report_section(when, </span><span class="s3">&quot;stdout&quot;</span><span class="s1">, out)</span>
        <span class="s1">item.add_report_section(when, </span><span class="s3">&quot;stderr&quot;</span><span class="s1">, err)</span>

    <span class="s0"># Hooks</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_make_collect_report(self, collector: Collector):</span>
        <span class="s2">if </span><span class="s1">isinstance(collector, File):</span>
            <span class="s1">self.resume_global_capture()</span>
            <span class="s1">outcome = </span><span class="s2">yield</span>
            <span class="s1">self.suspend_global_capture()</span>
            <span class="s1">out, err = self.read_global_capture()</span>
            <span class="s1">rep = outcome.get_result()</span>
            <span class="s2">if </span><span class="s1">out:</span>
                <span class="s1">rep.sections.append((</span><span class="s3">&quot;Captured stdout&quot;</span><span class="s1">, out))</span>
            <span class="s2">if </span><span class="s1">err:</span>
                <span class="s1">rep.sections.append((</span><span class="s3">&quot;Captured stderr&quot;</span><span class="s1">, err))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_runtest_setup(self, item: Item) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s2">with </span><span class="s1">self.item_capture(</span><span class="s3">&quot;setup&quot;</span><span class="s1">, item):</span>
            <span class="s2">yield</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_runtest_call(self, item: Item) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s2">with </span><span class="s1">self.item_capture(</span><span class="s3">&quot;call&quot;</span><span class="s1">, item):</span>
            <span class="s2">yield</span>

    <span class="s1">@hookimpl(hookwrapper=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_runtest_teardown(self, item: Item) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s2">with </span><span class="s1">self.item_capture(</span><span class="s3">&quot;teardown&quot;</span><span class="s1">, item):</span>
            <span class="s2">yield</span>

    <span class="s1">@hookimpl(tryfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_keyboard_interrupt(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.stop_global_capturing()</span>

    <span class="s1">@hookimpl(tryfirst=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pytest_internalerror(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.stop_global_capturing()</span>


<span class="s2">class </span><span class="s1">CaptureFixture(Generic[AnyStr]):</span>
    <span class="s0">&quot;&quot;&quot;Object returned by the :fixture:`capsys`, :fixture:`capsysbinary`, 
    :fixture:`capfd` and :fixture:`capfdbinary` fixtures.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self, captureclass, request: SubRequest, *, _ispytest: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s1">self.captureclass = captureclass</span>
        <span class="s1">self.request = request</span>
        <span class="s1">self._capture: Optional[MultiCapture[AnyStr]] = </span><span class="s2">None</span>
        <span class="s1">self._captured_out = self.captureclass.EMPTY_BUFFER</span>
        <span class="s1">self._captured_err = self.captureclass.EMPTY_BUFFER</span>

    <span class="s2">def </span><span class="s1">_start(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._capture = MultiCapture(</span>
                <span class="s1">in_=</span><span class="s2">None</span><span class="s1">, out=self.captureclass(</span><span class="s4">1</span><span class="s1">), err=self.captureclass(</span><span class="s4">2</span><span class="s1">),</span>
            <span class="s1">)</span>
            <span class="s1">self._capture.start_capturing()</span>

    <span class="s2">def </span><span class="s1">close(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">out, err = self._capture.pop_outerr_to_orig()</span>
            <span class="s1">self._captured_out += out</span>
            <span class="s1">self._captured_err += err</span>
            <span class="s1">self._capture.stop_capturing()</span>
            <span class="s1">self._capture = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">readouterr(self) -&gt; CaptureResult[AnyStr]:</span>
        <span class="s0">&quot;&quot;&quot;Read and return the captured output so far, resetting the internal 
        buffer. 
 
        :returns: 
            The captured content as a namedtuple with ``out`` and ``err`` 
            string attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">captured_out, captured_err = self._captured_out, self._captured_err</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">out, err = self._capture.readouterr()</span>
            <span class="s1">captured_out += out</span>
            <span class="s1">captured_err += err</span>
        <span class="s1">self._captured_out = self.captureclass.EMPTY_BUFFER</span>
        <span class="s1">self._captured_err = self.captureclass.EMPTY_BUFFER</span>
        <span class="s2">return </span><span class="s1">CaptureResult(captured_out, captured_err)</span>

    <span class="s2">def </span><span class="s1">_suspend(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Suspend this fixture's own capturing temporarily.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._capture.suspend_capturing()</span>

    <span class="s2">def </span><span class="s1">_resume(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Resume this fixture's own capturing temporarily.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._capture.resume_capturing()</span>

    <span class="s2">def </span><span class="s1">_is_started(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether actively capturing -- not disabled or closed.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._capture </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._capture.is_started()</span>
        <span class="s2">return False</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">disabled(self) -&gt; Generator[</span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Temporarily disable capturing while inside the ``with`` block.&quot;&quot;&quot;</span>
        <span class="s1">capmanager = self.request.config.pluginmanager.getplugin(</span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">capmanager.global_and_fixture_disabled():</span>
            <span class="s2">yield</span>


<span class="s0"># The fixtures.</span>


<span class="s1">@fixture</span>
<span class="s2">def </span><span class="s1">capsys(request: SubRequest) -&gt; Generator[CaptureFixture[str], </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``. 
 
    The captured output is made available via ``capsys.readouterr()`` method 
    calls, which return a ``(out, err)`` namedtuple. 
    ``out`` and ``err`` will be ``text`` objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">capman = request.config.pluginmanager.getplugin(</span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>
    <span class="s1">capture_fixture = CaptureFixture[str](SysCapture, request, _ispytest=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">capman.set_fixture(capture_fixture)</span>
    <span class="s1">capture_fixture._start()</span>
    <span class="s2">yield </span><span class="s1">capture_fixture</span>
    <span class="s1">capture_fixture.close()</span>
    <span class="s1">capman.unset_fixture()</span>


<span class="s1">@fixture</span>
<span class="s2">def </span><span class="s1">capsysbinary(request: SubRequest) -&gt; Generator[CaptureFixture[bytes], </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``. 
 
    The captured output is made available via ``capsysbinary.readouterr()`` 
    method calls, which return a ``(out, err)`` namedtuple. 
    ``out`` and ``err`` will be ``bytes`` objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">capman = request.config.pluginmanager.getplugin(</span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>
    <span class="s1">capture_fixture = CaptureFixture[bytes](SysCaptureBinary, request, _ispytest=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">capman.set_fixture(capture_fixture)</span>
    <span class="s1">capture_fixture._start()</span>
    <span class="s2">yield </span><span class="s1">capture_fixture</span>
    <span class="s1">capture_fixture.close()</span>
    <span class="s1">capman.unset_fixture()</span>


<span class="s1">@fixture</span>
<span class="s2">def </span><span class="s1">capfd(request: SubRequest) -&gt; Generator[CaptureFixture[str], </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Enable text capturing of writes to file descriptors ``1`` and ``2``. 
 
    The captured output is made available via ``capfd.readouterr()`` method 
    calls, which return a ``(out, err)`` namedtuple. 
    ``out`` and ``err`` will be ``text`` objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">capman = request.config.pluginmanager.getplugin(</span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>
    <span class="s1">capture_fixture = CaptureFixture[str](FDCapture, request, _ispytest=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">capman.set_fixture(capture_fixture)</span>
    <span class="s1">capture_fixture._start()</span>
    <span class="s2">yield </span><span class="s1">capture_fixture</span>
    <span class="s1">capture_fixture.close()</span>
    <span class="s1">capman.unset_fixture()</span>


<span class="s1">@fixture</span>
<span class="s2">def </span><span class="s1">capfdbinary(request: SubRequest) -&gt; Generator[CaptureFixture[bytes], </span><span class="s2">None</span><span class="s1">, </span><span class="s2">None</span><span class="s1">]:</span>
    <span class="s0">&quot;&quot;&quot;Enable bytes capturing of writes to file descriptors ``1`` and ``2``. 
 
    The captured output is made available via ``capfd.readouterr()`` method 
    calls, which return a ``(out, err)`` namedtuple. 
    ``out`` and ``err`` will be ``byte`` objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">capman = request.config.pluginmanager.getplugin(</span><span class="s3">&quot;capturemanager&quot;</span><span class="s1">)</span>
    <span class="s1">capture_fixture = CaptureFixture[bytes](FDCaptureBinary, request, _ispytest=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">capman.set_fixture(capture_fixture)</span>
    <span class="s1">capture_fixture._start()</span>
    <span class="s2">yield </span><span class="s1">capture_fixture</span>
    <span class="s1">capture_fixture.close()</span>
    <span class="s1">capman.unset_fixture()</span>
</pre>
</body>
</html>