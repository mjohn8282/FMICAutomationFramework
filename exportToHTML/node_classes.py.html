<html>
<head>
<title>node_classes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #d19a66;}
.s4 { color: #98c379;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_classes.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;</span>
<span class="s0"># Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2013-2014 Google, Inc.</span>
<span class="s0"># Copyright (c) 2014-2021 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2014 Eevee (Alex Munroe) &lt;amunroe@yelp.com&gt;</span>
<span class="s0"># Copyright (c) 2015-2016 Ceridwen &lt;ceridwenv@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;</span>
<span class="s0"># Copyright (c) 2016-2017 Derek Gustafson &lt;degustaf@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016 Jared Garst &lt;jgarst@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2016 Jakub Wilk &lt;jwilk@jwilk.net&gt;</span>
<span class="s0"># Copyright (c) 2016 Dave Baum &lt;dbaum@google.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2020 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2017, 2019 Łukasz Rogalski &lt;rogalski.91@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 rr- &lt;rr-@sakuya.pl&gt;</span>
<span class="s0"># Copyright (c) 2018-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Ville Skyttä &lt;ville.skytta@iki.fi&gt;</span>
<span class="s0"># Copyright (c) 2018 brendanator &lt;brendan.maginnis@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 HoverHell &lt;hoverhell@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 kavins14 &lt;kavin.singh@mail.utoronto.ca&gt;</span>
<span class="s0"># Copyright (c) 2019 kavins14 &lt;kavinsingh@hotmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Raphael Gaschignard &lt;raphael@rtpg.co&gt;</span>
<span class="s0"># Copyright (c) 2020 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;</span>

<span class="s0"># Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html</span>
<span class="s0"># For details: https://github.com/PyCQA/astroid/blob/master/LICENSE</span>

<span class="s0">&quot;&quot;&quot;Module for some node classes. More nodes in scoped_nodes.py&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">builtins </span><span class="s2">as </span><span class="s1">builtins_mod</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">pprint</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">lru_cache</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">singledispatch </span><span class="s2">as </span><span class="s1">_singledispatch</span>

<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">as_string, bases</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">context </span><span class="s2">as </span><span class="s1">contextmod</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">decorators, exceptions, manager, mixins, util</span>

<span class="s1">BUILTINS = builtins_mod.__name__</span>
<span class="s1">MANAGER = manager.AstroidManager()</span>
<span class="s1">PY38 = sys.version_info[:</span><span class="s3">2</span><span class="s1">] &gt;= (</span><span class="s3">3</span><span class="s1">, </span><span class="s3">8</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_is_const(value):</span>
    <span class="s2">return </span><span class="s1">isinstance(value, tuple(CONST_CLS))</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">unpack_infer(stmt, context=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;recursively generate nodes inferred by the given statement. 
    If the inferred value is a list or a tuple, recurse on the elements 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(stmt, (List, Tuple)):</span>
        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">stmt.elts:</span>
            <span class="s2">if </span><span class="s1">elt </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                <span class="s2">yield </span><span class="s1">elt</span>
                <span class="s2">continue</span>
            <span class="s2">yield from </span><span class="s1">unpack_infer(elt, context)</span>
        <span class="s2">return </span><span class="s1">dict(node=stmt, context=context)</span>
    <span class="s0"># if inferred is a final node, return it and stop</span>
    <span class="s1">inferred = next(stmt.infer(context))</span>
    <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is </span><span class="s1">stmt:</span>
        <span class="s2">yield </span><span class="s1">inferred</span>
        <span class="s2">return </span><span class="s1">dict(node=stmt, context=context)</span>
    <span class="s0"># else, infer recursively, except Uninferable object that should be returned as is</span>
    <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">stmt.infer(context):</span>
        <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
            <span class="s2">yield </span><span class="s1">inferred</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield from </span><span class="s1">unpack_infer(inferred, context)</span>

    <span class="s2">return </span><span class="s1">dict(node=stmt, context=context)</span>


<span class="s2">def </span><span class="s1">are_exclusive(</span>
    <span class="s1">stmt1, stmt2, exceptions=</span><span class="s2">None</span>
<span class="s1">):  </span><span class="s0"># pylint: disable=redefined-outer-name</span>
    <span class="s0">&quot;&quot;&quot;return true if the two given statements are mutually exclusive 
 
    `exceptions` may be a list of exception names. If specified, discard If 
    branches and check one of the statement is in an exception handler catching 
    one of the given exceptions. 
 
    algorithm : 
     1) index stmt1's parents 
     2) climb among stmt2's parents until we find a common parent 
     3) if the common parent is a If or TryExcept statement, look if nodes are 
        in exclusive branches 
    &quot;&quot;&quot;</span>
    <span class="s0"># index stmt1's parents</span>
    <span class="s1">stmt1_parents = {}</span>
    <span class="s1">children = {}</span>
    <span class="s1">node = stmt1.parent</span>
    <span class="s1">previous = stmt1</span>
    <span class="s2">while </span><span class="s1">node:</span>
        <span class="s1">stmt1_parents[node] = </span><span class="s3">1</span>
        <span class="s1">children[node] = previous</span>
        <span class="s1">previous = node</span>
        <span class="s1">node = node.parent</span>
    <span class="s0"># climb among stmt2's parents until we find a common parent</span>
    <span class="s1">node = stmt2.parent</span>
    <span class="s1">previous = stmt2</span>
    <span class="s2">while </span><span class="s1">node:</span>
        <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">stmt1_parents:</span>
            <span class="s0"># if the common parent is a If or TryExcept statement, look if</span>
            <span class="s0"># nodes are in exclusive branches</span>
            <span class="s2">if </span><span class="s1">isinstance(node, If) </span><span class="s2">and </span><span class="s1">exceptions </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">node.locate_child(previous)[</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s2">is not </span><span class="s1">node.locate_child(children[node])[</span><span class="s3">1</span><span class="s1">]</span>
                <span class="s1">):</span>
                    <span class="s2">return True</span>
            <span class="s2">elif </span><span class="s1">isinstance(node, TryExcept):</span>
                <span class="s1">c2attr, c2node = node.locate_child(previous)</span>
                <span class="s1">c1attr, c1node = node.locate_child(children[node])</span>
                <span class="s2">if </span><span class="s1">c1node </span><span class="s2">is not </span><span class="s1">c2node:</span>
                    <span class="s1">first_in_body_caught_by_handlers = (</span>
                        <span class="s1">c2attr == </span><span class="s4">&quot;handlers&quot;</span>
                        <span class="s2">and </span><span class="s1">c1attr == </span><span class="s4">&quot;body&quot;</span>
                        <span class="s2">and </span><span class="s1">previous.catch(exceptions)</span>
                    <span class="s1">)</span>
                    <span class="s1">second_in_body_caught_by_handlers = (</span>
                        <span class="s1">c2attr == </span><span class="s4">&quot;body&quot;</span>
                        <span class="s2">and </span><span class="s1">c1attr == </span><span class="s4">&quot;handlers&quot;</span>
                        <span class="s2">and </span><span class="s1">children[node].catch(exceptions)</span>
                    <span class="s1">)</span>
                    <span class="s1">first_in_else_other_in_handlers = (</span>
                        <span class="s1">c2attr == </span><span class="s4">&quot;handlers&quot; </span><span class="s2">and </span><span class="s1">c1attr == </span><span class="s4">&quot;orelse&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">second_in_else_other_in_handlers = (</span>
                        <span class="s1">c2attr == </span><span class="s4">&quot;orelse&quot; </span><span class="s2">and </span><span class="s1">c1attr == </span><span class="s4">&quot;handlers&quot;</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">any(</span>
                        <span class="s1">(</span>
                            <span class="s1">first_in_body_caught_by_handlers,</span>
                            <span class="s1">second_in_body_caught_by_handlers,</span>
                            <span class="s1">first_in_else_other_in_handlers,</span>
                            <span class="s1">second_in_else_other_in_handlers,</span>
                        <span class="s1">)</span>
                    <span class="s1">):</span>
                        <span class="s2">return True</span>
                <span class="s2">elif </span><span class="s1">c2attr == </span><span class="s4">&quot;handlers&quot; </span><span class="s2">and </span><span class="s1">c1attr == </span><span class="s4">&quot;handlers&quot;</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">previous </span><span class="s2">is not </span><span class="s1">children[node]</span>
            <span class="s2">return False</span>
        <span class="s1">previous = node</span>
        <span class="s1">node = node.parent</span>
    <span class="s2">return False</span>


<span class="s0"># getitem() helpers.</span>

<span class="s1">_SLICE_SENTINEL = object()</span>


<span class="s2">def </span><span class="s1">_slice_value(index, context=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Get the value of the given slice index.&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">isinstance(index, Const):</span>
        <span class="s2">if </span><span class="s1">isinstance(index.value, (int, type(</span><span class="s2">None</span><span class="s1">))):</span>
            <span class="s2">return </span><span class="s1">index.value</span>
    <span class="s2">elif </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># Try to infer what the index actually is.</span>
        <span class="s0"># Since we can't return all the possible values,</span>
        <span class="s0"># we'll stop at the first possible value.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">inferred = next(index.infer(context=context))</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(inferred, Const):</span>
                <span class="s2">if </span><span class="s1">isinstance(inferred.value, (int, type(</span><span class="s2">None</span><span class="s1">))):</span>
                    <span class="s2">return </span><span class="s1">inferred.value</span>

    <span class="s0"># Use a sentinel, because None can be a valid</span>
    <span class="s0"># value that this function can return,</span>
    <span class="s0"># as it is the case for unspecified bounds.</span>
    <span class="s2">return </span><span class="s1">_SLICE_SENTINEL</span>


<span class="s2">def </span><span class="s1">_infer_slice(node, context=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">lower = _slice_value(node.lower, context)</span>
    <span class="s1">upper = _slice_value(node.upper, context)</span>
    <span class="s1">step = _slice_value(node.step, context)</span>
    <span class="s2">if </span><span class="s1">all(elem </span><span class="s2">is not </span><span class="s1">_SLICE_SENTINEL </span><span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">(lower, upper, step)):</span>
        <span class="s2">return </span><span class="s1">slice(lower, upper, step)</span>

    <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span>
        <span class="s1">message=</span><span class="s4">&quot;Could not infer slice used in subscript&quot;</span><span class="s1">,</span>
        <span class="s1">node=node,</span>
        <span class="s1">index=node.parent,</span>
        <span class="s1">context=context,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_container_getitem(instance, elts, index, context=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Get a slice or an item, using the given *index*, for the given sequence.&quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(index, Slice):</span>
            <span class="s1">index_slice = _infer_slice(index, context=context)</span>
            <span class="s1">new_cls = instance.__class__()</span>
            <span class="s1">new_cls.elts = elts[index_slice]</span>
            <span class="s1">new_cls.parent = instance.parent</span>
            <span class="s2">return </span><span class="s1">new_cls</span>
        <span class="s2">if </span><span class="s1">isinstance(index, Const):</span>
            <span class="s2">return </span><span class="s1">elts[index.value]</span>
    <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">exc:</span>
        <span class="s2">raise </span><span class="s1">exceptions.AstroidIndexError(</span>
            <span class="s1">message=</span><span class="s4">&quot;Index {index!s} out of range&quot;</span><span class="s1">,</span>
            <span class="s1">node=instance,</span>
            <span class="s1">index=index,</span>
            <span class="s1">context=context,</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
    <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">exc:</span>
        <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span>
            <span class="s1">message=</span><span class="s4">&quot;Type error {error!r}&quot;</span><span class="s1">, node=instance, index=index, context=context</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>

    <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span><span class="s4">&quot;Could not use %s as subscript index&quot; </span><span class="s1">% index)</span>


<span class="s1">OP_PRECEDENCE = {</span>
    <span class="s1">op: precedence</span>
    <span class="s2">for </span><span class="s1">precedence, ops </span><span class="s2">in </span><span class="s1">enumerate(</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s4">&quot;Lambda&quot;</span><span class="s1">],  </span><span class="s0"># lambda x: x + 1</span>
            <span class="s1">[</span><span class="s4">&quot;IfExp&quot;</span><span class="s1">],  </span><span class="s0"># 1 if True else 2</span>
            <span class="s1">[</span><span class="s4">&quot;or&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;and&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;not&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;Compare&quot;</span><span class="s1">],  </span><span class="s0"># in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</span>
            <span class="s1">[</span><span class="s4">&quot;|&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;^&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;&amp;&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;&lt;&lt;&quot;</span><span class="s1">, </span><span class="s4">&quot;&gt;&gt;&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;+&quot;</span><span class="s1">, </span><span class="s4">&quot;-&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;*&quot;</span><span class="s1">, </span><span class="s4">&quot;@&quot;</span><span class="s1">, </span><span class="s4">&quot;/&quot;</span><span class="s1">, </span><span class="s4">&quot;//&quot;</span><span class="s1">, </span><span class="s4">&quot;%&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;UnaryOp&quot;</span><span class="s1">],  </span><span class="s0"># +, -, ~</span>
            <span class="s1">[</span><span class="s4">&quot;**&quot;</span><span class="s1">],</span>
            <span class="s1">[</span><span class="s4">&quot;Await&quot;</span><span class="s1">],</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">for </span><span class="s1">op </span><span class="s2">in </span><span class="s1">ops</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">NodeNG:</span>
    <span class="s0">&quot;&quot;&quot;A node of the new Abstract Syntax Tree (AST). 
 
    This is the base class for all Astroid node classes. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_statement = </span><span class="s2">False</span>
    <span class="s4">&quot;&quot;&quot;Whether this node indicates a statement. 
 
    :type: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">optional_assign = </span><span class="s2">False  </span><span class="s0"># True for For (and for Comprehension if py &lt;3.0)</span>
    <span class="s4">&quot;&quot;&quot;Whether this node optionally assigns a variable. 
 
    This is for loop assignments because loop won't necessarily perform an 
    assignment if the loop has no iterations. 
    This is also the case from comprehensions in Python 2. 
 
    :type: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">is_function = </span><span class="s2">False  </span><span class="s0"># True for FunctionDef nodes</span>
    <span class="s4">&quot;&quot;&quot;Whether this node indicates a function. 
 
    :type: bool 
    &quot;&quot;&quot;</span>
    <span class="s1">is_lambda = </span><span class="s2">False</span>
    <span class="s0"># Attributes below are set by the builder module or by raw factories</span>
    <span class="s1">lineno = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The line that this node appears on in the source code. 
 
    :type: int or None 
    &quot;&quot;&quot;</span>
    <span class="s1">col_offset = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The column that this node appears on in the source code. 
 
    :type: int or None 
    &quot;&quot;&quot;</span>
    <span class="s1">parent = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The parent node in the syntax tree. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">_astroid_fields = ()</span>
    <span class="s4">&quot;&quot;&quot;Node attributes that contain child nodes. 
 
    This is redefined in most concrete classes. 
 
    :type: tuple(str) 
    &quot;&quot;&quot;</span>
    <span class="s1">_other_fields = ()</span>
    <span class="s4">&quot;&quot;&quot;Node attributes that do not contain child nodes. 
 
    :type: tuple(str) 
    &quot;&quot;&quot;</span>
    <span class="s1">_other_other_fields = ()</span>
    <span class="s4">&quot;&quot;&quot;Attributes that contain AST-dependent fields. 
 
    :type: tuple(str) 
    &quot;&quot;&quot;</span>
    <span class="s0"># instance specific inference function infer(node, context)</span>
    <span class="s1">_explicit_inference = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.lineno = lineno</span>
        <span class="s1">self.col_offset = col_offset</span>
        <span class="s1">self.parent = parent</span>

    <span class="s2">def </span><span class="s1">infer(self, context=</span><span class="s2">None</span><span class="s1">, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Get a generator of the inferred values. 
 
        This is the main entry point to the inference system. 
 
        .. seealso:: :ref:`inference` 
 
        If the instance has some explicit inference function set, it will be 
        called instead of the default interface. 
 
        :returns: The inferred values. 
        :rtype: iterable 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">context </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">context = context.extra_context.get(self, context)</span>
        <span class="s2">if </span><span class="s1">self._explicit_inference </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s0"># explicit_inference is not bound, give it self explicitly</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s0"># pylint: disable=not-callable</span>
                <span class="s2">yield from </span><span class="s1">self._explicit_inference(self, context, **kwargs)</span>
                <span class="s2">return</span>
            <span class="s2">except </span><span class="s1">exceptions.UseInferenceDefault:</span>
                <span class="s2">pass</span>

        <span class="s2">if not </span><span class="s1">context:</span>
            <span class="s2">yield from </span><span class="s1">self._infer(context, **kwargs)</span>
            <span class="s2">return</span>

        <span class="s1">key = (self, context.lookupname, context.callcontext, context.boundnode)</span>
        <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">context.inferred:</span>
            <span class="s2">yield from </span><span class="s1">context.inferred[key]</span>
            <span class="s2">return</span>

        <span class="s1">generator = self._infer(context, **kwargs)</span>
        <span class="s1">results = []</span>

        <span class="s0"># Limit inference amount to help with performance issues with</span>
        <span class="s0"># exponentially exploding possible results.</span>
        <span class="s1">limit = MANAGER.max_inferable_values</span>
        <span class="s2">for </span><span class="s1">i, result </span><span class="s2">in </span><span class="s1">enumerate(generator):</span>
            <span class="s2">if </span><span class="s1">i &gt;= limit:</span>
                <span class="s2">yield </span><span class="s1">util.Uninferable</span>
                <span class="s2">break</span>
            <span class="s1">results.append(result)</span>
            <span class="s2">yield </span><span class="s1">result</span>

        <span class="s0"># Cache generated results for subsequent inferences of the</span>
        <span class="s0"># same node using the same context</span>
        <span class="s1">context.inferred[key] = tuple(results)</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">_repr_name(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a name for nice representation. 
 
        This is either :attr:`name`, :attr:`attrname`, or the empty string. 
 
        :returns: The nice name. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s1">names = {</span><span class="s4">&quot;name&quot;</span><span class="s1">, </span><span class="s4">&quot;attrname&quot;</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">all(name </span><span class="s2">not in </span><span class="s1">self._astroid_fields </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names):</span>
            <span class="s2">return </span><span class="s1">getattr(self, </span><span class="s4">&quot;name&quot;</span><span class="s1">, getattr(self, </span><span class="s4">&quot;attrname&quot;</span><span class="s1">, </span><span class="s4">&quot;&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s4">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">rname = self._repr_name()</span>
        <span class="s1">cname = type(self).__name__</span>
        <span class="s2">if </span><span class="s1">rname:</span>
            <span class="s1">string = </span><span class="s4">&quot;%(cname)s.%(rname)s(%(fields)s)&quot;</span>
            <span class="s1">alignment = len(cname) + len(rname) + </span><span class="s3">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">string = </span><span class="s4">&quot;%(cname)s(%(fields)s)&quot;</span>
            <span class="s1">alignment = len(cname) + </span><span class="s3">1</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._other_fields + self._astroid_fields:</span>
            <span class="s1">value = getattr(self, field)</span>
            <span class="s1">width = </span><span class="s3">80 </span><span class="s1">- len(field) - alignment</span>
            <span class="s1">lines = pprint.pformat(value, indent=</span><span class="s3">2</span><span class="s1">, width=width).splitlines(</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s1">inner = [lines[</span><span class="s3">0</span><span class="s1">]]</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines[</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">inner.append(</span><span class="s4">&quot; &quot; </span><span class="s1">* alignment + line)</span>
            <span class="s1">result.append(</span><span class="s4">&quot;{}={}&quot;</span><span class="s1">.format(field, </span><span class="s4">&quot;&quot;</span><span class="s1">.join(inner)))</span>

        <span class="s2">return </span><span class="s1">string % {</span>
            <span class="s4">&quot;cname&quot;</span><span class="s1">: cname,</span>
            <span class="s4">&quot;rname&quot;</span><span class="s1">: rname,</span>
            <span class="s4">&quot;fields&quot;</span><span class="s1">: (</span><span class="s4">&quot;,</span><span class="s5">\n</span><span class="s4">&quot; </span><span class="s1">+ </span><span class="s4">&quot; &quot; </span><span class="s1">* alignment).join(result),</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">rname = self._repr_name()</span>
        <span class="s2">if </span><span class="s1">rname:</span>
            <span class="s1">string = </span><span class="s4">&quot;&lt;%(cname)s.%(rname)s l.%(lineno)s at 0x%(id)x&gt;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">string = </span><span class="s4">&quot;&lt;%(cname)s l.%(lineno)s at 0x%(id)x&gt;&quot;</span>
        <span class="s2">return </span><span class="s1">string % {</span>
            <span class="s4">&quot;cname&quot;</span><span class="s1">: type(self).__name__,</span>
            <span class="s4">&quot;rname&quot;</span><span class="s1">: rname,</span>
            <span class="s4">&quot;lineno&quot;</span><span class="s1">: self.fromlineno,</span>
            <span class="s4">&quot;id&quot;</span><span class="s1">: id(self),</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">accept(self, visitor):</span>
        <span class="s0">&quot;&quot;&quot;Visit this node using the given visitor.&quot;&quot;&quot;</span>
        <span class="s1">func = getattr(visitor, </span><span class="s4">&quot;visit_&quot; </span><span class="s1">+ self.__class__.__name__.lower())</span>
        <span class="s2">return </span><span class="s1">func(self)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the child nodes below this node. 
 
        :returns: The children. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._astroid_fields:</span>
            <span class="s1">attr = getattr(self, field)</span>
            <span class="s2">if </span><span class="s1">attr </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance(attr, (list, tuple)):</span>
                <span class="s2">yield from </span><span class="s1">attr</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">attr</span>

    <span class="s2">def </span><span class="s1">last_child(self):</span>
        <span class="s0">&quot;&quot;&quot;An optimized version of list(get_children())[-1] 
 
        :returns: The last child, or None if no children exist. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._astroid_fields[::-</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s1">attr = getattr(self, field)</span>
            <span class="s2">if not </span><span class="s1">attr:  </span><span class="s0"># None or empty listy / tuple</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">isinstance(attr, (list, tuple)):</span>
                <span class="s2">return </span><span class="s1">attr[-</span><span class="s3">1</span><span class="s1">]</span>

            <span class="s2">return </span><span class="s1">attr</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parent_of(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Check if this node is the parent of the given node. 
 
        :param node: The node to check if it is the child. 
        :type node: NodeNG 
 
        :returns: True if this node is the parent of the given node, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">parent = node.parent</span>
        <span class="s2">while </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self </span><span class="s2">is </span><span class="s1">parent:</span>
                <span class="s2">return True</span>
            <span class="s1">parent = parent.parent</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">statement(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent node, including self, marked as statement node. 
 
        :returns: The first parent statement. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.is_statement:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">self.parent.statement()</span>

    <span class="s2">def </span><span class="s1">frame(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent frame node. 
 
        A frame node is a :class:`Module`, :class:`FunctionDef`, 
        or :class:`ClassDef`. 
 
        :returns: The first parent frame node. 
        :rtype: Module or FunctionDef or ClassDef 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parent.frame()</span>

    <span class="s2">def </span><span class="s1">scope(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent node defining a new scope. 
 
        :returns: The first parent scope node. 
        :rtype: Module or FunctionDef or ClassDef or Lambda or GenExpr 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.parent:</span>
            <span class="s2">return </span><span class="s1">self.parent.scope()</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">root(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the root node of the syntax tree. 
 
        :returns: The root node. 
        :rtype: Module 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.parent:</span>
            <span class="s2">return </span><span class="s1">self.parent.root()</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">child_sequence(self, child):</span>
        <span class="s0">&quot;&quot;&quot;Search for the sequence that contains this child. 
 
        :param child: The child node to search sequences for. 
        :type child: NodeNG 
 
        :returns: The sequence containing the given child node. 
        :rtype: iterable(NodeNG) 
 
        :raises AstroidError: If no sequence could be found that contains 
            the given child. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._astroid_fields:</span>
            <span class="s1">node_or_sequence = getattr(self, field)</span>
            <span class="s2">if </span><span class="s1">node_or_sequence </span><span class="s2">is </span><span class="s1">child:</span>
                <span class="s2">return </span><span class="s1">[node_or_sequence]</span>
            <span class="s0"># /!\ compiler.ast Nodes have an __iter__ walking over child nodes</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(node_or_sequence, (tuple, list))</span>
                <span class="s2">and </span><span class="s1">child </span><span class="s2">in </span><span class="s1">node_or_sequence</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">node_or_sequence</span>

        <span class="s1">msg = </span><span class="s4">&quot;Could not find %s in %s's children&quot;</span>
        <span class="s2">raise </span><span class="s1">exceptions.AstroidError(msg % (repr(child), repr(self)))</span>

    <span class="s2">def </span><span class="s1">locate_child(self, child):</span>
        <span class="s0">&quot;&quot;&quot;Find the field of this node that contains the given child. 
 
        :param child: The child node to search fields for. 
        :type child: NodeNG 
 
        :returns: A tuple of the name of the field that contains the child, 
            and the sequence or node that contains the child node. 
        :rtype: tuple(str, iterable(NodeNG) or NodeNG) 
 
        :raises AstroidError: If no field could be found that contains 
            the given child. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">self._astroid_fields:</span>
            <span class="s1">node_or_sequence = getattr(self, field)</span>
            <span class="s0"># /!\ compiler.ast Nodes have an __iter__ walking over child nodes</span>
            <span class="s2">if </span><span class="s1">child </span><span class="s2">is </span><span class="s1">node_or_sequence:</span>
                <span class="s2">return </span><span class="s1">field, child</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(node_or_sequence, (tuple, list))</span>
                <span class="s2">and </span><span class="s1">child </span><span class="s2">in </span><span class="s1">node_or_sequence</span>
            <span class="s1">):</span>
                <span class="s2">return </span><span class="s1">field, node_or_sequence</span>
        <span class="s1">msg = </span><span class="s4">&quot;Could not find %s in %s's children&quot;</span>
        <span class="s2">raise </span><span class="s1">exceptions.AstroidError(msg % (repr(child), repr(self)))</span>

    <span class="s0"># FIXME : should we merge child_sequence and locate_child ? locate_child</span>
    <span class="s0"># is only used in are_exclusive, child_sequence one time in pylint.</span>

    <span class="s2">def </span><span class="s1">next_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The next sibling statement node. 
 
        :returns: The next sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parent.next_sibling()</span>

    <span class="s2">def </span><span class="s1">previous_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The previous sibling statement. 
 
        :returns: The previous sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.parent.previous_sibling()</span>

    <span class="s0"># these are lazy because they're relatively expensive to compute for every</span>
    <span class="s0"># single node, and they rarely get looked at</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">fromlineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The first line that this node appears on in the source code. 
 
        :type: int or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.lineno </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._fixed_source_line()</span>

        <span class="s2">return </span><span class="s1">self.lineno</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The last line that this node appears on in the source code. 
 
        :type: int or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._astroid_fields:</span>
            <span class="s0"># can't have children</span>
            <span class="s1">lastchild = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lastchild = self.last_child()</span>
        <span class="s2">if </span><span class="s1">lastchild </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fromlineno</span>

        <span class="s2">return </span><span class="s1">lastchild.tolineno</span>

    <span class="s2">def </span><span class="s1">_fixed_source_line(self):</span>
        <span class="s0">&quot;&quot;&quot;Attempt to find the line that this node appears on. 
 
        We need this method since not all nodes have :attr:`lineno` set. 
 
        :returns: The line number of this node, 
            or None if this could not be determined. 
        :rtype: int or None 
        &quot;&quot;&quot;</span>
        <span class="s1">line = self.lineno</span>
        <span class="s1">_node = self</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s1">line </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">_node = next(_node.get_children())</span>
                <span class="s1">line = _node.lineno</span>
        <span class="s2">except </span><span class="s1">StopIteration:</span>
            <span class="s1">_node = self.parent</span>
            <span class="s2">while </span><span class="s1">_node </span><span class="s2">and </span><span class="s1">line </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">line = _node.lineno</span>
                <span class="s1">_node = _node.parent</span>
        <span class="s2">return </span><span class="s1">line</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: The line number to start the range at. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
            starting at the given line number. 
        :rtype: tuple(int, int or None) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">lineno, self.tolineno</span>

    <span class="s2">def </span><span class="s1">set_local(self, name, stmt):</span>
        <span class="s0">&quot;&quot;&quot;Define that the given name is declared in the given statement node. 
 
        This definition is stored on the parent scope node. 
 
        .. seealso:: :meth:`scope` 
 
        :param name: The name that is being defined. 
        :type name: str 
 
        :param stmt: The statement that defines the given name. 
        :type stmt: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parent.set_local(name, stmt)</span>

    <span class="s2">def </span><span class="s1">nodes_of_class(self, klass, skip_klass=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the nodes (including this one or below) of the given types. 
 
        :param klass: The types of node to search for. 
        :type klass: builtins.type or tuple(builtins.type) 
 
        :param skip_klass: The types of node to ignore. This is useful to ignore 
            subclasses of :attr:`klass`. 
        :type skip_klass: builtins.type or tuple(builtins.type) 
 
        :returns: The node of the given types. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self, klass):</span>
            <span class="s2">yield </span><span class="s1">self</span>

        <span class="s2">if </span><span class="s1">skip_klass </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.get_children():</span>
                <span class="s2">yield from </span><span class="s1">child_node.nodes_of_class(klass, skip_klass)</span>

            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s2">if </span><span class="s1">isinstance(child_node, skip_klass):</span>
                <span class="s2">continue</span>
            <span class="s2">yield from </span><span class="s1">child_node.nodes_of_class(klass, skip_klass)</span>

    <span class="s1">@decorators.cached</span>
    <span class="s2">def </span><span class="s1">_get_assign_nodes(self):</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_get_name_nodes(self):</span>
        <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s2">yield from </span><span class="s1">child_node._get_name_nodes()</span>

    <span class="s2">def </span><span class="s1">_get_return_nodes_skip_functions(self):</span>
        <span class="s2">yield from </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s2">yield from </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">_infer_name(self, frame, name):</span>
        <span class="s0"># overridden for ImportFrom, Import, Global, TryExcept and Arguments</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_infer(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;we don't know how to resolve a statement by default&quot;&quot;&quot;</span>
        <span class="s0"># this method is overridden by most concrete classes</span>
        <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
            <span class="s4">&quot;No inference function for {node!r}.&quot;</span><span class="s1">, node=self, context=context</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">inferred(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of the inferred values. 
 
        .. seealso:: :ref:`inference` 
 
        :returns: The inferred values. 
        :rtype: list 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self.infer())</span>

    <span class="s2">def </span><span class="s1">instantiate_class(self):</span>
        <span class="s0">&quot;&quot;&quot;Instantiate an instance of the defined class. 
 
        .. note:: 
 
            On anything other than a :class:`ClassDef` this will return self. 
 
        :returns: An instance of the defined class. 
        :rtype: object 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">has_base(self, node):</span>
        <span class="s0">&quot;&quot;&quot;Check if this node inherits from the given type. 
 
        :param node: The node defining the base to look for. 
            Usually this is a :class:`Name` node. 
        :type node: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">callable(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether this node defines something that is callable. 
 
        :returns: True if this defines something that is callable, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">eq(self, value):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">as_string(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the source code that this node represents. 
 
        :returns: The source code. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">as_string.to_code(self)</span>

    <span class="s2">def </span><span class="s1">repr_tree(</span>
        <span class="s1">self,</span>
        <span class="s1">ids=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">include_linenos=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">ast_state=</span><span class="s2">False</span><span class="s1">,</span>
        <span class="s1">indent=</span><span class="s4">&quot;   &quot;</span><span class="s1">,</span>
        <span class="s1">max_depth=</span><span class="s3">0</span><span class="s1">,</span>
        <span class="s1">max_width=</span><span class="s3">80</span><span class="s1">,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get a string representation of the AST from this node. 
 
        :param ids: If true, includes the ids with the node type names. 
        :type ids: bool 
 
        :param include_linenos: If true, includes the line numbers and 
            column offsets. 
        :type include_linenos: bool 
 
        :param ast_state: If true, includes information derived from 
            the whole AST like local and global variables. 
        :type ast_state: bool 
 
        :param indent: A string to use to indent the output string. 
        :type indent: str 
 
        :param max_depth: If set to a positive integer, won't return 
            nodes deeper than max_depth in the string. 
        :type max_depth: int 
 
        :param max_width: Attempt to format the output string to stay 
            within this number of characters, but can exceed it under some 
            circumstances. Only positive integer values are valid, the default is 80. 
        :type max_width: int 
 
        :returns: The string representation of the AST. 
        :rtype: str 
        &quot;&quot;&quot;</span>

        <span class="s1">@_singledispatch</span>
        <span class="s2">def </span><span class="s1">_repr_tree(node, result, done, cur_indent=</span><span class="s4">&quot;&quot;</span><span class="s1">, depth=</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot;Outputs a representation of a non-tuple/list, non-node that's 
            contained within an AST, including strings. 
            &quot;&quot;&quot;</span>
            <span class="s1">lines = pprint.pformat(</span>
                <span class="s1">node, width=max(max_width - len(cur_indent), </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">).splitlines(</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">result.append(lines[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">result.extend([cur_indent + line </span><span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines[</span><span class="s3">1</span><span class="s1">:]])</span>
            <span class="s2">return </span><span class="s1">len(lines) != </span><span class="s3">1</span>

        <span class="s0"># pylint: disable=unused-variable,useless-suppression; doesn't understand singledispatch</span>
        <span class="s1">@_repr_tree.register(tuple)</span>
        <span class="s1">@_repr_tree.register(list)</span>
        <span class="s2">def </span><span class="s1">_repr_seq(node, result, done, cur_indent=</span><span class="s4">&quot;&quot;</span><span class="s1">, depth=</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot;Outputs a representation of a sequence that's contained within an AST.&quot;&quot;&quot;</span>
            <span class="s1">cur_indent += indent</span>
            <span class="s1">result.append(</span><span class="s4">&quot;[&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">node:</span>
                <span class="s1">broken = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">len(node) == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">broken = _repr_tree(node[</span><span class="s3">0</span><span class="s1">], result, done, cur_indent, depth)</span>
            <span class="s2">elif </span><span class="s1">len(node) == </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s1">broken = _repr_tree(node[</span><span class="s3">0</span><span class="s1">], result, done, cur_indent, depth)</span>
                <span class="s2">if not </span><span class="s1">broken:</span>
                    <span class="s1">result.append(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">result.append(</span><span class="s4">&quot;,</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                    <span class="s1">result.append(cur_indent)</span>
                <span class="s1">broken = _repr_tree(node[</span><span class="s3">1</span><span class="s1">], result, done, cur_indent, depth) </span><span class="s2">or </span><span class="s1">broken</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">result.append(cur_indent)</span>
                <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">node[:-</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s1">_repr_tree(child, result, done, cur_indent, depth)</span>
                    <span class="s1">result.append(</span><span class="s4">&quot;,</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                    <span class="s1">result.append(cur_indent)</span>
                <span class="s1">_repr_tree(node[-</span><span class="s3">1</span><span class="s1">], result, done, cur_indent, depth)</span>
                <span class="s1">broken = </span><span class="s2">True</span>
            <span class="s1">result.append(</span><span class="s4">&quot;]&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">broken</span>

        <span class="s0"># pylint: disable=unused-variable,useless-suppression; doesn't understand singledispatch</span>
        <span class="s1">@_repr_tree.register(NodeNG)</span>
        <span class="s2">def </span><span class="s1">_repr_node(node, result, done, cur_indent=</span><span class="s4">&quot;&quot;</span><span class="s1">, depth=</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot;Outputs a strings representation of an astroid node.&quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">node </span><span class="s2">in </span><span class="s1">done:</span>
                <span class="s1">result.append(</span>
                    <span class="s1">indent</span>
                    <span class="s1">+ </span><span class="s4">&quot;&lt;Recursion on {} with id={}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">type(node).__name__, id(node)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s2">return False</span>
            <span class="s1">done.add(node)</span>

            <span class="s2">if </span><span class="s1">max_depth </span><span class="s2">and </span><span class="s1">depth &gt; max_depth:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;...&quot;</span><span class="s1">)</span>
                <span class="s2">return False</span>
            <span class="s1">depth += </span><span class="s3">1</span>
            <span class="s1">cur_indent += indent</span>
            <span class="s2">if </span><span class="s1">ids:</span>
                <span class="s1">result.append(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">type(node).__name__</span><span class="s5">}</span><span class="s4">&lt;0x</span><span class="s5">{</span><span class="s1">id(node)</span><span class="s5">:</span><span class="s4">x</span><span class="s5">}</span><span class="s4">&gt;(</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;%s(&quot; </span><span class="s1">% type(node).__name__)</span>
            <span class="s1">fields = []</span>
            <span class="s2">if </span><span class="s1">include_linenos:</span>
                <span class="s1">fields.extend((</span><span class="s4">&quot;lineno&quot;</span><span class="s1">, </span><span class="s4">&quot;col_offset&quot;</span><span class="s1">))</span>
            <span class="s1">fields.extend(node._other_fields)</span>
            <span class="s1">fields.extend(node._astroid_fields)</span>
            <span class="s2">if </span><span class="s1">ast_state:</span>
                <span class="s1">fields.extend(node._other_other_fields)</span>
            <span class="s2">if not </span><span class="s1">fields:</span>
                <span class="s1">broken = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">len(fields) == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;%s=&quot; </span><span class="s1">% fields[</span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">broken = _repr_tree(</span>
                    <span class="s1">getattr(node, fields[</span><span class="s3">0</span><span class="s1">]), result, done, cur_indent, depth</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s1">result.append(cur_indent)</span>
                <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields[:-</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s1">result.append(</span><span class="s4">&quot;%s=&quot; </span><span class="s1">% field)</span>
                    <span class="s1">_repr_tree(getattr(node, field), result, done, cur_indent, depth)</span>
                    <span class="s1">result.append(</span><span class="s4">&quot;,</span><span class="s5">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
                    <span class="s1">result.append(cur_indent)</span>
                <span class="s1">result.append(</span><span class="s4">&quot;%s=&quot; </span><span class="s1">% fields[-</span><span class="s3">1</span><span class="s1">])</span>
                <span class="s1">_repr_tree(getattr(node, fields[-</span><span class="s3">1</span><span class="s1">]), result, done, cur_indent, depth)</span>
                <span class="s1">broken = </span><span class="s2">True</span>
            <span class="s1">result.append(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">broken</span>

        <span class="s1">result = []</span>
        <span class="s1">_repr_tree(self, result, set())</span>
        <span class="s2">return </span><span class="s4">&quot;&quot;</span><span class="s1">.join(result)</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        The boolean value of a node can have three 
        possible values: 
 
            * False: For instance, empty data structures, 
              False, empty strings, instances which return 
              explicitly False from the __nonzero__ / __bool__ 
              method. 
            * True: Most of constructs are True by default: 
              classes, functions, modules etc 
            * Uninferable: The inference engine is uncertain of the 
              node's value. 
 
        :returns: The boolean value of this node. 
        :rtype: bool or Uninferable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">util.Uninferable</span>

    <span class="s2">def </span><span class="s1">op_precedence(self):</span>
        <span class="s0"># Look up by class name or default to highest precedence</span>
        <span class="s2">return </span><span class="s1">OP_PRECEDENCE.get(self.__class__.__name__, len(OP_PRECEDENCE))</span>

    <span class="s2">def </span><span class="s1">op_left_associative(self):</span>
        <span class="s0"># Everything is left associative except `**` and IfExp</span>
        <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">Statement(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Statement node adding a few attributes&quot;&quot;&quot;</span>

    <span class="s1">is_statement = </span><span class="s2">True</span>
    <span class="s4">&quot;&quot;&quot;Whether this node indicates a statement. 
 
    :type: bool 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">next_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The next sibling statement node. 
 
        :returns: The next sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">stmts = self.parent.child_sequence(self)</span>
        <span class="s1">index = stmts.index(self)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">stmts[index + </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">previous_sibling(self):</span>
        <span class="s0">&quot;&quot;&quot;The previous sibling statement. 
 
        :returns: The previous sibling statement node. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">stmts = self.parent.child_sequence(self)</span>
        <span class="s1">index = stmts.index(self)</span>
        <span class="s2">if </span><span class="s1">index &gt;= </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">stmts[index - </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">_BaseContainer(</span>
    <span class="s1">mixins.ParentAssignTypeMixin, NodeNG, bases.Instance, metaclass=abc.ABCMeta</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Base class for Set, FrozenSet, Tuple and List.&quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;elts&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.elts = []</span>
        <span class="s4">&quot;&quot;&quot;The elements in the node. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, elts):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param elts: The list of elements the that node contains. 
        :type elts: list(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.elts = elts</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_elements(cls, elts=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a node of this type from the given list of elements. 
 
        :param elts: The list of elements that the node should contain. 
        :type elts: list(NodeNG) 
 
        :returns: A new node containing the given elements. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s1">node = cls()</span>
        <span class="s2">if </span><span class="s1">elts </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">node.elts = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node.elts = [const_factory(e) </span><span class="s2">if </span><span class="s1">_is_const(e) </span><span class="s2">else </span><span class="s1">e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">elts]</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">itered(self):</span>
        <span class="s0">&quot;&quot;&quot;An iterator over the elements this node contains. 
 
        :returns: The contents of this node. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.elts</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
        :rtype: bool or Uninferable 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self.elts)</span>

    <span class="s1">@abc.abstractmethod</span>
    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.elts</span>


<span class="s2">class </span><span class="s1">LookupMixIn:</span>
    <span class="s0">&quot;&quot;&quot;Mixin to look up a name in the right scope.&quot;&quot;&quot;</span>

    <span class="s1">@lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">lookup(self, name):</span>
        <span class="s0">&quot;&quot;&quot;Lookup where the given variable is assigned. 
 
        The lookup starts from self's scope. If self is not a frame itself 
        and the name is found in the inner frame locals, statements will be 
        filtered to remove ignorable statements according to self's location. 
 
        :param name: The name of the variable to find assignments for. 
        :type name: str 
 
        :returns: The scope node and the list of assignments associated to the 
            given name according to the scope where it has been found (locals, 
            globals or builtin). 
        :rtype: tuple(str, list(NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.scope().scope_lookup(self, name)</span>

    <span class="s2">def </span><span class="s1">ilookup(self, name):</span>
        <span class="s0">&quot;&quot;&quot;Lookup the inferred values of the given variable. 
 
        :param name: The variable name to find values for. 
        :type name: str 
 
        :returns: The inferred values of the statements returned from 
            :meth:`lookup`. 
        :rtype: iterable 
        &quot;&quot;&quot;</span>
        <span class="s1">frame, stmts = self.lookup(name)</span>
        <span class="s1">context = contextmod.InferenceContext()</span>
        <span class="s2">return </span><span class="s1">bases._infer_stmts(stmts, context, frame)</span>

    <span class="s2">def </span><span class="s1">_get_filtered_node_statements(self, nodes):</span>
        <span class="s1">statements = [(node, node.statement()) </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">nodes]</span>
        <span class="s0"># Next we check if we have ExceptHandlers that are parent</span>
        <span class="s0"># of the underlying variable, in which case the last one survives</span>
        <span class="s2">if </span><span class="s1">len(statements) &gt; </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">all(</span>
            <span class="s1">isinstance(stmt, ExceptHandler) </span><span class="s2">for </span><span class="s1">_, stmt </span><span class="s2">in </span><span class="s1">statements</span>
        <span class="s1">):</span>
            <span class="s1">statements = [</span>
                <span class="s1">(node, stmt) </span><span class="s2">for </span><span class="s1">node, stmt </span><span class="s2">in </span><span class="s1">statements </span><span class="s2">if </span><span class="s1">stmt.parent_of(self)</span>
            <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">statements</span>

    <span class="s2">def </span><span class="s1">_filter_stmts(self, stmts, frame, offset):</span>
        <span class="s0">&quot;&quot;&quot;Filter the given list of statements to remove ignorable statements. 
 
        If self is not a frame itself and the name is found in the inner 
        frame locals, statements will be filtered to remove ignorable 
        statements according to self's location. 
 
        :param stmts: The statements to filter. 
        :type stmts: list(NodeNG) 
 
        :param frame: The frame that all of the given statements belong to. 
        :type frame: NodeNG 
 
        :param offset: The line offset to filter statements up to. 
        :type offset: int 
 
        :returns: The filtered statements. 
        :rtype: list(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s0"># if offset == -1, my actual frame is not the inner frame but its parent</span>
        <span class="s0">#</span>
        <span class="s0"># class A(B): pass</span>
        <span class="s0">#</span>
        <span class="s0"># we need this to resolve B correctly</span>
        <span class="s2">if </span><span class="s1">offset == -</span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">myframe = self.frame().parent.frame()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">myframe = self.frame()</span>
            <span class="s0"># If the frame of this node is the same as the statement</span>
            <span class="s0"># of this node, then the node is part of a class or</span>
            <span class="s0"># a function definition and the frame of this node should be the</span>
            <span class="s0"># the upper frame, not the frame of the definition.</span>
            <span class="s0"># For more information why this is important,</span>
            <span class="s0"># see Pylint issue #295.</span>
            <span class="s0"># For example, for 'b', the statement is the same</span>
            <span class="s0"># as the frame / scope:</span>
            <span class="s0">#</span>
            <span class="s0"># def test(b=1):</span>
            <span class="s0">#     ...</span>

            <span class="s2">if </span><span class="s1">self.statement() </span><span class="s2">is </span><span class="s1">myframe </span><span class="s2">and </span><span class="s1">myframe.parent:</span>
                <span class="s1">myframe = myframe.parent.frame()</span>
        <span class="s1">mystmt = self.statement()</span>
        <span class="s0"># line filtering if we are in the same frame</span>
        <span class="s0">#</span>
        <span class="s0"># take care node may be missing lineno information (this is the case for</span>
        <span class="s0"># nodes inserted for living objects)</span>
        <span class="s2">if </span><span class="s1">myframe </span><span class="s2">is </span><span class="s1">frame </span><span class="s2">and </span><span class="s1">mystmt.fromlineno </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">mystmt.fromlineno </span><span class="s2">is not None</span><span class="s1">, mystmt</span>
            <span class="s1">mylineno = mystmt.fromlineno + offset</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># disabling lineno filtering</span>
            <span class="s1">mylineno = </span><span class="s3">0</span>

        <span class="s1">_stmts = []</span>
        <span class="s1">_stmt_parents = []</span>
        <span class="s1">statements = self._get_filtered_node_statements(stmts)</span>
        <span class="s2">for </span><span class="s1">node, stmt </span><span class="s2">in </span><span class="s1">statements:</span>
            <span class="s0"># line filtering is on and we have reached our location, break</span>
            <span class="s2">if </span><span class="s1">stmt.fromlineno </span><span class="s2">and </span><span class="s1">stmt.fromlineno &gt; mylineno &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s0"># Ignore decorators with the same name as the</span>
            <span class="s0"># decorated function</span>
            <span class="s0"># Fixes issue #375</span>
            <span class="s2">if </span><span class="s1">mystmt </span><span class="s2">is </span><span class="s1">stmt </span><span class="s2">and </span><span class="s1">is_from_decorator(self):</span>
                <span class="s2">continue</span>
            <span class="s2">assert </span><span class="s1">hasattr(node, </span><span class="s4">&quot;assign_type&quot;</span><span class="s1">), (</span>
                <span class="s1">node,</span>
                <span class="s1">node.scope(),</span>
                <span class="s1">node.scope().locals,</span>
            <span class="s1">)</span>
            <span class="s1">assign_type = node.assign_type()</span>
            <span class="s2">if </span><span class="s1">node.has_base(self):</span>
                <span class="s2">break</span>

            <span class="s1">_stmts, done = assign_type._get_filtered_stmts(self, node, _stmts, mystmt)</span>
            <span class="s2">if </span><span class="s1">done:</span>
                <span class="s2">break</span>

            <span class="s1">optional_assign = assign_type.optional_assign</span>
            <span class="s2">if </span><span class="s1">optional_assign </span><span class="s2">and </span><span class="s1">assign_type.parent_of(self):</span>
                <span class="s0"># we are inside a loop, loop var assignment is hiding previous</span>
                <span class="s0"># assignment</span>
                <span class="s1">_stmts = [node]</span>
                <span class="s1">_stmt_parents = [stmt.parent]</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">isinstance(assign_type, NamedExpr):</span>
                <span class="s1">_stmts = [node]</span>
                <span class="s2">continue</span>

            <span class="s0"># XXX comment various branches below!!!</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">pindex = _stmt_parents.index(stmt.parent)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># we got a parent index, this means the currently visited node</span>
                <span class="s0"># is at the same block level as a previously visited node</span>
                <span class="s2">if </span><span class="s1">_stmts[pindex].assign_type().parent_of(assign_type):</span>
                    <span class="s0"># both statements are not at the same block level</span>
                    <span class="s2">continue</span>
                <span class="s0"># if currently visited node is following previously considered</span>
                <span class="s0"># assignment and both are not exclusive, we can drop the</span>
                <span class="s0"># previous one. For instance in the following code ::</span>
                <span class="s0">#</span>
                <span class="s0">#   if a:</span>
                <span class="s0">#     x = 1</span>
                <span class="s0">#   else:</span>
                <span class="s0">#     x = 2</span>
                <span class="s0">#   print x</span>
                <span class="s0">#</span>
                <span class="s0"># we can't remove neither x = 1 nor x = 2 when looking for 'x'</span>
                <span class="s0"># of 'print x'; while in the following ::</span>
                <span class="s0">#</span>
                <span class="s0">#   x = 1</span>
                <span class="s0">#   x = 2</span>
                <span class="s0">#   print x</span>
                <span class="s0">#</span>
                <span class="s0"># we can remove x = 1 when we see x = 2</span>
                <span class="s0">#</span>
                <span class="s0"># moreover, on loop assignment types, assignment won't</span>
                <span class="s0"># necessarily be done if the loop has no iteration, so we don't</span>
                <span class="s0"># want to clear previous assignments if any (hence the test on</span>
                <span class="s0"># optional_assign)</span>
                <span class="s2">if not </span><span class="s1">(optional_assign </span><span class="s2">or </span><span class="s1">are_exclusive(_stmts[pindex], node)):</span>
                    <span class="s2">if </span><span class="s1">(</span>
                        <span class="s0"># In case of partial function node, if the statement is different</span>
                        <span class="s0"># from the origin function then it can be deleted otherwise it should</span>
                        <span class="s0"># remain to be able to correctly infer the call to origin function.</span>
                        <span class="s2">not </span><span class="s1">node.is_function</span>
                        <span class="s2">or </span><span class="s1">node.qname() != </span><span class="s4">&quot;PartialFunction&quot;</span>
                        <span class="s2">or </span><span class="s1">node.name != _stmts[pindex].name</span>
                    <span class="s1">):</span>
                        <span class="s2">del </span><span class="s1">_stmt_parents[pindex]</span>
                        <span class="s2">del </span><span class="s1">_stmts[pindex]</span>
            <span class="s2">if </span><span class="s1">isinstance(node, AssignName):</span>
                <span class="s2">if not </span><span class="s1">optional_assign </span><span class="s2">and </span><span class="s1">stmt.parent </span><span class="s2">is </span><span class="s1">mystmt.parent:</span>
                    <span class="s1">_stmts = []</span>
                    <span class="s1">_stmt_parents = []</span>
            <span class="s2">elif </span><span class="s1">isinstance(node, DelName):</span>
                <span class="s1">_stmts = []</span>
                <span class="s1">_stmt_parents = []</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">are_exclusive(self, node):</span>
                <span class="s1">_stmts.append(node)</span>
                <span class="s1">_stmt_parents.append(stmt.parent)</span>
        <span class="s2">return </span><span class="s1">_stmts</span>


<span class="s0"># Name classes</span>


<span class="s2">class </span><span class="s1">AssignName(</span>
    <span class="s1">mixins.NoChildrenMixin, LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Variation of :class:`ast.Assign` representing assignment to a name. 
 
    An :class:`AssignName` is the name of something that is assigned to. 
    This includes variables defined in a function signature or in a loop. 
 
    &gt;&gt;&gt; node = astroid.extract_node('variable = range(10)') 
    &gt;&gt;&gt; node 
    &lt;Assign l.1 at 0x7effe1db8550&gt; 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;AssignName.variable l.1 at 0x7effe1db8748&gt;, &lt;Call l.1 at 0x7effe1db8630&gt;] 
    &gt;&gt;&gt; list(node.get_children())[0].as_string() 
    'variable' 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;name&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, name=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name that is assigned to. 
        :type name: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s4">&quot;&quot;&quot;The name that is assigned to. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>


<span class="s2">class </span><span class="s1">DelName(</span>
    <span class="s1">mixins.NoChildrenMixin, LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Variation of :class:`ast.Delete` representing deletion of a name. 
 
    A :class:`DelName` is the name of something that is deleted. 
 
    &gt;&gt;&gt; node = astroid.extract_node(&quot;del variable #@&quot;) 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;DelName.variable l.1 at 0x7effe1da4d30&gt;] 
    &gt;&gt;&gt; list(node.get_children())[0].as_string() 
    'variable' 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;name&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, name=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name that is being deleted. 
        :type name: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s4">&quot;&quot;&quot;The name that is being deleted. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>


<span class="s2">class </span><span class="s1">Name(mixins.NoChildrenMixin, LookupMixIn, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Name` node. 
 
    A :class:`Name` node is something that is named, but not covered by 
    :class:`AssignName` or :class:`DelName`. 
 
    &gt;&gt;&gt; node = astroid.extract_node('range(10)') 
    &gt;&gt;&gt; node 
    &lt;Call l.1 at 0x7effe1db8710&gt; 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;Name.range l.1 at 0x7effe1db86a0&gt;, &lt;Const.int l.1 at 0x7effe1db8518&gt;] 
    &gt;&gt;&gt; list(node.get_children())[0].as_string() 
    'range' 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;name&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, name=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param name: The name that this node refers to. 
        :type name: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s4">&quot;&quot;&quot;The name that this node refers to. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">_get_name_nodes(self):</span>
        <span class="s2">yield </span><span class="s1">self</span>

        <span class="s2">for </span><span class="s1">child_node </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s2">yield from </span><span class="s1">child_node._get_name_nodes()</span>


<span class="s2">class </span><span class="s1">Arguments(mixins.AssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.arguments` node. 
 
    An :class:`Arguments` node represents that arguments in a 
    function definition. 
 
    &gt;&gt;&gt; node = astroid.extract_node('def foo(bar): pass') 
    &gt;&gt;&gt; node 
    &lt;FunctionDef.foo l.1 at 0x7effe1db8198&gt; 
    &gt;&gt;&gt; node.args 
    &lt;Arguments l.1 at 0x7effe1db82e8&gt; 
    &quot;&quot;&quot;</span>

    <span class="s0"># Python 3.4+ uses a different approach regarding annotations,</span>
    <span class="s0"># each argument is a new class, _ast.arg, which exposes an</span>
    <span class="s0"># 'annotation' attribute. In astroid though, arguments are exposed</span>
    <span class="s0"># as is in the Arguments node and the only way to expose annotations</span>
    <span class="s0"># is by using something similar with Python 3.3:</span>
    <span class="s0">#  - we expose 'varargannotation' and 'kwargannotation' of annotations</span>
    <span class="s0">#    of varargs and kwargs.</span>
    <span class="s0">#  - we expose 'annotation', a list with annotations for</span>
    <span class="s0">#    for each normal argument. If an argument doesn't have an</span>
    <span class="s0">#    annotation, its value will be None.</span>
    <span class="s0"># pylint: disable=too-many-instance-attributes</span>
    <span class="s1">_astroid_fields = (</span>
        <span class="s4">&quot;args&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;defaults&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;kwonlyargs&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;posonlyargs&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;posonlyargs_annotations&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;kw_defaults&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;annotations&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;varargannotation&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;kwargannotation&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;kwonlyargs_annotations&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;type_comment_args&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;type_comment_kwonlyargs&quot;</span><span class="s1">,</span>
        <span class="s4">&quot;type_comment_posonlyargs&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>
    <span class="s1">varargannotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The type annotation for the variable length arguments. 
 
    :type: NodeNG 
    &quot;&quot;&quot;</span>
    <span class="s1">kwargannotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The type annotation for the variable length keyword arguments. 
 
    :type: NodeNG 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;vararg&quot;</span><span class="s1">, </span><span class="s4">&quot;kwarg&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self, vararg=</span><span class="s2">None</span><span class="s1">, kwarg=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param vararg: The name of the variable length arguments. 
        :type vararg: str or None 
 
        :param kwarg: The name of the variable length keyword arguments. 
        :type kwarg: str or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(parent=parent)</span>
        <span class="s1">self.vararg = vararg</span>
        <span class="s4">&quot;&quot;&quot;The name of the variable length arguments. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.kwarg = kwarg</span>
        <span class="s4">&quot;&quot;&quot;The name of the variable length keyword arguments. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.args = []</span>
        <span class="s4">&quot;&quot;&quot;The names of the required arguments. 
 
        :type: list(AssignName) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.defaults = []</span>
        <span class="s4">&quot;&quot;&quot;The default values for arguments that can be passed positionally. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.kwonlyargs = []</span>
        <span class="s4">&quot;&quot;&quot;The keyword arguments that cannot be passed positionally. 
 
        :type: list(AssignName) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.posonlyargs = []</span>
        <span class="s4">&quot;&quot;&quot;The arguments that can only be passed positionally. 
 
        :type: list(AssignName) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.kw_defaults = []</span>
        <span class="s4">&quot;&quot;&quot;The default values for keyword arguments that cannot be passed positionally. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.annotations = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotations of arguments that can be passed positionally. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.posonlyargs_annotations = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotations of arguments that can only be passed positionally. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.kwonlyargs_annotations = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotations of arguments that cannot be passed positionally. 
 
        :type: list(NodeNG) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.type_comment_args = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotation, passed by a type comment, of each argument. 
 
        If an argument does not have a type comment, 
        the value for that argument will be None. 
 
        :type: list(NodeNG or None) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.type_comment_kwonlyargs = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotation, passed by a type comment, of each keyword only argument. 
 
        If an argument does not have a type comment, 
        the value for that argument will be None. 
 
        :type: list(NodeNG or None) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.type_comment_posonlyargs = []</span>
        <span class="s4">&quot;&quot;&quot;The type annotation, passed by a type comment, of each positional argument. 
 
        If an argument does not have a type comment, 
        the value for that argument will be None. 
 
        :type: list(NodeNG or None) 
        &quot;&quot;&quot;</span>

    <span class="s0"># pylint: disable=too-many-arguments</span>
    <span class="s2">def </span><span class="s1">postinit(</span>
        <span class="s1">self,</span>
        <span class="s1">args,</span>
        <span class="s1">defaults,</span>
        <span class="s1">kwonlyargs,</span>
        <span class="s1">kw_defaults,</span>
        <span class="s1">annotations,</span>
        <span class="s1">posonlyargs=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">kwonlyargs_annotations=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">posonlyargs_annotations=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">varargannotation=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">kwargannotation=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type_comment_args=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type_comment_kwonlyargs=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">type_comment_posonlyargs=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param args: The names of the required arguments. 
        :type args: list(AssignName) 
 
        :param defaults: The default values for arguments that can be passed 
            positionally. 
        :type defaults: list(NodeNG) 
 
        :param kwonlyargs: The keyword arguments that cannot be passed 
            positionally. 
        :type kwonlyargs: list(AssignName) 
 
        :param posonlyargs: The arguments that can only be passed 
            positionally. 
        :type kwonlyargs: list(AssignName) 
 
        :param kw_defaults: The default values for keyword arguments that 
            cannot be passed positionally. 
        :type kw_defaults: list(NodeNG) 
 
        :param annotations: The type annotations of arguments that can be 
            passed positionally. 
        :type annotations: list(NodeNG) 
 
        :param kwonlyargs_annotations: The type annotations of arguments that 
            cannot be passed positionally. This should always be passed in 
            Python 3. 
        :type kwonlyargs_annotations: list(NodeNG) 
 
        :param posonlyargs_annotations: The type annotations of arguments that 
            can only be passed positionally. This should always be passed in 
            Python 3. 
        :type posonlyargs_annotations: list(NodeNG) 
 
        :param varargannotation: The type annotation for the variable length 
            arguments. 
        :type varargannotation: NodeNG 
 
        :param kwargannotation: The type annotation for the variable length 
            keyword arguments. 
        :type kwargannotation: NodeNG 
 
        :param type_comment_args: The type annotation, 
            passed by a type comment, of each argument. 
        :type type_comment_args: list(NodeNG or None) 
 
        :param type_comment_args: The type annotation, 
            passed by a type comment, of each keyword only argument. 
        :type type_comment_args: list(NodeNG or None) 
 
        :param type_comment_args: The type annotation, 
            passed by a type comment, of each positional argument. 
        :type type_comment_args: list(NodeNG or None) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.defaults = defaults</span>
        <span class="s1">self.kwonlyargs = kwonlyargs</span>
        <span class="s1">self.posonlyargs = posonlyargs</span>
        <span class="s1">self.kw_defaults = kw_defaults</span>
        <span class="s1">self.annotations = annotations</span>
        <span class="s1">self.kwonlyargs_annotations = kwonlyargs_annotations</span>
        <span class="s1">self.posonlyargs_annotations = posonlyargs_annotations</span>
        <span class="s1">self.varargannotation = varargannotation</span>
        <span class="s1">self.kwargannotation = kwargannotation</span>
        <span class="s1">self.type_comment_args = type_comment_args</span>
        <span class="s1">self.type_comment_kwonlyargs = type_comment_kwonlyargs</span>
        <span class="s1">self.type_comment_posonlyargs = type_comment_posonlyargs</span>

    <span class="s2">def </span><span class="s1">_infer_name(self, frame, name):</span>
        <span class="s2">if </span><span class="s1">self.parent </span><span class="s2">is </span><span class="s1">frame:</span>
            <span class="s2">return </span><span class="s1">name</span>
        <span class="s2">return None</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">fromlineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The first line that this node appears on in the source code. 
 
        :type: int or None 
        &quot;&quot;&quot;</span>
        <span class="s1">lineno = super().fromlineno</span>
        <span class="s2">return </span><span class="s1">max(lineno, self.parent.fromlineno </span><span class="s2">or </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">arguments(self):</span>
        <span class="s0">&quot;&quot;&quot;Get all the arguments for this node, including positional only and positional and keyword&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(itertools.chain((self.posonlyargs </span><span class="s2">or </span><span class="s1">()), self.args </span><span class="s2">or </span><span class="s1">()))</span>

    <span class="s2">def </span><span class="s1">format_args(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the arguments formatted as string. 
 
        :returns: The formatted arguments. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s1">positional_only_defaults = []</span>
        <span class="s1">positional_or_keyword_defaults = self.defaults</span>
        <span class="s2">if </span><span class="s1">self.defaults:</span>
            <span class="s1">args = self.args </span><span class="s2">or </span><span class="s1">[]</span>
            <span class="s1">positional_or_keyword_defaults = self.defaults[-len(args) :]</span>
            <span class="s1">positional_only_defaults = self.defaults[: len(self.defaults) - len(args)]</span>

        <span class="s2">if </span><span class="s1">self.posonlyargs:</span>
            <span class="s1">result.append(</span>
                <span class="s1">_format_args(</span>
                    <span class="s1">self.posonlyargs,</span>
                    <span class="s1">positional_only_defaults,</span>
                    <span class="s1">self.posonlyargs_annotations,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">result.append(</span><span class="s4">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.args:</span>
            <span class="s1">result.append(</span>
                <span class="s1">_format_args(</span>
                    <span class="s1">self.args,</span>
                    <span class="s1">positional_or_keyword_defaults,</span>
                    <span class="s1">getattr(self, </span><span class="s4">&quot;annotations&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">),</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.vararg:</span>
            <span class="s1">result.append(</span><span class="s4">&quot;*%s&quot; </span><span class="s1">% self.vararg)</span>
        <span class="s2">if </span><span class="s1">self.kwonlyargs:</span>
            <span class="s2">if not </span><span class="s1">self.vararg:</span>
                <span class="s1">result.append(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
            <span class="s1">result.append(</span>
                <span class="s1">_format_args(</span>
                    <span class="s1">self.kwonlyargs, self.kw_defaults, self.kwonlyargs_annotations</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.kwarg:</span>
            <span class="s1">result.append(</span><span class="s4">&quot;**%s&quot; </span><span class="s1">% self.kwarg)</span>
        <span class="s2">return </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(result)</span>

    <span class="s2">def </span><span class="s1">default_value(self, argname):</span>
        <span class="s0">&quot;&quot;&quot;Get the default value for an argument. 
 
        :param argname: The name of the argument to get the default value for. 
        :type argname: str 
 
        :raises NoDefault: If there is no default value defined for the 
            given argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">args = self.arguments</span>
        <span class="s1">index = _find_arg(argname, args)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">idx = index - (len(args) - len(self.defaults))</span>
            <span class="s2">if </span><span class="s1">idx &gt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.defaults[idx]</span>
        <span class="s1">index = _find_arg(argname, self.kwonlyargs)[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is not None and </span><span class="s1">self.kw_defaults[index] </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.kw_defaults[index]</span>
        <span class="s2">raise </span><span class="s1">exceptions.NoDefault(func=self.parent, name=argname)</span>

    <span class="s2">def </span><span class="s1">is_argument(self, name):</span>
        <span class="s0">&quot;&quot;&quot;Check if the given name is defined in the arguments. 
 
        :param name: The name to check for. 
        :type name: str 
 
        :returns: True if the given name is defined in the arguments, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name == self.vararg:</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">name == self.kwarg:</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.find_argname(name, rec=</span><span class="s2">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">is not None</span>
            <span class="s2">or </span><span class="s1">self.kwonlyargs</span>
            <span class="s2">and </span><span class="s1">_find_arg(name, self.kwonlyargs, rec=</span><span class="s2">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">is not None</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">find_argname(self, argname, rec=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get the index and :class:`AssignName` node for given name. 
 
        :param argname: The name of the argument to search for. 
        :type argname: str 
 
        :param rec: Whether or not to include arguments in unpacked tuples 
            in the search. 
        :type rec: bool 
 
        :returns: The index and node for the argument. 
        :rtype: tuple(str or None, AssignName or None) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.arguments:</span>
            <span class="s2">return </span><span class="s1">_find_arg(argname, self.arguments, rec)</span>
        <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.posonlyargs </span><span class="s2">or </span><span class="s1">()</span>

        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.posonlyargs_annotations:</span>
            <span class="s2">if </span><span class="s1">elt </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">elt</span>

        <span class="s2">yield from </span><span class="s1">self.args </span><span class="s2">or </span><span class="s1">()</span>

        <span class="s2">yield from </span><span class="s1">self.defaults</span>
        <span class="s2">yield from </span><span class="s1">self.kwonlyargs</span>

        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.kw_defaults:</span>
            <span class="s2">if </span><span class="s1">elt </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">elt</span>

        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.annotations:</span>
            <span class="s2">if </span><span class="s1">elt </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">elt</span>

        <span class="s2">if </span><span class="s1">self.varargannotation </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.varargannotation</span>

        <span class="s2">if </span><span class="s1">self.kwargannotation </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.kwargannotation</span>

        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.kwonlyargs_annotations:</span>
            <span class="s2">if </span><span class="s1">elt </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">elt</span>


<span class="s2">def </span><span class="s1">_find_arg(argname, args, rec=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s2">for </span><span class="s1">i, arg </span><span class="s2">in </span><span class="s1">enumerate(args):</span>
        <span class="s2">if </span><span class="s1">isinstance(arg, Tuple):</span>
            <span class="s2">if </span><span class="s1">rec:</span>
                <span class="s1">found = _find_arg(argname, arg.elts)</span>
                <span class="s2">if </span><span class="s1">found[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">found</span>
        <span class="s2">elif </span><span class="s1">arg.name == argname:</span>
            <span class="s2">return </span><span class="s1">i, arg</span>
    <span class="s2">return None</span><span class="s1">, </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_format_args(args, defaults=</span><span class="s2">None</span><span class="s1">, annotations=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">values = []</span>
    <span class="s2">if </span><span class="s1">args </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">annotations </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">annotations = []</span>
    <span class="s2">if </span><span class="s1">defaults </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">default_offset = len(args) - len(defaults)</span>
    <span class="s1">packed = itertools.zip_longest(args, annotations)</span>
    <span class="s2">for </span><span class="s1">i, (arg, annotation) </span><span class="s2">in </span><span class="s1">enumerate(packed):</span>
        <span class="s2">if </span><span class="s1">isinstance(arg, Tuple):</span>
            <span class="s1">values.append(</span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% _format_args(arg.elts))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">argname = arg.name</span>
            <span class="s1">default_sep = </span><span class="s4">&quot;=&quot;</span>
            <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">argname += </span><span class="s4">&quot;: &quot; </span><span class="s1">+ annotation.as_string()</span>
                <span class="s1">default_sep = </span><span class="s4">&quot; = &quot;</span>
            <span class="s1">values.append(argname)</span>

            <span class="s2">if </span><span class="s1">defaults </span><span class="s2">is not None and </span><span class="s1">i &gt;= default_offset:</span>
                <span class="s2">if </span><span class="s1">defaults[i - default_offset] </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">values[-</span><span class="s3">1</span><span class="s1">] += default_sep + defaults[i - default_offset].as_string()</span>
    <span class="s2">return </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(values)</span>


<span class="s2">class </span><span class="s1">AssignAttr(mixins.ParentAssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Variation of :class:`ast.Assign` representing assignment to an attribute. 
 
    &gt;&gt;&gt; node = astroid.extract_node('self.attribute = range(10)') 
    &gt;&gt;&gt; node 
    &lt;Assign l.1 at 0x7effe1d521d0&gt; 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;AssignAttr.attribute l.1 at 0x7effe1d52320&gt;, &lt;Call l.1 at 0x7effe1d522e8&gt;] 
    &gt;&gt;&gt; list(node.get_children())[0].as_string() 
    'self.attribute' 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;expr&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;attrname&quot;</span><span class="s1">,)</span>
    <span class="s1">expr = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What has the attribute that is being assigned to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, attrname=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param attrname: The name of the attribute being assigned to. 
        :type attrname: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.attrname = attrname</span>
        <span class="s4">&quot;&quot;&quot;The name of the attribute being assigned to. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, expr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param expr: What has the attribute that is being assigned to. 
        :type expr: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.expr = expr</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.expr</span>


<span class="s2">class </span><span class="s1">Assert(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Assert` node. 
 
    An :class:`Assert` node represents an assert statement. 
 
    &gt;&gt;&gt; node = astroid.extract_node('assert len(things) == 10, &quot;Not enough things&quot;') 
    &gt;&gt;&gt; node 
    &lt;Assert l.1 at 0x7effe1d527b8&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;test&quot;</span><span class="s1">, </span><span class="s4">&quot;fail&quot;</span><span class="s1">)</span>
    <span class="s1">test = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The test that passes or fails the assertion. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">fail = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The message shown when the assertion fails. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, test=</span><span class="s2">None</span><span class="s1">, fail=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param test: The test that passes or fails the assertion. 
        :type test: NodeNG or None 
 
        :param fail: The message shown when the assertion fails. 
        :type fail: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.fail = fail</span>
        <span class="s1">self.test = test</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.test</span>

        <span class="s2">if </span><span class="s1">self.fail </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.fail</span>


<span class="s2">class </span><span class="s1">Assign(mixins.AssignTypeMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Assign` node. 
 
    An :class:`Assign` is a statement where something is explicitly 
    asssigned to. 
 
    &gt;&gt;&gt; node = astroid.extract_node('variable = range(10)') 
    &gt;&gt;&gt; node 
    &lt;Assign l.1 at 0x7effe1db8550&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;targets&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;type_annotation&quot;</span><span class="s1">,)</span>
    <span class="s1">targets = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being assigned to. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value being assigned to the variables. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">type_annotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;If present, this will contain the type annotation passed by a type comment 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, targets=</span><span class="s2">None</span><span class="s1">, value=</span><span class="s2">None</span><span class="s1">, type_annotation=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param targets: What is being assigned to. 
        :type targets: list(NodeNG) or None 
 
        :param value: The value being assigned to the variables. 
        :type: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.targets = targets</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.type_annotation = type_annotation</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.targets</span>

        <span class="s2">yield </span><span class="s1">self.value</span>

    <span class="s1">@decorators.cached</span>
    <span class="s2">def </span><span class="s1">_get_assign_nodes(self):</span>
        <span class="s2">return </span><span class="s1">[self] + list(self.value._get_assign_nodes())</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s2">yield from </span><span class="s1">self.value._get_yield_nodes_skip_lambdas()</span>


<span class="s2">class </span><span class="s1">AnnAssign(mixins.AssignTypeMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.AnnAssign` node. 
 
    An :class:`AnnAssign` is an assignment with a type annotation. 
 
    &gt;&gt;&gt; node = astroid.extract_node('variable: List[int] = range(10)') 
    &gt;&gt;&gt; node 
    &lt;AnnAssign l.1 at 0x7effe1d4c630&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;target&quot;</span><span class="s1">, </span><span class="s4">&quot;annotation&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;simple&quot;</span><span class="s1">,)</span>
    <span class="s1">target = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being assigned to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">annotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The type annotation of what is being assigned to. 
 
    :type: NodeNG 
    &quot;&quot;&quot;</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value being assigned to the variables. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">simple = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Whether :attr:`target` is a pure name or a complex statement. 
 
    :type: int 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, target, annotation, simple, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param target: What is being assigned to. 
        :type target: NodeNG 
 
        :param annotation: The type annotation of what is being assigned to. 
        :type: NodeNG 
 
        :param simple: Whether :attr:`target` is a pure name 
            or a complex statement. 
        :type simple: int 
 
        :param value: The value being assigned to the variables. 
        :type: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.annotation = annotation</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.simple = simple</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.target</span>
        <span class="s2">yield </span><span class="s1">self.annotation</span>

        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">AugAssign(mixins.AssignTypeMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.AugAssign` node. 
 
    An :class:`AugAssign` is an assignment paired with an operator. 
 
    &gt;&gt;&gt; node = astroid.extract_node('variable += 1') 
    &gt;&gt;&gt; node 
    &lt;AugAssign l.1 at 0x7effe1db4d68&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;target&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;op&quot;</span><span class="s1">,)</span>
    <span class="s1">target = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being assigned to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value being assigned to the variable. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, op=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param op: The operator that is being combined with the assignment. 
            This includes the equals sign. 
        :type op: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.op = op</span>
        <span class="s4">&quot;&quot;&quot;The operator that is being combined with the assignment. 
 
        This includes the equals sign. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, target=</span><span class="s2">None</span><span class="s1">, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param target: What is being assigned to. 
        :type target: NodeNG or None 
 
        :param value: The value being assigned to the variable. 
        :type: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.value = value</span>

    <span class="s0"># This is set by inference.py</span>
    <span class="s2">def </span><span class="s1">_infer_augassign(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">type_errors(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of type errors which can occur during inference. 
 
        Each TypeError is represented by a :class:`BadBinaryOperationMessage` , 
        which holds the original exception. 
 
        :returns: The list of possible type errors. 
        :rtype: list(BadBinaryOperationMessage) 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">results = self._infer_augassign(context=context)</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">result</span>
                <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">results</span>
                <span class="s2">if </span><span class="s1">isinstance(result, util.BadBinaryOperationMessage)</span>
            <span class="s1">]</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.target</span>
        <span class="s2">yield </span><span class="s1">self.value</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s0">&quot;&quot;&quot;An AugAssign node can contain a Yield node in the value&quot;&quot;&quot;</span>
        <span class="s2">yield from </span><span class="s1">self.value._get_yield_nodes_skip_lambdas()</span>
        <span class="s2">yield from </span><span class="s1">super()._get_yield_nodes_skip_lambdas()</span>


<span class="s2">class </span><span class="s1">Repr(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Repr` node. 
 
    A :class:`Repr` node represents the backtick syntax, 
    which is a deprecated alias for :func:`repr` removed in Python 3. 
 
    &gt;&gt;&gt; node = astroid.extract_node('`variable`') 
    &gt;&gt;&gt; node 
    &lt;Repr l.1 at 0x7fa0951d75d0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is having :func:`repr` called on it. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: What is having :func:`repr` called on it. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>


<span class="s2">class </span><span class="s1">BinOp(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.BinOp` node. 
 
    A :class:`BinOp` node is an application of a binary operator. 
 
    &gt;&gt;&gt; node = astroid.extract_node('a + b') 
    &gt;&gt;&gt; node 
    &lt;BinOp l.1 at 0x7f23b2e8cfd0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;left&quot;</span><span class="s1">, </span><span class="s4">&quot;right&quot;</span><span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;op&quot;</span><span class="s1">,)</span>
    <span class="s1">left = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being applied to the operator on the left side. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">right = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being applied to the operator on the right side. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, op=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param op: The operator. 
        :type: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.op = op</span>
        <span class="s4">&quot;&quot;&quot;The operator. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, left=</span><span class="s2">None</span><span class="s1">, right=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param left: What is being applied to the operator on the left side. 
        :type left: NodeNG or None 
 
        :param right: What is being applied to the operator on the right side. 
        :type right: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.left = left</span>
        <span class="s1">self.right = right</span>

    <span class="s0"># This is set by inference.py</span>
    <span class="s2">def </span><span class="s1">_infer_binop(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">type_errors(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of type errors which can occur during inference. 
 
        Each TypeError is represented by a :class:`BadBinaryOperationMessage`, 
        which holds the original exception. 
 
        :returns: The list of possible type errors. 
        :rtype: list(BadBinaryOperationMessage) 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">results = self._infer_binop(context=context)</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">result</span>
                <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">results</span>
                <span class="s2">if </span><span class="s1">isinstance(result, util.BadBinaryOperationMessage)</span>
            <span class="s1">]</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.left</span>
        <span class="s2">yield </span><span class="s1">self.right</span>

    <span class="s2">def </span><span class="s1">op_precedence(self):</span>
        <span class="s2">return </span><span class="s1">OP_PRECEDENCE[self.op]</span>

    <span class="s2">def </span><span class="s1">op_left_associative(self):</span>
        <span class="s0"># 2**3**4 == 2**(3**4)</span>
        <span class="s2">return </span><span class="s1">self.op != </span><span class="s4">&quot;**&quot;</span>


<span class="s2">class </span><span class="s1">BoolOp(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.BoolOp` node. 
 
    A :class:`BoolOp` is an application of a boolean operator. 
 
    &gt;&gt;&gt; node = astroid.extract_node('a and b') 
    &gt;&gt;&gt; node 
    &lt;BinOp l.1 at 0x7f23b2e71c50&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;values&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;op&quot;</span><span class="s1">,)</span>
    <span class="s1">values = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The values being applied to the operator. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, op=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param op: The operator. 
        :type: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.op = op</span>
        <span class="s4">&quot;&quot;&quot;The operator. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, values=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param values: The values being applied to the operator. 
        :type values: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.values = values</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.values</span>

    <span class="s2">def </span><span class="s1">op_precedence(self):</span>
        <span class="s2">return </span><span class="s1">OP_PRECEDENCE[self.op]</span>


<span class="s2">class </span><span class="s1">Break(mixins.NoChildrenMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Break` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('break') 
    &gt;&gt;&gt; node 
    &lt;Break l.1 at 0x7f23b2e9e5c0&gt; 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Call(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Call` node. 
 
    A :class:`Call` node is a call to a function, method, etc. 
 
    &gt;&gt;&gt; node = astroid.extract_node('function()') 
    &gt;&gt;&gt; node 
    &lt;Call l.1 at 0x7f23b2e71eb8&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;func&quot;</span><span class="s1">, </span><span class="s4">&quot;args&quot;</span><span class="s1">, </span><span class="s4">&quot;keywords&quot;</span><span class="s1">)</span>
    <span class="s1">func = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being called. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">args = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The positional arguments being given to the call. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">keywords = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The keyword arguments being given to the call. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, func=</span><span class="s2">None</span><span class="s1">, args=</span><span class="s2">None</span><span class="s1">, keywords=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param func: What is being called. 
        :type func: NodeNG or None 
 
        :param args: The positional arguments being given to the call. 
        :type args: list(NodeNG) or None 
 
        :param keywords: The keyword arguments being given to the call. 
        :type keywords: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.keywords = keywords</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">starargs(self):</span>
        <span class="s0">&quot;&quot;&quot;The positional arguments that unpack something. 
 
        :type: list(Starred) 
        &quot;&quot;&quot;</span>
        <span class="s1">args = self.args </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[arg </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args </span><span class="s2">if </span><span class="s1">isinstance(arg, Starred)]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">kwargs(self):</span>
        <span class="s0">&quot;&quot;&quot;The keyword arguments that unpack something. 
 
        :type: list(Keyword) 
        &quot;&quot;&quot;</span>
        <span class="s1">keywords = self.keywords </span><span class="s2">or </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">[keyword </span><span class="s2">for </span><span class="s1">keyword </span><span class="s2">in </span><span class="s1">keywords </span><span class="s2">if </span><span class="s1">keyword.arg </span><span class="s2">is None</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.func</span>

        <span class="s2">yield from </span><span class="s1">self.args</span>

        <span class="s2">yield from </span><span class="s1">self.keywords </span><span class="s2">or </span><span class="s1">()</span>


<span class="s2">class </span><span class="s1">Compare(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Compare` node. 
 
    A :class:`Compare` node indicates a comparison. 
 
    &gt;&gt;&gt; node = astroid.extract_node('a &lt;= b &lt;= c') 
    &gt;&gt;&gt; node 
    &lt;Compare l.1 at 0x7f23b2e9e6d8&gt; 
    &gt;&gt;&gt; node.ops 
    [('&lt;=', &lt;Name.b l.1 at 0x7f23b2e9e2b0&gt;), ('&lt;=', &lt;Name.c l.1 at 0x7f23b2e9e390&gt;)] 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;left&quot;</span><span class="s1">, </span><span class="s4">&quot;ops&quot;</span><span class="s1">)</span>
    <span class="s1">left = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value at the left being applied to a comparison operator. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">ops = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The remainder of the operators and their relevant right hand value. 
 
    :type: list(tuple(str, NodeNG)) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, left=</span><span class="s2">None</span><span class="s1">, ops=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param left: The value at the left being applied to a comparison 
            operator. 
        :type left: NodeNG or None 
 
        :param ops: The remainder of the operators 
            and their relevant right hand value. 
        :type ops: list(tuple(str, NodeNG)) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.left = left</span>
        <span class="s1">self.ops = ops</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the child nodes below this node. 
 
        Overridden to handle the tuple fields and skip returning the operator 
        strings. 
 
        :returns: The children. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">yield </span><span class="s1">self.left</span>
        <span class="s2">for </span><span class="s1">_, comparator </span><span class="s2">in </span><span class="s1">self.ops:</span>
            <span class="s2">yield </span><span class="s1">comparator  </span><span class="s0"># we don't want the 'op'</span>

    <span class="s2">def </span><span class="s1">last_child(self):</span>
        <span class="s0">&quot;&quot;&quot;An optimized version of list(get_children())[-1] 
 
        :returns: The last child. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s0"># XXX maybe if self.ops:</span>
        <span class="s2">return </span><span class="s1">self.ops[-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0"># return self.left</span>


<span class="s2">class </span><span class="s1">Comprehension(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.comprehension` node. 
 
    A :class:`Comprehension` indicates the loop inside any type of 
    comprehension including generator expressions. 
 
    &gt;&gt;&gt; node = astroid.extract_node('[x for x in some_values]') 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;Name.x l.1 at 0x7f23b2e352b0&gt;, &lt;Comprehension l.1 at 0x7f23b2e35320&gt;] 
    &gt;&gt;&gt; list(node.get_children())[1].as_string() 
    'for x in some_values' 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;target&quot;</span><span class="s1">, </span><span class="s4">&quot;iter&quot;</span><span class="s1">, </span><span class="s4">&quot;ifs&quot;</span><span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;is_async&quot;</span><span class="s1">,)</span>
    <span class="s1">target = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is assigned to by the comprehension. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">iter = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is iterated over by the comprehension. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">ifs = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of any if statements that filter the comprehension. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">is_async = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Whether this is an asynchronous comprehension or not. 
 
    :type: bool or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.parent = parent</span>

    <span class="s0"># pylint: disable=redefined-builtin; same name as builtin ast module.</span>
    <span class="s2">def </span><span class="s1">postinit(self, target=</span><span class="s2">None</span><span class="s1">, iter=</span><span class="s2">None</span><span class="s1">, ifs=</span><span class="s2">None</span><span class="s1">, is_async=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param target: What is assigned to by the comprehension. 
        :type target: NodeNG or None 
 
        :param iter: What is iterated over by the comprehension. 
        :type iter: NodeNG or None 
 
        :param ifs: The contents of any if statements that filter 
            the comprehension. 
        :type ifs: list(NodeNG) or None 
 
        :param is_async: Whether this is an asynchronous comprehension or not. 
        :type: bool or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.iter = iter</span>
        <span class="s1">self.ifs = ifs</span>
        <span class="s1">self.is_async = is_async</span>

    <span class="s1">optional_assign = </span><span class="s2">True</span>
    <span class="s4">&quot;&quot;&quot;Whether this node optionally assigns a variable. 
 
    :type: bool 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">assign_type(self):</span>
        <span class="s0">&quot;&quot;&quot;The type of assignment that this node performs. 
 
        :returns: The assignment type. 
        :rtype: NodeNG 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">_get_filtered_stmts(self, lookup_node, node, stmts, mystmt):</span>
        <span class="s0">&quot;&quot;&quot;method used in filter_stmts&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self </span><span class="s2">is </span><span class="s1">mystmt:</span>
            <span class="s2">if </span><span class="s1">isinstance(lookup_node, (Const, Name)):</span>
                <span class="s2">return </span><span class="s1">[lookup_node], </span><span class="s2">True</span>

        <span class="s2">elif </span><span class="s1">self.statement() </span><span class="s2">is </span><span class="s1">mystmt:</span>
            <span class="s0"># original node's statement is the assignment, only keeps</span>
            <span class="s0"># current node (gen exp, list comp)</span>

            <span class="s2">return </span><span class="s1">[node], </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">stmts, </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.target</span>
        <span class="s2">yield </span><span class="s1">self.iter</span>

        <span class="s2">yield from </span><span class="s1">self.ifs</span>


<span class="s2">class </span><span class="s1">Const(mixins.NoChildrenMixin, NodeNG, bases.Instance):</span>
    <span class="s0">&quot;&quot;&quot;Class representing any constant including num, str, bool, None, bytes. 
 
    &gt;&gt;&gt; node = astroid.extract_node('(5, &quot;This is a string.&quot;, True, None, b&quot;bytes&quot;)') 
    &gt;&gt;&gt; node 
    &lt;Tuple.tuple l.1 at 0x7f23b2e358d0&gt; 
    &gt;&gt;&gt; list(node.get_children()) 
    [&lt;Const.int l.1 at 0x7f23b2e35940&gt;, 
    &lt;Const.str l.1 at 0x7f23b2e35978&gt;, 
    &lt;Const.bool l.1 at 0x7f23b2e359b0&gt;, 
    &lt;Const.NoneType l.1 at 0x7f23b2e359e8&gt;, 
    &lt;Const.bytes l.1 at 0x7f23b2e35a20&gt;] 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, value, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param value: The value that the constant represents. 
        :type value: object 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>
        <span class="s4">&quot;&quot;&quot;The value that the constant represents. 
 
        :type: object 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self, name):</span>
        <span class="s0"># This is needed because of Proxy's __getattr__ method.</span>
        <span class="s0"># Calling object.__new__ on this class without calling</span>
        <span class="s0"># __init__ would result in an infinite loop otherwise</span>
        <span class="s0"># since __getattr__ is called when an attribute doesn't</span>
        <span class="s0"># exist and self._proxied indirectly calls self.value</span>
        <span class="s0"># and Proxy __getattr__ calls self.value</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s4">&quot;value&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError</span>
        <span class="s2">return </span><span class="s1">super().__getattr__(name)</span>

    <span class="s2">def </span><span class="s1">getitem(self, index, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get an item from this node if subscriptable. 
 
        :param index: The node to use as a subscript index. 
        :type index: Const or Slice 
 
        :raises AstroidTypeError: When the given index cannot be used as a 
            subscript index, or if this node is not subscriptable. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(index, Const):</span>
            <span class="s1">index_value = index.value</span>
        <span class="s2">elif </span><span class="s1">isinstance(index, Slice):</span>
            <span class="s1">index_value = _infer_slice(index, context=context)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span>
                <span class="s4">f&quot;Could not use type </span><span class="s5">{</span><span class="s1">type(index)</span><span class="s5">} </span><span class="s4">as subscript index&quot;</span>
            <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.value, (str, bytes)):</span>
                <span class="s2">return </span><span class="s1">Const(self.value[index_value])</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AstroidIndexError(</span>
                <span class="s1">message=</span><span class="s4">&quot;Index {index!r} out of range&quot;</span><span class="s1">,</span>
                <span class="s1">node=self,</span>
                <span class="s1">index=index,</span>
                <span class="s1">context=context,</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span>
                <span class="s1">message=</span><span class="s4">&quot;Type error {error!r}&quot;</span><span class="s1">, node=self, index=index, context=context</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>

        <span class="s2">raise </span><span class="s1">exceptions.AstroidTypeError(</span><span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">self</span><span class="s5">!r} </span><span class="s4">(value=</span><span class="s5">{</span><span class="s1">self.value</span><span class="s5">}</span><span class="s4">)&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">has_dynamic_getattr(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if the node has a custom __getattr__ or __getattribute__. 
 
        :returns: True if the class has a custom 
            __getattr__ or __getattribute__, False otherwise. 
            For a :class:`Const` this is always ``False``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">itered(self):</span>
        <span class="s0">&quot;&quot;&quot;An iterator over the elements this node contains. 
 
        :returns: The contents of this node. 
        :rtype: iterable(Const) 
 
        :raises TypeError: If this node does not represent something that is iterable. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.value, str):</span>
            <span class="s2">return </span><span class="s1">[const_factory(elem) </span><span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">self.value]</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Cannot iterate over type </span><span class="s5">{</span><span class="s1">type(self.value)</span><span class="s5">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._proxied.qname()</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self.value)</span>


<span class="s2">class </span><span class="s1">Continue(mixins.NoChildrenMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Continue` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('continue') 
    &gt;&gt;&gt; node 
    &lt;Continue l.1 at 0x7f23b2e35588&gt; 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Decorators(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;A node representing a list of decorators. 
 
    A :class:`Decorators` is the decorators that are applied to 
    a method or function. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    @property 
    def my_property(self): 
        return 3 
    ''') 
    &gt;&gt;&gt; node 
    &lt;FunctionDef.my_property l.2 at 0x7f23b2e35d30&gt; 
    &gt;&gt;&gt; list(node.get_children())[0] 
    &lt;Decorators l.1 at 0x7f23b2e35d68&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;nodes&quot;</span><span class="s1">,)</span>
    <span class="s1">nodes = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The decorators that this node contains. 
 
    :type: list(Name or Call) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, nodes):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param nodes: The decorators that this node contains. 
        :type nodes: list(Name or Call) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.nodes = nodes</span>

    <span class="s2">def </span><span class="s1">scope(self):</span>
        <span class="s0">&quot;&quot;&quot;The first parent node defining a new scope. 
 
        :returns: The first parent scope node. 
        :rtype: Module or FunctionDef or ClassDef or Lambda or GenExpr 
        &quot;&quot;&quot;</span>
        <span class="s0"># skip the function node to go directly to the upper level scope</span>
        <span class="s2">return </span><span class="s1">self.parent.parent.scope()</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.nodes</span>


<span class="s2">class </span><span class="s1">DelAttr(mixins.ParentAssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Variation of :class:`ast.Delete` representing deletion of an attribute. 
 
    &gt;&gt;&gt; node = astroid.extract_node('del self.attr') 
    &gt;&gt;&gt; node 
    &lt;Delete l.1 at 0x7f23b2e35f60&gt; 
    &gt;&gt;&gt; list(node.get_children())[0] 
    &lt;DelAttr.attr l.1 at 0x7f23b2e411d0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;expr&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;attrname&quot;</span><span class="s1">,)</span>
    <span class="s1">expr = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The name that this node represents. 
 
    :type: Name or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, attrname=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param attrname: The name of the attribute that is being deleted. 
        :type attrname: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.attrname = attrname</span>
        <span class="s4">&quot;&quot;&quot;The name of the attribute that is being deleted. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, expr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param expr: The name that this node represents. 
        :type expr: Name or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.expr = expr</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.expr</span>


<span class="s2">class </span><span class="s1">Delete(mixins.AssignTypeMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Delete` node. 
 
    A :class:`Delete` is a ``del`` statement this is deleting something. 
 
    &gt;&gt;&gt; node = astroid.extract_node('del self.attr') 
    &gt;&gt;&gt; node 
    &lt;Delete l.1 at 0x7f23b2e35f60&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;targets&quot;</span><span class="s1">,)</span>
    <span class="s1">targets = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being deleted. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, targets=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param targets: What is being deleted. 
        :type targets: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.targets = targets</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.targets</span>


<span class="s2">class </span><span class="s1">Dict(NodeNG, bases.Instance):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Dict` node. 
 
    A :class:`Dict` is a dictionary that is created with ``{}`` syntax. 
 
    &gt;&gt;&gt; node = astroid.extract_node('{1: &quot;1&quot;}') 
    &gt;&gt;&gt; node 
    &lt;Dict.dict l.1 at 0x7f23b2e35cc0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;items&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.items = []</span>
        <span class="s4">&quot;&quot;&quot;The key-value pairs contained in the dictionary. 
 
        :type: list(tuple(NodeNG, NodeNG)) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, items):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param items: The key-value pairs contained in the dictionary. 
        :type items: list(tuple(NodeNG, NodeNG)) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.items = items</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_elements(cls, items=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a :class:`Dict` of constants from a live dictionary. 
 
        :param items: The items to store in the node. 
        :type items: dict 
 
        :returns: The created dictionary node. 
        :rtype: Dict 
        &quot;&quot;&quot;</span>
        <span class="s1">node = cls()</span>
        <span class="s2">if </span><span class="s1">items </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">node.items = []</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">node.items = [</span>
                <span class="s1">(const_factory(k), const_factory(v) </span><span class="s2">if </span><span class="s1">_is_const(v) </span><span class="s2">else </span><span class="s1">v)</span>
                <span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">items.items()</span>
                <span class="s0"># The keys need to be constants</span>
                <span class="s2">if </span><span class="s1">_is_const(k)</span>
            <span class="s1">]</span>
        <span class="s2">return </span><span class="s1">node</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.dict&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the key and value nodes below this node. 
 
        Children are returned in the order that they are defined in the source 
        code, key first then the value. 
 
        :returns: The children. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">key, value </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s2">yield </span><span class="s1">key</span>
            <span class="s2">yield </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">last_child(self):</span>
        <span class="s0">&quot;&quot;&quot;An optimized version of list(get_children())[-1] 
 
        :returns: The last child, or None if no children exist. 
        :rtype: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.items:</span>
            <span class="s2">return </span><span class="s1">self.items[-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">itered(self):</span>
        <span class="s0">&quot;&quot;&quot;An iterator over the keys this node contains. 
 
        :returns: The keys of this node. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[key </span><span class="s2">for </span><span class="s1">(key, _) </span><span class="s2">in </span><span class="s1">self.items]</span>

    <span class="s2">def </span><span class="s1">getitem(self, index, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get an item from this node. 
 
        :param index: The node to use as a subscript index. 
        :type index: Const or Slice 
 
        :raises AstroidTypeError: When the given index cannot be used as a 
            subscript index, or if this node is not subscriptable. 
        :raises AstroidIndexError: If the given index does not exist in the 
            dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">key, value </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s0"># TODO(cpopa): no support for overriding yet, {1:2, **{1: 3}}.</span>
            <span class="s2">if </span><span class="s1">isinstance(key, DictUnpack):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">value.getitem(index, context)</span>
                <span class="s2">except </span><span class="s1">(exceptions.AstroidTypeError, exceptions.AstroidIndexError):</span>
                    <span class="s2">continue</span>
            <span class="s2">for </span><span class="s1">inferredkey </span><span class="s2">in </span><span class="s1">key.infer(context):</span>
                <span class="s2">if </span><span class="s1">inferredkey </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">isinstance(inferredkey, Const) </span><span class="s2">and </span><span class="s1">isinstance(index, Const):</span>
                    <span class="s2">if </span><span class="s1">inferredkey.value == index.value:</span>
                        <span class="s2">return </span><span class="s1">value</span>

        <span class="s2">raise </span><span class="s1">exceptions.AstroidIndexError(index)</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool(self.items)</span>


<span class="s2">class </span><span class="s1">Expr(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Expr` node. 
 
    An :class:`Expr` is any expression that does not have its value used or 
    stored. 
 
    &gt;&gt;&gt; node = astroid.extract_node('method()') 
    &gt;&gt;&gt; node 
    &lt;Call l.1 at 0x7f23b2e352b0&gt; 
    &gt;&gt;&gt; node.parent 
    &lt;Expr l.1 at 0x7f23b2e35278&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What the expression does. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: What the expression does. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s2">if not </span><span class="s1">self.value.is_lambda:</span>
            <span class="s2">yield from </span><span class="s1">self.value._get_yield_nodes_skip_lambdas()</span>


<span class="s2">class </span><span class="s1">Ellipsis(mixins.NoChildrenMixin, NodeNG):  </span><span class="s0"># pylint: disable=redefined-builtin</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Ellipsis` node. 
 
    An :class:`Ellipsis` is the ``...`` syntax. 
 
    &gt;&gt;&gt; node = astroid.extract_node('...') 
    &gt;&gt;&gt; node 
    &lt;Ellipsis l.1 at 0x7f23b2e35160&gt; 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">bool_value(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Determine the boolean value of this node. 
 
        :returns: The boolean value of this node. 
            For an :class:`Ellipsis` this is always ``True``. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>


<span class="s2">class </span><span class="s1">EmptyNode(mixins.NoChildrenMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Holds an arbitrary object in the :attr:`LocalsDictNodeNG.locals`.&quot;&quot;&quot;</span>

    <span class="s1">object = </span><span class="s2">None</span>


<span class="s2">class </span><span class="s1">ExceptHandler(mixins.MultiLineBlockMixin, mixins.AssignTypeMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ExceptHandler`. node. 
 
    An :class:`ExceptHandler` is an ``except`` block on a try-except. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
        try: 
            do_something() 
        except Exception as error: 
            print(&quot;Error!&quot;) 
        ''') 
    &gt;&gt;&gt; node 
    &lt;TryExcept l.2 at 0x7f23b2e9d908&gt; 
    &gt;&gt;&gt; &gt;&gt;&gt; node.handlers 
    [&lt;ExceptHandler l.4 at 0x7f23b2e9e860&gt;] 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;type&quot;</span><span class="s1">, </span><span class="s4">&quot;name&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">,)</span>
    <span class="s1">type = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The types that the block handles. 
 
    :type: Tuple or NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The name that the caught exception is assigned to. 
 
    :type: AssignName or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.type</span>

        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.name</span>

        <span class="s2">yield from </span><span class="s1">self.body</span>

    <span class="s0"># pylint: disable=redefined-builtin; had to use the same name as builtin ast module.</span>
    <span class="s2">def </span><span class="s1">postinit(self, type=</span><span class="s2">None</span><span class="s1">, name=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param type: The types that the block handles. 
        :type type: Tuple or NodeNG or None 
 
        :param name: The name that the caught exception is assigned to. 
        :type name: AssignName or None 
 
        :param body:The contents of the block. 
        :type body: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.type = type</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.body = body</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.name:</span>
            <span class="s2">return </span><span class="s1">self.name.tolineno</span>
        <span class="s2">if </span><span class="s1">self.type:</span>
            <span class="s2">return </span><span class="s1">self.type.tolineno</span>
        <span class="s2">return </span><span class="s1">self.lineno</span>

    <span class="s2">def </span><span class="s1">catch(self, exceptions):  </span><span class="s0"># pylint: disable=redefined-outer-name</span>
        <span class="s0">&quot;&quot;&quot;Check if this node handles any of the given exceptions. 
 
        If ``exceptions`` is empty, this will default to ``True``. 
 
        :param exceptions: The name of the exceptions to check for. 
        :type exceptions: list(str) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.type </span><span class="s2">is None or </span><span class="s1">exceptions </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.type._get_name_nodes():</span>
            <span class="s2">if </span><span class="s1">node.name </span><span class="s2">in </span><span class="s1">exceptions:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">Exec(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing the ``exec`` statement. 
 
    &gt;&gt;&gt; node = astroid.extract_node('exec &quot;True&quot;') 
    &gt;&gt;&gt; node 
    &lt;Exec l.1 at 0x7f0e8106c6d0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;expr&quot;</span><span class="s1">, </span><span class="s4">&quot;globals&quot;</span><span class="s1">, </span><span class="s4">&quot;locals&quot;</span><span class="s1">)</span>
    <span class="s1">expr = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The expression to be executed. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">globals = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The globals dictionary to execute with. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">locals = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The locals dictionary to execute with. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s0"># pylint: disable=redefined-builtin; had to use the same name as builtin ast module.</span>
    <span class="s2">def </span><span class="s1">postinit(self, expr=</span><span class="s2">None</span><span class="s1">, globals=</span><span class="s2">None</span><span class="s1">, locals=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param expr: The expression to be executed. 
        :type expr: NodeNG or None 
 
        :param globals:The globals dictionary to execute with. 
        :type globals: NodeNG or None 
 
        :param locals: The locals dictionary to execute with. 
        :type locals: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.expr = expr</span>
        <span class="s1">self.globals = globals</span>
        <span class="s1">self.locals = locals</span>


<span class="s2">class </span><span class="s1">ExtSlice(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ExtSlice` node. 
 
    An :class:`ExtSlice` is a complex slice expression. 
 
    &gt;&gt;&gt; node = astroid.extract_node('l[1:3, 5]') 
    &gt;&gt;&gt; node 
    &lt;Subscript l.1 at 0x7f23b2e9e550&gt; 
    &gt;&gt;&gt; node.slice 
    &lt;ExtSlice l.1 at 0x7f23b7b05ef0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;dims&quot;</span><span class="s1">,)</span>
    <span class="s1">dims = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The simple dimensions that form the complete slice. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, dims=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param dims: The simple dimensions that form the complete slice. 
        :type dims: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dims = dims</span>


<span class="s2">class </span><span class="s1">For(</span>
    <span class="s1">mixins.MultiLineBlockMixin,</span>
    <span class="s1">mixins.BlockRangeMixIn,</span>
    <span class="s1">mixins.AssignTypeMixin,</span>
    <span class="s1">Statement,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.For` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('for thing in things: print(thing)') 
    &gt;&gt;&gt; node 
    &lt;For l.1 at 0x7f23b2e8cf28&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;target&quot;</span><span class="s1">, </span><span class="s4">&quot;iter&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;type_annotation&quot;</span><span class="s1">,)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">target = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What the loop assigns to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">iter = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What the loop iterates over. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the body of the loop. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">orelse = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``else`` block of the loop. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">type_annotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;If present, this will contain the type annotation passed by a type comment 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s0"># pylint: disable=redefined-builtin; had to use the same name as builtin ast module.</span>
    <span class="s2">def </span><span class="s1">postinit(</span>
        <span class="s1">self, target=</span><span class="s2">None</span><span class="s1">, iter=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">, orelse=</span><span class="s2">None</span><span class="s1">, type_annotation=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param target: What the loop assigns to. 
        :type target: NodeNG or None 
 
        :param iter: What the loop iterates over. 
        :type iter: NodeNG or None 
 
        :param body: The contents of the body of the loop. 
        :type body: list(NodeNG) or None 
 
        :param orelse: The contents of the ``else`` block of the loop. 
        :type orelse: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.iter = iter</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.orelse = orelse</span>
        <span class="s1">self.type_annotation = type_annotation</span>

    <span class="s1">optional_assign = </span><span class="s2">True</span>
    <span class="s4">&quot;&quot;&quot;Whether this node optionally assigns a variable. 
 
    This is always ``True`` for :class:`For` nodes. 
 
    :type: bool 
    &quot;&quot;&quot;</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.iter.tolineno</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.target</span>
        <span class="s2">yield </span><span class="s1">self.iter</span>

        <span class="s2">yield from </span><span class="s1">self.body</span>
        <span class="s2">yield from </span><span class="s1">self.orelse</span>


<span class="s2">class </span><span class="s1">AsyncFor(For):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.AsyncFor` node. 
 
    An :class:`AsyncFor` is an asynchronous :class:`For` built with 
    the ``async`` keyword. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    async def func(things): 
        async for thing in things: 
            print(thing) 
    ''') 
    &gt;&gt;&gt; node 
    &lt;AsyncFunctionDef.func l.2 at 0x7f23b2e416d8&gt; 
    &gt;&gt;&gt; node.body[0] 
    &lt;AsyncFor l.3 at 0x7f23b2e417b8&gt; 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Await(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Await` node. 
 
    An :class:`Await` is the ``await`` keyword. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    async def func(things): 
        await other_func() 
    ''') 
    &gt;&gt;&gt; node 
    &lt;AsyncFunctionDef.func l.2 at 0x7f23b2e41748&gt; 
    &gt;&gt;&gt; node.body[0] 
    &lt;Expr l.3 at 0x7f23b2e419e8&gt; 
    &gt;&gt;&gt; list(node.body[0].get_children())[0] 
    &lt;Await l.3 at 0x7f23b2e41a20&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What to wait for. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: What to wait for. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">ImportFrom(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.ImportFrom` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('from my_package import my_module') 
    &gt;&gt;&gt; node 
    &lt;ImportFrom l.1 at 0x7f23b2e415c0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;modname&quot;</span><span class="s1">, </span><span class="s4">&quot;names&quot;</span><span class="s1">, </span><span class="s4">&quot;level&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self, fromname, names, level=</span><span class="s3">0</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param fromname: The module that is being imported from. 
        :type fromname: str or None 
 
        :param names: What is being imported from the module. 
        :type names: list(tuple(str, str or None)) 
 
        :param level: The level of relative import. 
        :type level: int 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.modname = fromname</span>
        <span class="s4">&quot;&quot;&quot;The module that is being imported from. 
 
        This is ``None`` for relative imports. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">self.names = names</span>
        <span class="s4">&quot;&quot;&quot;What is being imported from the module. 
 
        Each entry is a :class:`tuple` of the name being imported, 
        and the alias that the name is assigned to (if any). 
 
        :type: list(tuple(str, str or None)) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.level = level</span>
        <span class="s4">&quot;&quot;&quot;The level of relative import. 
 
        Essentially this is the number of dots in the import. 
        This is always 0 for absolute imports. 
 
        :type: int 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>


<span class="s2">class </span><span class="s1">Attribute(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Attribute` node.&quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;expr&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;attrname&quot;</span><span class="s1">,)</span>
    <span class="s1">expr = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The name that this node represents. 
 
    :type: Name or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, attrname=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param attrname: The name of the attribute. 
        :type attrname: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.attrname = attrname</span>
        <span class="s4">&quot;&quot;&quot;The name of the attribute. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, expr=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param expr: The name that this node represents. 
        :type expr: Name or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.expr = expr</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.expr</span>


<span class="s2">class </span><span class="s1">Global(mixins.NoChildrenMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Global` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('global a_global') 
    &gt;&gt;&gt; node 
    &lt;Global l.1 at 0x7f23b2e9de10&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;names&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, names, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param names: The names being declared as global. 
        :type names: list(str) 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.names = names</span>
        <span class="s4">&quot;&quot;&quot;The names being declared as global. 
 
        :type: list(str) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">_infer_name(self, frame, name):</span>
        <span class="s2">return </span><span class="s1">name</span>


<span class="s2">class </span><span class="s1">If(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.If` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('if condition: print(True)') 
    &gt;&gt;&gt; node 
    &lt;If l.1 at 0x7f23b2e9dd30&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;test&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">test = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The condition that the statement tests. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">orelse = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``else`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, test=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">, orelse=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param test: The condition that the statement tests. 
        :type test: NodeNG or None 
 
        :param body: The contents of the block. 
        :type body: list(NodeNG) or None 
 
        :param orelse: The contents of the ``else`` block. 
        :type orelse: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.test = test</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.orelse = orelse</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.test.tolineno</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: The line number to start the range at. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
            starting at the given line number. 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">lineno == self.body[</span><span class="s3">0</span><span class="s1">].fromlineno:</span>
            <span class="s2">return </span><span class="s1">lineno, lineno</span>
        <span class="s2">if </span><span class="s1">lineno &lt;= self.body[-</span><span class="s3">1</span><span class="s1">].tolineno:</span>
            <span class="s2">return </span><span class="s1">lineno, self.body[-</span><span class="s3">1</span><span class="s1">].tolineno</span>
        <span class="s2">return </span><span class="s1">self._elsed_block_range(lineno, self.orelse, self.body[</span><span class="s3">0</span><span class="s1">].fromlineno - </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.test</span>

        <span class="s2">yield from </span><span class="s1">self.body</span>
        <span class="s2">yield from </span><span class="s1">self.orelse</span>

    <span class="s2">def </span><span class="s1">has_elif_block(self):</span>
        <span class="s2">return </span><span class="s1">len(self.orelse) == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">isinstance(self.orelse[</span><span class="s3">0</span><span class="s1">], If)</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s0">&quot;&quot;&quot;An If node can contain a Yield node in the test&quot;&quot;&quot;</span>
        <span class="s2">yield from </span><span class="s1">self.test._get_yield_nodes_skip_lambdas()</span>
        <span class="s2">yield from </span><span class="s1">super()._get_yield_nodes_skip_lambdas()</span>


<span class="s2">class </span><span class="s1">IfExp(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.IfExp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('value if condition else other') 
    &gt;&gt;&gt; node 
    &lt;IfExp l.1 at 0x7f23b2e9dbe0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;test&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">test = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The condition that the statement tests. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">orelse = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``else`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, test=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">, orelse=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param test: The condition that the statement tests. 
        :type test: NodeNG or None 
 
        :param body: The contents of the block. 
        :type body: list(NodeNG) or None 
 
        :param orelse: The contents of the ``else`` block. 
        :type orelse: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.test = test</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.orelse = orelse</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.test</span>
        <span class="s2">yield </span><span class="s1">self.body</span>
        <span class="s2">yield </span><span class="s1">self.orelse</span>

    <span class="s2">def </span><span class="s1">op_left_associative(self):</span>
        <span class="s0"># `1 if True else 2 if False else 3` is parsed as</span>
        <span class="s0"># `1 if True else (2 if False else 3)`</span>
        <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">Import(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Import` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('import astroid') 
    &gt;&gt;&gt; node 
    &lt;Import l.1 at 0x7f23b2e4e5c0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;names&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, names=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param names: The names being imported. 
        :type names: list(tuple(str, str or None)) or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.names = names</span>
        <span class="s4">&quot;&quot;&quot;The names being imported. 
 
        Each entry is a :class:`tuple` of the name being imported, 
        and the alias that the name is assigned to (if any). 
 
        :type: list(tuple(str, str or None)) or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>


<span class="s2">class </span><span class="s1">Index(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Index` node. 
 
    An :class:`Index` is a simple subscript. 
 
    &gt;&gt;&gt; node = astroid.extract_node('things[1]') 
    &gt;&gt;&gt; node 
    &lt;Subscript l.1 at 0x7f23b2e9e2b0&gt; 
    &gt;&gt;&gt; node.slice 
    &lt;Index l.1 at 0x7f23b2e9e6a0&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value to subscript with. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The value to subscript with. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">Keyword(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.keyword` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('function(a_kwarg=True)') 
    &gt;&gt;&gt; node 
    &lt;Call l.1 at 0x7f23b2e9e320&gt; 
    &gt;&gt;&gt; node.keywords 
    [&lt;Keyword l.1 at 0x7f23b2e9e9b0&gt;] 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;arg&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value being assigned to the keyword argument. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, arg=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param arg: The argument being assigned to. 
        :type arg: Name or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.arg = arg</span>
        <span class="s4">&quot;&quot;&quot;The argument being assigned to. 
 
        :type: Name or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The value being assigned to the ketword argument. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">List(_BaseContainer):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.List` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('[1, 2, 3]') 
    &gt;&gt;&gt; node 
    &lt;List.list l.1 at 0x7f23b2e9e128&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;ctx&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, ctx=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param ctx: Whether the list is assigned to or loaded from. 
        :type ctx: Context or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ctx = ctx</span>
        <span class="s4">&quot;&quot;&quot;Whether the list is assigned to or loaded from. 
 
        :type: Context or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.list&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">getitem(self, index, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get an item from this node. 
 
        :param index: The node to use as a subscript index. 
        :type index: Const or Slice 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">_container_getitem(self, self.elts, index, context=context)</span>


<span class="s2">class </span><span class="s1">Nonlocal(mixins.NoChildrenMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Nonlocal` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    def function(): 
        nonlocal var 
    ''') 
    &gt;&gt;&gt; node 
    &lt;FunctionDef.function l.2 at 0x7f23b2e9e208&gt; 
    &gt;&gt;&gt; node.body[0] 
    &lt;Nonlocal l.3 at 0x7f23b2e9e908&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;names&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, names, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param names: The names being declared as not local. 
        :type names: list(str) 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.names = names</span>
        <span class="s4">&quot;&quot;&quot;The names being declared as not local. 
 
        :type: list(str) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">_infer_name(self, frame, name):</span>
        <span class="s2">return </span><span class="s1">name</span>


<span class="s2">class </span><span class="s1">Pass(mixins.NoChildrenMixin, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Pass` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('pass') 
    &gt;&gt;&gt; node 
    &lt;Pass l.1 at 0x7f23b2e9e748&gt; 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Print(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Print` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('print &quot;A message&quot;') 
    &gt;&gt;&gt; node 
    &lt;Print l.1 at 0x7f0e8101d290&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;dest&quot;</span><span class="s1">, </span><span class="s4">&quot;values&quot;</span><span class="s1">)</span>
    <span class="s1">dest = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;Where to print to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">values = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What to print. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, nl=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param nl: Whether to print a new line. 
        :type nl: bool or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.nl = nl</span>
        <span class="s4">&quot;&quot;&quot;Whether to print a new line. 
 
        :type: bool or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, dest=</span><span class="s2">None</span><span class="s1">, values=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param dest: Where to print to. 
        :type dest: NodeNG or None 
 
        :param values: What to print. 
        :type values: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dest = dest</span>
        <span class="s1">self.values = values</span>


<span class="s2">class </span><span class="s1">Raise(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Raise` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('raise RuntimeError(&quot;Something bad happened!&quot;)') 
    &gt;&gt;&gt; node 
    &lt;Raise l.1 at 0x7f23b2e9e828&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">exc = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being raised. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;exc&quot;</span><span class="s1">, </span><span class="s4">&quot;cause&quot;</span><span class="s1">)</span>
    <span class="s1">cause = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The exception being used to raise this one. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, exc=</span><span class="s2">None</span><span class="s1">, cause=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param exc: What is being raised. 
        :type exc: NodeNG or None 
 
        :param cause: The exception being used to raise this one. 
        :type cause: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.exc = exc</span>
        <span class="s1">self.cause = cause</span>

    <span class="s2">def </span><span class="s1">raises_not_implemented(self):</span>
        <span class="s0">&quot;&quot;&quot;Check if this node raises a :class:`NotImplementedError`. 
 
        :returns: True if this node raises a :class:`NotImplementedError`, 
            False otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.exc:</span>
            <span class="s2">return False</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.exc._get_name_nodes():</span>
            <span class="s2">if </span><span class="s1">name.name == </span><span class="s4">&quot;NotImplementedError&quot;</span><span class="s1">:</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.exc </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.exc</span>

        <span class="s2">if </span><span class="s1">self.cause </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.cause</span>


<span class="s2">class </span><span class="s1">Return(Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Return` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('return True') 
    &gt;&gt;&gt; node 
    &lt;Return l.1 at 0x7f23b8211908&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value being returned. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The value being returned. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.value</span>

    <span class="s2">def </span><span class="s1">is_tuple_return(self):</span>
        <span class="s2">return </span><span class="s1">isinstance(self.value, Tuple)</span>

    <span class="s2">def </span><span class="s1">_get_return_nodes_skip_functions(self):</span>
        <span class="s2">yield </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">Set(_BaseContainer):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Set` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('{1, 2, 3}') 
    &gt;&gt;&gt; node 
    &lt;Set.set l.1 at 0x7f23b2e71d68&gt; 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.set&quot; </span><span class="s1">% BUILTINS</span>


<span class="s2">class </span><span class="s1">Slice(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Slice` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('things[1:3]') 
    &gt;&gt;&gt; node 
    &lt;Subscript l.1 at 0x7f23b2e71f60&gt; 
    &gt;&gt;&gt; node.slice 
    &lt;Slice l.1 at 0x7f23b2e71e80&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;lower&quot;</span><span class="s1">, </span><span class="s4">&quot;upper&quot;</span><span class="s1">, </span><span class="s4">&quot;step&quot;</span><span class="s1">)</span>
    <span class="s1">lower = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The lower index in the slice. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">upper = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The upper index in the slice. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">step = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The step to take between indexes. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, lower=</span><span class="s2">None</span><span class="s1">, upper=</span><span class="s2">None</span><span class="s1">, step=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param lower: The lower index in the slice. 
        :value lower: NodeNG or None 
 
        :param upper: The upper index in the slice. 
        :value upper: NodeNG or None 
 
        :param step: The step to take between index. 
        :param step: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.lower = lower</span>
        <span class="s1">self.upper = upper</span>
        <span class="s1">self.step = step</span>

    <span class="s2">def </span><span class="s1">_wrap_attribute(self, attr):</span>
        <span class="s0">&quot;&quot;&quot;Wrap the empty attributes of the Slice in a Const node.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">attr:</span>
            <span class="s1">const = const_factory(attr)</span>
            <span class="s1">const.parent = self</span>
            <span class="s2">return </span><span class="s1">const</span>
        <span class="s2">return </span><span class="s1">attr</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">_proxied(self):</span>
        <span class="s1">builtins = MANAGER.builtins_module</span>
        <span class="s2">return </span><span class="s1">builtins.getattr(</span><span class="s4">&quot;slice&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.slice&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">igetattr(self, attrname, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Infer the possible values of the given attribute on the slice. 
 
        :param attrname: The name of the attribute to infer. 
        :type attrname: str 
 
        :returns: The inferred possible values. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">attrname == </span><span class="s4">&quot;start&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self._wrap_attribute(self.lower)</span>
        <span class="s2">elif </span><span class="s1">attrname == </span><span class="s4">&quot;stop&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self._wrap_attribute(self.upper)</span>
        <span class="s2">elif </span><span class="s1">attrname == </span><span class="s4">&quot;step&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self._wrap_attribute(self.step)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield from </span><span class="s1">self.getattr(attrname, context=context)</span>

    <span class="s2">def </span><span class="s1">getattr(self, attrname, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._proxied.getattr(attrname, context)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.lower </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.lower</span>

        <span class="s2">if </span><span class="s1">self.upper </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.upper</span>

        <span class="s2">if </span><span class="s1">self.step </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.step</span>


<span class="s2">class </span><span class="s1">Starred(mixins.ParentAssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Starred` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('*args') 
    &gt;&gt;&gt; node 
    &lt;Starred l.1 at 0x7f23b2e41978&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;ctx&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being unpacked. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, ctx=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param ctx: Whether the list is assigned to or loaded from. 
        :type ctx: Context or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ctx = ctx</span>
        <span class="s4">&quot;&quot;&quot;Whether the starred item is assigned to or loaded from. 
 
        :type: Context or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno=lineno, col_offset=col_offset, parent=parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: What is being unpacked. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s2">class </span><span class="s1">Subscript(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Subscript` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('things[1:3]') 
    &gt;&gt;&gt; node 
    &lt;Subscript l.1 at 0x7f23b2e71f60&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">, </span><span class="s4">&quot;slice&quot;</span><span class="s1">)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;ctx&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What is being indexed. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">slice = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The slice being used to lookup. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, ctx=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param ctx: Whether the subscripted item is assigned to or loaded from. 
        :type ctx: Context or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ctx = ctx</span>
        <span class="s4">&quot;&quot;&quot;Whether the subscripted item is assigned to or loaded from. 
 
        :type: Context or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno=lineno, col_offset=col_offset, parent=parent)</span>

    <span class="s0"># pylint: disable=redefined-builtin; had to use the same name as builtin ast module.</span>
    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">, slice=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: What is being indexed. 
        :type value: NodeNG or None 
 
        :param slice: The slice being used to lookup. 
        :type slice: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.slice = slice</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>
        <span class="s2">yield </span><span class="s1">self.slice</span>


<span class="s2">class </span><span class="s1">TryExcept(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.TryExcept` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
        try: 
            do_something() 
        except Exception as error: 
            print(&quot;Error!&quot;) 
        ''') 
    &gt;&gt;&gt; node 
    &lt;TryExcept l.2 at 0x7f23b2e9d908&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;handlers&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;handlers&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the block to catch exceptions from. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">handlers = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The exception handlers. 
 
    :type: list(ExceptHandler) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">orelse = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``else`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, body=</span><span class="s2">None</span><span class="s1">, handlers=</span><span class="s2">None</span><span class="s1">, orelse=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param body: The contents of the block to catch exceptions from. 
        :type body: list(NodeNG) or None 
 
        :param handlers: The exception handlers. 
        :type handlers: list(ExceptHandler) or None 
 
        :param orelse: The contents of the ``else`` block. 
        :type orelse: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.handlers = handlers</span>
        <span class="s1">self.orelse = orelse</span>

    <span class="s2">def </span><span class="s1">_infer_name(self, frame, name):</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: The line number to start the range at. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
            starting at the given line number. 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s1">last = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">exhandler </span><span class="s2">in </span><span class="s1">self.handlers:</span>
            <span class="s2">if </span><span class="s1">exhandler.type </span><span class="s2">and </span><span class="s1">lineno == exhandler.type.fromlineno:</span>
                <span class="s2">return </span><span class="s1">lineno, lineno</span>
            <span class="s2">if </span><span class="s1">exhandler.body[</span><span class="s3">0</span><span class="s1">].fromlineno &lt;= lineno &lt;= exhandler.body[-</span><span class="s3">1</span><span class="s1">].tolineno:</span>
                <span class="s2">return </span><span class="s1">lineno, exhandler.body[-</span><span class="s3">1</span><span class="s1">].tolineno</span>
            <span class="s2">if </span><span class="s1">last </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">last = exhandler.body[</span><span class="s3">0</span><span class="s1">].fromlineno - </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s1">self._elsed_block_range(lineno, self.orelse, last)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.body</span>

        <span class="s2">yield from </span><span class="s1">self.handlers </span><span class="s2">or </span><span class="s1">()</span>
        <span class="s2">yield from </span><span class="s1">self.orelse </span><span class="s2">or </span><span class="s1">()</span>


<span class="s2">class </span><span class="s1">TryFinally(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.TryFinally` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    try: 
        do_something() 
    except Exception as error: 
        print(&quot;Error!&quot;) 
    finally: 
        print(&quot;Cleanup!&quot;) 
    ''') 
    &gt;&gt;&gt; node 
    &lt;TryFinally l.2 at 0x7f23b2e41d68&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;finalbody&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;finalbody&quot;</span><span class="s1">)</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The try-except that the finally is attached to. 
 
    :type: list(TryExcept) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">finalbody = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``finally`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, body=</span><span class="s2">None</span><span class="s1">, finalbody=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param body: The try-except that the finally is attached to. 
        :type body: list(TryExcept) or None 
 
        :param finalbody: The contents of the ``finally`` block. 
        :type finalbody: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.finalbody = finalbody</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: The line number to start the range at. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
            starting at the given line number. 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s1">child = self.body[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0"># py2.5 try: except: finally:</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(child, TryExcept)</span>
            <span class="s2">and </span><span class="s1">child.fromlineno == self.fromlineno</span>
            <span class="s2">and </span><span class="s1">child.tolineno &gt;= lineno &gt; self.fromlineno</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">child.block_range(lineno)</span>
        <span class="s2">return </span><span class="s1">self._elsed_block_range(lineno, self.finalbody)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.body</span>
        <span class="s2">yield from </span><span class="s1">self.finalbody</span>


<span class="s2">class </span><span class="s1">Tuple(_BaseContainer):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Tuple` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('(1, 2, 3)') 
    &gt;&gt;&gt; node 
    &lt;Tuple.tuple l.1 at 0x7f23b2e41780&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_other_fields = (</span><span class="s4">&quot;ctx&quot;</span><span class="s1">,)</span>

    <span class="s2">def </span><span class="s1">__init__(self, ctx=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param ctx: Whether the tuple is assigned to or loaded from. 
        :type ctx: Context or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ctx = ctx</span>
        <span class="s4">&quot;&quot;&quot;Whether the tuple is assigned to or loaded from. 
 
        :type: Context or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">pytype(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the name of the type that this node represents. 
 
        :returns: The name of the type. 
        :rtype: str 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">&quot;%s.tuple&quot; </span><span class="s1">% BUILTINS</span>

    <span class="s2">def </span><span class="s1">getitem(self, index, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get an item from this node. 
 
        :param index: The node to use as a subscript index. 
        :type index: Const or Slice 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">_container_getitem(self, self.elts, index, context=context)</span>


<span class="s2">class </span><span class="s1">UnaryOp(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.UnaryOp` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('-5') 
    &gt;&gt;&gt; node 
    &lt;UnaryOp l.1 at 0x7f23b2e4e198&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;operand&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;op&quot;</span><span class="s1">,)</span>
    <span class="s1">operand = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;What the unary operator is applied to. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, op=</span><span class="s2">None</span><span class="s1">, lineno=</span><span class="s2">None</span><span class="s1">, col_offset=</span><span class="s2">None</span><span class="s1">, parent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        :param op: The operator. 
        :type: str or None 
 
        :param lineno: The line that this node appears on in the source code. 
        :type lineno: int or None 
 
        :param col_offset: The column that this node appears on in the 
            source code. 
        :type col_offset: int or None 
 
        :param parent: The parent node in the syntax tree. 
        :type parent: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.op = op</span>
        <span class="s4">&quot;&quot;&quot;The operator. 
 
        :type: str or None 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(lineno, col_offset, parent)</span>

    <span class="s2">def </span><span class="s1">postinit(self, operand=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param operand: What the unary operator is applied to. 
        :type operand: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.operand = operand</span>

    <span class="s0"># This is set by inference.py</span>
    <span class="s2">def </span><span class="s1">_infer_unaryop(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">type_errors(self, context=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of type errors which can occur during inference. 
 
        Each TypeError is represented by a :class:`BadBinaryOperationMessage`, 
        which holds the original exception. 
 
        :returns: The list of possible type errors. 
        :rtype: list(BadBinaryOperationMessage) 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">results = self._infer_unaryop(context=context)</span>
            <span class="s2">return </span><span class="s1">[</span>
                <span class="s1">result</span>
                <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">results</span>
                <span class="s2">if </span><span class="s1">isinstance(result, util.BadUnaryOperationMessage)</span>
            <span class="s1">]</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.operand</span>

    <span class="s2">def </span><span class="s1">op_precedence(self):</span>
        <span class="s2">if </span><span class="s1">self.op == </span><span class="s4">&quot;not&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">OP_PRECEDENCE[self.op]</span>

        <span class="s2">return </span><span class="s1">super().op_precedence()</span>


<span class="s2">class </span><span class="s1">While(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.While` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    while condition(): 
        print(&quot;True&quot;) 
    ''') 
    &gt;&gt;&gt; node 
    &lt;While l.2 at 0x7f23b2e4e390&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;test&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">, </span><span class="s4">&quot;orelse&quot;</span><span class="s1">)</span>
    <span class="s1">test = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The condition that the loop tests. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the loop. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">orelse = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``else`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, test=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">, orelse=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param test: The condition that the loop tests. 
        :type test: NodeNG or None 
 
        :param body: The contents of the loop. 
        :type body: list(NodeNG) or None 
 
        :param orelse: The contents of the ``else`` block. 
        :type orelse: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.test = test</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.orelse = orelse</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.test.tolineno</span>

    <span class="s2">def </span><span class="s1">block_range(self, lineno):</span>
        <span class="s0">&quot;&quot;&quot;Get a range from the given line number to where this node ends. 
 
        :param lineno: The line number to start the range at. 
        :type lineno: int 
 
        :returns: The range of line numbers that this node belongs to, 
            starting at the given line number. 
        :rtype: tuple(int, int) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._elsed_block_range(lineno, self.orelse)</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.test</span>

        <span class="s2">yield from </span><span class="s1">self.body</span>
        <span class="s2">yield from </span><span class="s1">self.orelse</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s0">&quot;&quot;&quot;A While node can contain a Yield node in the test&quot;&quot;&quot;</span>
        <span class="s2">yield from </span><span class="s1">self.test._get_yield_nodes_skip_lambdas()</span>
        <span class="s2">yield from </span><span class="s1">super()._get_yield_nodes_skip_lambdas()</span>


<span class="s2">class </span><span class="s1">With(</span>
    <span class="s1">mixins.MultiLineBlockMixin,</span>
    <span class="s1">mixins.BlockRangeMixIn,</span>
    <span class="s1">mixins.AssignTypeMixin,</span>
    <span class="s1">Statement,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.With` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node(''' 
    with open(file_path) as file_: 
        print(file_.read()) 
    ''') 
    &gt;&gt;&gt; node 
    &lt;With l.2 at 0x7f23b2e4e710&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;items&quot;</span><span class="s1">, </span><span class="s4">&quot;body&quot;</span><span class="s1">)</span>
    <span class="s1">_other_other_fields = (</span><span class="s4">&quot;type_annotation&quot;</span><span class="s1">,)</span>
    <span class="s1">_multi_line_block_fields = (</span><span class="s4">&quot;body&quot;</span><span class="s1">,)</span>
    <span class="s1">items = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The pairs of context managers and the names they are assigned to. 
 
    :type: list(tuple(NodeNG, AssignName or None)) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">body = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The contents of the ``with`` block. 
 
    :type: list(NodeNG) or None 
    &quot;&quot;&quot;</span>
    <span class="s1">type_annotation = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;If present, this will contain the type annotation passed by a type comment 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, items=</span><span class="s2">None</span><span class="s1">, body=</span><span class="s2">None</span><span class="s1">, type_annotation=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param items: The pairs of context managers and the names 
            they are assigned to. 
        :type items: list(tuple(NodeNG, AssignName or None)) or None 
 
        :param body: The contents of the ``with`` block. 
        :type body: list(NodeNG) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.items = items</span>
        <span class="s1">self.body = body</span>
        <span class="s1">self.type_annotation = type_annotation</span>

    <span class="s1">@decorators.cachedproperty</span>
    <span class="s2">def </span><span class="s1">blockstart_tolineno(self):</span>
        <span class="s0">&quot;&quot;&quot;The line on which the beginning of this block ends. 
 
        :type: int 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.items[-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].tolineno</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the child nodes below this node. 
 
        :returns: The children. 
        :rtype: iterable(NodeNG) 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">expr, var </span><span class="s2">in </span><span class="s1">self.items:</span>
            <span class="s2">yield </span><span class="s1">expr</span>
            <span class="s2">if </span><span class="s1">var:</span>
                <span class="s2">yield </span><span class="s1">var</span>
        <span class="s2">yield from </span><span class="s1">self.body</span>


<span class="s2">class </span><span class="s1">AsyncWith(With):</span>
    <span class="s0">&quot;&quot;&quot;Asynchronous ``with`` built with the ``async`` keyword.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Yield(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.Yield` node. 
 
    &gt;&gt;&gt; node = astroid.extract_node('yield True') 
    &gt;&gt;&gt; node 
    &lt;Yield l.1 at 0x7f23b2e4e5f8&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value to yield. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The value to yield. 
        :type value: NodeNG or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.value</span>

    <span class="s2">def </span><span class="s1">_get_yield_nodes_skip_lambdas(self):</span>
        <span class="s2">yield </span><span class="s1">self</span>


<span class="s2">class </span><span class="s1">YieldFrom(Yield):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.YieldFrom` node.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">DictUnpack(mixins.NoChildrenMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Represents the unpacking of dicts into dicts using :pep:`448`.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">FormattedValue(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Class representing an :class:`ast.FormattedValue` node. 
 
    Represents a :pep:`498` format string. 
 
    &gt;&gt;&gt; node = astroid.extract_node('f&quot;Format {type_}&quot;') 
    &gt;&gt;&gt; node 
    &lt;JoinedStr l.1 at 0x7f23b2e4ed30&gt; 
    &gt;&gt;&gt; node.values 
    [&lt;Const.str l.1 at 0x7f23b2e4eda0&gt;, &lt;FormattedValue l.1 at 0x7f23b2e4edd8&gt;] 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">, </span><span class="s4">&quot;format_spec&quot;</span><span class="s1">)</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value to be formatted into the string. 
 
    :type: NodeNG or None 
    &quot;&quot;&quot;</span>
    <span class="s1">conversion = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The type of formatting to be applied to the value. 
 
    .. seealso:: 
        :class:`ast.FormattedValue` 
 
    :type: int or None 
    &quot;&quot;&quot;</span>
    <span class="s1">format_spec = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The formatting to be applied to the value. 
 
    .. seealso:: 
        :class:`ast.FormattedValue` 
 
    :type: JoinedStr or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, value, conversion=</span><span class="s2">None</span><span class="s1">, format_spec=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The value to be formatted into the string. 
        :type value: NodeNG 
 
        :param conversion: The type of formatting to be applied to the value. 
        :type conversion: int or None 
 
        :param format_spec: The formatting to be applied to the value. 
        :type format_spec: JoinedStr or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.conversion = conversion</span>
        <span class="s1">self.format_spec = format_spec</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>

        <span class="s2">if </span><span class="s1">self.format_spec </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self.format_spec</span>


<span class="s2">class </span><span class="s1">JoinedStr(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Represents a list of string expressions to be joined. 
 
    &gt;&gt;&gt; node = astroid.extract_node('f&quot;Format {type_}&quot;') 
    &gt;&gt;&gt; node 
    &lt;JoinedStr l.1 at 0x7f23b2e4ed30&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;values&quot;</span><span class="s1">,)</span>
    <span class="s1">values = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The string expressions to be joined. 
 
    :type: list(FormattedValue or Const) or None 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, values=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do some setup after initialisation. 
 
        :param value: The string expressions to be joined. 
 
        :type: list(FormattedValue or Const) or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self.values = values</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">yield from </span><span class="s1">self.values</span>


<span class="s2">class </span><span class="s1">NamedExpr(mixins.AssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Represents the assignment from the assignment expression 
 
    &gt;&gt;&gt; module = astroid.parse('if a := 1: pass') 
    &gt;&gt;&gt; module.body[0].test 
    &lt;NamedExpr l.1 at 0x7f23b2e4ed30&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;target&quot;</span><span class="s1">, </span><span class="s4">&quot;value&quot;</span><span class="s1">)</span>
    <span class="s1">target = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The assignment target 
 
    :type: Name 
    &quot;&quot;&quot;</span>
    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The value that gets assigned in the expression 
 
    :type: NodeNG 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">postinit(self, target, value):</span>
        <span class="s1">self.target = target</span>
        <span class="s1">self.value = value</span>


<span class="s2">class </span><span class="s1">Unknown(mixins.AssignTypeMixin, NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;This node represents a node in a constructed AST where 
    introspection is not possible.  At the moment, it's only used in 
    the args attribute of FunctionDef nodes where function signature 
    introspection failed. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s4">&quot;Unknown&quot;</span>

    <span class="s2">def </span><span class="s1">qname(self):</span>
        <span class="s2">return </span><span class="s4">&quot;Unknown&quot;</span>

    <span class="s2">def </span><span class="s1">infer(self, context=</span><span class="s2">None</span><span class="s1">, **kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Inference on an Unknown node immediately terminates.&quot;&quot;&quot;</span>
        <span class="s2">yield </span><span class="s1">util.Uninferable</span>


<span class="s2">class </span><span class="s1">EvaluatedObject(NodeNG):</span>
    <span class="s0">&quot;&quot;&quot;Contains an object that has already been inferred 
 
    This class is useful to pre-evaluate a particular node, 
    with the resulting class acting as the non-evaluated node. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s4">&quot;EvaluatedObject&quot;</span>
    <span class="s1">_astroid_fields = (</span><span class="s4">&quot;original&quot;</span><span class="s1">,)</span>
    <span class="s1">_other_fields = (</span><span class="s4">&quot;value&quot;</span><span class="s1">,)</span>

    <span class="s1">original = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The original node that has already been evaluated 
 
    :type: NodeNG 
    &quot;&quot;&quot;</span>

    <span class="s1">value = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;The inferred value 
 
    :type: Union[Uninferable, NodeNG] 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self, original, value):</span>
        <span class="s1">self.original = original</span>
        <span class="s1">self.value = value</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">lineno=self.original.lineno,</span>
            <span class="s1">col_offset=self.original.col_offset,</span>
            <span class="s1">parent=self.original.parent,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">infer(self, context=</span><span class="s2">None</span><span class="s1">, **kwargs):</span>
        <span class="s2">yield </span><span class="s1">self.value</span>


<span class="s0"># constants ##############################################################</span>

<span class="s1">CONST_CLS = {</span>
    <span class="s1">list: List,</span>
    <span class="s1">tuple: Tuple,</span>
    <span class="s1">dict: Dict,</span>
    <span class="s1">set: Set,</span>
    <span class="s1">type(</span><span class="s2">None</span><span class="s1">): Const,</span>
    <span class="s1">type(NotImplemented): Const,</span>
<span class="s1">}</span>
<span class="s2">if </span><span class="s1">PY38:</span>
    <span class="s1">CONST_CLS[type(...)] = Const</span>


<span class="s2">def </span><span class="s1">_update_const_classes():</span>
    <span class="s0">&quot;&quot;&quot;update constant classes, so the keys of CONST_CLS can be reused&quot;&quot;&quot;</span>
    <span class="s1">klasses = (bool, int, float, complex, str, bytes)</span>
    <span class="s2">for </span><span class="s1">kls </span><span class="s2">in </span><span class="s1">klasses:</span>
        <span class="s1">CONST_CLS[kls] = Const</span>


<span class="s1">_update_const_classes()</span>


<span class="s2">def </span><span class="s1">_two_step_initialization(cls, value):</span>
    <span class="s1">instance = cls()</span>
    <span class="s1">instance.postinit(value)</span>
    <span class="s2">return </span><span class="s1">instance</span>


<span class="s2">def </span><span class="s1">_dict_initialization(cls, value):</span>
    <span class="s2">if </span><span class="s1">isinstance(value, dict):</span>
        <span class="s1">value = tuple(value.items())</span>
    <span class="s2">return </span><span class="s1">_two_step_initialization(cls, value)</span>


<span class="s1">_CONST_CLS_CONSTRUCTORS = {</span>
    <span class="s1">List: _two_step_initialization,</span>
    <span class="s1">Tuple: _two_step_initialization,</span>
    <span class="s1">Dict: _dict_initialization,</span>
    <span class="s1">Set: _two_step_initialization,</span>
    <span class="s1">Const: </span><span class="s2">lambda </span><span class="s1">cls, value: cls(value),</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">const_factory(value):</span>
    <span class="s0">&quot;&quot;&quot;return an astroid node for a python value&quot;&quot;&quot;</span>
    <span class="s0"># XXX we should probably be stricter here and only consider stuff in</span>
    <span class="s0"># CONST_CLS or do better treatment: in case where value is not in CONST_CLS,</span>
    <span class="s0"># we should rather recall the builder on this value than returning an empty</span>
    <span class="s0"># node (another option being that const_factory shouldn't be called with something</span>
    <span class="s0"># not in CONST_CLS)</span>
    <span class="s2">assert not </span><span class="s1">isinstance(value, NodeNG)</span>

    <span class="s0"># Hack for ignoring elements of a sequence</span>
    <span class="s0"># or a mapping, in order to avoid transforming</span>
    <span class="s0"># each element to an AST. This is fixed in 2.0</span>
    <span class="s0"># and this approach is a temporary hack.</span>
    <span class="s2">if </span><span class="s1">isinstance(value, (list, set, tuple, dict)):</span>
        <span class="s1">elts = []</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">elts = value</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">initializer_cls = CONST_CLS[value.__class__]</span>
        <span class="s1">initializer = _CONST_CLS_CONSTRUCTORS[initializer_cls]</span>
        <span class="s2">return </span><span class="s1">initializer(initializer_cls, elts)</span>
    <span class="s2">except </span><span class="s1">(KeyError, AttributeError):</span>
        <span class="s1">node = EmptyNode()</span>
        <span class="s1">node.object = value</span>
        <span class="s2">return </span><span class="s1">node</span>


<span class="s2">def </span><span class="s1">is_from_decorator(node):</span>
    <span class="s0">&quot;&quot;&quot;Return True if the given node is the child of a decorator&quot;&quot;&quot;</span>
    <span class="s1">parent = node.parent</span>
    <span class="s2">while </span><span class="s1">parent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(parent, Decorators):</span>
            <span class="s2">return True</span>
        <span class="s1">parent = parent.parent</span>
    <span class="s2">return False</span>
</pre>
</body>
</html>