<html>
<head>
<title>fixtures.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #c678dd;}
.s1 { color: #abb2bf;}
.s2 { color: #98c379;}
.s3 { color: #5c6370;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fixtures.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">deque</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">TracebackType</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Dict</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Generator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Generic</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Set</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">attr</span>
<span class="s0">import </span><span class="s1">py</span>

<span class="s0">import </span><span class="s1">_pytest</span>
<span class="s0">from </span><span class="s1">_pytest </span><span class="s0">import </span><span class="s1">nodes</span>
<span class="s0">from </span><span class="s1">_pytest._code </span><span class="s0">import </span><span class="s1">getfslineno</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">FormattedExcinfo</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">TerminalRepr</span>
<span class="s0">from </span><span class="s1">_pytest._io </span><span class="s0">import </span><span class="s1">TerminalWriter</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">_format_args</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">_PytestWrapper</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">assert_never</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">final</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">get_real_func</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">get_real_method</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">getfuncargnames</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">getimfunc</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">getlocation</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">is_generator</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">NOTSET</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">safe_getattr</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">_PluggyPlugin</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">_pytest.config.argparsing </span><span class="s0">import </span><span class="s1">Parser</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">check_ispytest</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">FILLFUNCARGS</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">YIELD_FIXTURE</span>
<span class="s0">from </span><span class="s1">_pytest.mark </span><span class="s0">import </span><span class="s1">Mark</span>
<span class="s0">from </span><span class="s1">_pytest.mark </span><span class="s0">import </span><span class="s1">ParameterSet</span>
<span class="s0">from </span><span class="s1">_pytest.mark.structures </span><span class="s0">import </span><span class="s1">MarkDecorator</span>
<span class="s0">from </span><span class="s1">_pytest.outcomes </span><span class="s0">import </span><span class="s1">fail</span>
<span class="s0">from </span><span class="s1">_pytest.outcomes </span><span class="s0">import </span><span class="s1">TEST_OUTCOME</span>
<span class="s0">from </span><span class="s1">_pytest.pathlib </span><span class="s0">import </span><span class="s1">absolutepath</span>
<span class="s0">from </span><span class="s1">_pytest.store </span><span class="s0">import </span><span class="s1">StoreKey</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Deque</span>
    <span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NoReturn</span>
    <span class="s0">from </span><span class="s1">typing_extensions </span><span class="s0">import </span><span class="s1">Literal</span>

    <span class="s0">from </span><span class="s1">_pytest.main </span><span class="s0">import </span><span class="s1">Session</span>
    <span class="s0">from </span><span class="s1">_pytest.python </span><span class="s0">import </span><span class="s1">CallSpec2</span>
    <span class="s0">from </span><span class="s1">_pytest.python </span><span class="s0">import </span><span class="s1">Function</span>
    <span class="s0">from </span><span class="s1">_pytest.python </span><span class="s0">import </span><span class="s1">Metafunc</span>

    <span class="s1">_Scope = Literal[</span><span class="s2">&quot;session&quot;</span><span class="s1">, </span><span class="s2">&quot;package&quot;</span><span class="s1">, </span><span class="s2">&quot;module&quot;</span><span class="s1">, </span><span class="s2">&quot;class&quot;</span><span class="s1">, </span><span class="s2">&quot;function&quot;</span><span class="s1">]</span>


<span class="s3"># The value of the fixture -- return/yield of the fixture function (type variable).</span>
<span class="s1">_FixtureValue = TypeVar(</span><span class="s2">&quot;_FixtureValue&quot;</span><span class="s1">)</span>
<span class="s3"># The type of the fixture function (type variable).</span>
<span class="s1">_FixtureFunction = TypeVar(</span><span class="s2">&quot;_FixtureFunction&quot;</span><span class="s1">, bound=Callable[..., object])</span>
<span class="s3"># The type of a fixture function (type alias generic in fixture value).</span>
<span class="s1">_FixtureFunc = Union[</span>
    <span class="s1">Callable[..., _FixtureValue], Callable[..., Generator[_FixtureValue, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">]]</span>
<span class="s1">]</span>
<span class="s3"># The type of FixtureDef.cached_result (type alias generic in fixture value).</span>
<span class="s1">_FixtureCachedResult = Union[</span>
    <span class="s1">Tuple[</span>
        <span class="s3"># The result.</span>
        <span class="s1">_FixtureValue,</span>
        <span class="s3"># Cache key.</span>
        <span class="s1">object,</span>
        <span class="s0">None</span><span class="s1">,</span>
    <span class="s1">],</span>
    <span class="s1">Tuple[</span>
        <span class="s0">None</span><span class="s1">,</span>
        <span class="s3"># Cache key.</span>
        <span class="s1">object,</span>
        <span class="s3"># Exc info if raised.</span>
        <span class="s1">Tuple[Type[BaseException], BaseException, TracebackType],</span>
    <span class="s1">],</span>
<span class="s1">]</span>


<span class="s1">@attr.s(frozen=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">PseudoFixtureDef(Generic[_FixtureValue]):</span>
    <span class="s1">cached_result = attr.ib(type=</span><span class="s2">&quot;_FixtureCachedResult[_FixtureValue]&quot;</span><span class="s1">)</span>
    <span class="s1">scope = attr.ib(type=</span><span class="s2">&quot;_Scope&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">pytest_sessionstart(session: </span><span class="s2">&quot;Session&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s1">session._fixturemanager = FixtureManager(session)</span>


<span class="s0">def </span><span class="s1">get_scope_package(node, fixturedef: </span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">):</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s1">cls = pytest.Package</span>
    <span class="s1">current = node</span>
    <span class="s1">fixture_package_name = </span><span class="s2">&quot;{}/{}&quot;</span><span class="s1">.format(fixturedef.baseid, </span><span class="s2">&quot;__init__.py&quot;</span><span class="s1">)</span>
    <span class="s0">while </span><span class="s1">current </span><span class="s0">and </span><span class="s1">(</span>
        <span class="s1">type(current) </span><span class="s0">is not </span><span class="s1">cls </span><span class="s0">or </span><span class="s1">fixture_package_name != current.nodeid</span>
    <span class="s1">):</span>
        <span class="s1">current = current.parent</span>
    <span class="s0">if </span><span class="s1">current </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.session</span>
    <span class="s0">return </span><span class="s1">current</span>


<span class="s0">def </span><span class="s1">get_scope_node(</span>
    <span class="s1">node: nodes.Node, scope: </span><span class="s2">&quot;_Scope&quot;</span>
<span class="s1">) -&gt; Optional[Union[nodes.Item, nodes.Collector]]:</span>
    <span class="s0">import </span><span class="s1">_pytest.python</span>

    <span class="s0">if </span><span class="s1">scope == </span><span class="s2">&quot;function&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.getparent(nodes.Item)</span>
    <span class="s0">elif </span><span class="s1">scope == </span><span class="s2">&quot;class&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.getparent(_pytest.python.Class)</span>
    <span class="s0">elif </span><span class="s1">scope == </span><span class="s2">&quot;module&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.getparent(_pytest.python.Module)</span>
    <span class="s0">elif </span><span class="s1">scope == </span><span class="s2">&quot;package&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.getparent(_pytest.python.Package)</span>
    <span class="s0">elif </span><span class="s1">scope == </span><span class="s2">&quot;session&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">node.getparent(_pytest.main.Session)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">assert_never(scope)</span>


<span class="s3"># Used for storing artificial fixturedefs for direct parametrization.</span>
<span class="s1">name2pseudofixturedef_key = StoreKey[Dict[str, </span><span class="s2">&quot;FixtureDef[Any]&quot;</span><span class="s1">]]()</span>


<span class="s0">def </span><span class="s1">add_funcarg_pseudo_fixture_def(</span>
    <span class="s1">collector: nodes.Collector, metafunc: </span><span class="s2">&quot;Metafunc&quot;</span><span class="s1">, fixturemanager: </span><span class="s2">&quot;FixtureManager&quot;</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3"># This function will transform all collected calls to functions</span>
    <span class="s3"># if they use direct funcargs (i.e. direct parametrization)</span>
    <span class="s3"># because we want later test execution to be able to rely on</span>
    <span class="s3"># an existing FixtureDef structure for all arguments.</span>
    <span class="s3"># XXX we can probably avoid this algorithm  if we modify CallSpec2</span>
    <span class="s3"># to directly care for creating the fixturedefs within its methods.</span>
    <span class="s0">if not </span><span class="s1">metafunc._calls[</span><span class="s4">0</span><span class="s1">].funcargs:</span>
        <span class="s3"># This function call does not have direct parametrization.</span>
        <span class="s0">return</span>
    <span class="s3"># Collect funcargs of all callspecs into a list of values.</span>
    <span class="s1">arg2params: Dict[str, List[object]] = {}</span>
    <span class="s1">arg2scope: Dict[str, _Scope] = {}</span>
    <span class="s0">for </span><span class="s1">callspec </span><span class="s0">in </span><span class="s1">metafunc._calls:</span>
        <span class="s0">for </span><span class="s1">argname, argvalue </span><span class="s0">in </span><span class="s1">callspec.funcargs.items():</span>
            <span class="s0">assert </span><span class="s1">argname </span><span class="s0">not in </span><span class="s1">callspec.params</span>
            <span class="s1">callspec.params[argname] = argvalue</span>
            <span class="s1">arg2params_list = arg2params.setdefault(argname, [])</span>
            <span class="s1">callspec.indices[argname] = len(arg2params_list)</span>
            <span class="s1">arg2params_list.append(argvalue)</span>
            <span class="s0">if </span><span class="s1">argname </span><span class="s0">not in </span><span class="s1">arg2scope:</span>
                <span class="s1">scopenum = callspec._arg2scopenum.get(argname, scopenum_function)</span>
                <span class="s1">arg2scope[argname] = scopes[scopenum]</span>
        <span class="s1">callspec.funcargs.clear()</span>

    <span class="s3"># Register artificial FixtureDef's so that later at test execution</span>
    <span class="s3"># time we can rely on a proper FixtureDef to exist for fixture setup.</span>
    <span class="s1">arg2fixturedefs = metafunc._arg2fixturedefs</span>
    <span class="s0">for </span><span class="s1">argname, valuelist </span><span class="s0">in </span><span class="s1">arg2params.items():</span>
        <span class="s3"># If we have a scope that is higher than function, we need</span>
        <span class="s3"># to make sure we only ever create an according fixturedef on</span>
        <span class="s3"># a per-scope basis. We thus store and cache the fixturedef on the</span>
        <span class="s3"># node related to the scope.</span>
        <span class="s1">scope = arg2scope[argname]</span>
        <span class="s1">node = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">scope != </span><span class="s2">&quot;function&quot;</span><span class="s1">:</span>
            <span class="s1">node = get_scope_node(collector, scope)</span>
            <span class="s0">if </span><span class="s1">node </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">scope == </span><span class="s2">&quot;class&quot; </span><span class="s0">and </span><span class="s1">isinstance(collector, _pytest.python.Module)</span>
                <span class="s3"># Use module-level collector for class-scope (for now).</span>
                <span class="s1">node = collector</span>
        <span class="s0">if </span><span class="s1">node </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">name2pseudofixturedef = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">default: Dict[str, FixtureDef[Any]] = {}</span>
            <span class="s1">name2pseudofixturedef = node._store.setdefault(</span>
                <span class="s1">name2pseudofixturedef_key, default</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">name2pseudofixturedef </span><span class="s0">is not None and </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">name2pseudofixturedef:</span>
            <span class="s1">arg2fixturedefs[argname] = [name2pseudofixturedef[argname]]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fixturedef = FixtureDef(</span>
                <span class="s1">fixturemanager=fixturemanager,</span>
                <span class="s1">baseid=</span><span class="s2">&quot;&quot;</span><span class="s1">,</span>
                <span class="s1">argname=argname,</span>
                <span class="s1">func=get_direct_param_fixture_func,</span>
                <span class="s1">scope=arg2scope[argname],</span>
                <span class="s1">params=valuelist,</span>
                <span class="s1">unittest=</span><span class="s0">False</span><span class="s1">,</span>
                <span class="s1">ids=</span><span class="s0">None</span><span class="s1">,</span>
            <span class="s1">)</span>
            <span class="s1">arg2fixturedefs[argname] = [fixturedef]</span>
            <span class="s0">if </span><span class="s1">name2pseudofixturedef </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">name2pseudofixturedef[argname] = fixturedef</span>


<span class="s0">def </span><span class="s1">getfixturemarker(obj: object) -&gt; Optional[</span><span class="s2">&quot;FixtureFunctionMarker&quot;</span><span class="s1">]:</span>
    <span class="s3">&quot;&quot;&quot;Return fixturemarker or None if it doesn't exist or raised 
    exceptions.&quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">fixturemarker: Optional[FixtureFunctionMarker] = getattr(</span>
            <span class="s1">obj, </span><span class="s2">&quot;_pytestfixturefunction&quot;</span><span class="s1">, </span><span class="s0">None</span>
        <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">TEST_OUTCOME:</span>
        <span class="s3"># some objects raise errors like request (from flask import request)</span>
        <span class="s3"># we don't expect them to be fixture functions</span>
        <span class="s0">return None</span>
    <span class="s0">return </span><span class="s1">fixturemarker</span>


<span class="s3"># Parametrized fixture key, helper alias for code below.</span>
<span class="s1">_Key = Tuple[object, ...]</span>


<span class="s0">def </span><span class="s1">get_parametrized_fixture_keys(item: nodes.Item, scopenum: int) -&gt; Iterator[_Key]:</span>
    <span class="s3">&quot;&quot;&quot;Return list of keys for all parametrized arguments which match 
    the specified scope. &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">scopenum &lt; scopenum_function  </span><span class="s3"># function</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">callspec = item.callspec  </span><span class="s3"># type: ignore[attr-defined]</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cs: CallSpec2 = callspec</span>
        <span class="s3"># cs.indices.items() is random order of argnames.  Need to</span>
        <span class="s3"># sort this so that different calls to</span>
        <span class="s3"># get_parametrized_fixture_keys will be deterministic.</span>
        <span class="s0">for </span><span class="s1">argname, param_index </span><span class="s0">in </span><span class="s1">sorted(cs.indices.items()):</span>
            <span class="s0">if </span><span class="s1">cs._arg2scopenum[argname] != scopenum:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">scopenum == </span><span class="s4">0</span><span class="s1">:  </span><span class="s3"># session</span>
                <span class="s1">key: _Key = (argname, param_index)</span>
            <span class="s0">elif </span><span class="s1">scopenum == </span><span class="s4">1</span><span class="s1">:  </span><span class="s3"># package</span>
                <span class="s1">key = (argname, param_index, item.fspath.dirpath())</span>
            <span class="s0">elif </span><span class="s1">scopenum == </span><span class="s4">2</span><span class="s1">:  </span><span class="s3"># module</span>
                <span class="s1">key = (argname, param_index, item.fspath)</span>
            <span class="s0">elif </span><span class="s1">scopenum == </span><span class="s4">3</span><span class="s1">:  </span><span class="s3"># class</span>
                <span class="s1">item_cls = item.cls  </span><span class="s3"># type: ignore[attr-defined]</span>
                <span class="s1">key = (argname, param_index, item.fspath, item_cls)</span>
            <span class="s0">yield </span><span class="s1">key</span>


<span class="s3"># Algorithm for sorting on a per-parametrized resource setup basis.</span>
<span class="s3"># It is called for scopenum==0 (session) first and performs sorting</span>
<span class="s3"># down to the lower scopes such as to minimize number of &quot;high scope&quot;</span>
<span class="s3"># setups and teardowns.</span>


<span class="s0">def </span><span class="s1">reorder_items(items: Sequence[nodes.Item]) -&gt; List[nodes.Item]:</span>
    <span class="s1">argkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, </span><span class="s0">None</span><span class="s1">]]] = {}</span>
    <span class="s1">items_by_argkey: Dict[int, Dict[_Key, Deque[nodes.Item]]] = {}</span>
    <span class="s0">for </span><span class="s1">scopenum </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s1">, scopenum_function):</span>
        <span class="s1">d: Dict[nodes.Item, Dict[_Key, </span><span class="s0">None</span><span class="s1">]] = {}</span>
        <span class="s1">argkeys_cache[scopenum] = d</span>
        <span class="s1">item_d: Dict[_Key, Deque[nodes.Item]] = defaultdict(deque)</span>
        <span class="s1">items_by_argkey[scopenum] = item_d</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items:</span>
            <span class="s1">keys = dict.fromkeys(get_parametrized_fixture_keys(item, scopenum), </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">keys:</span>
                <span class="s1">d[item] = keys</span>
                <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">keys:</span>
                    <span class="s1">item_d[key].append(item)</span>
    <span class="s1">items_dict = dict.fromkeys(items, </span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">list(reorder_items_atscope(items_dict, argkeys_cache, items_by_argkey, </span><span class="s4">0</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">fix_cache_order(</span>
    <span class="s1">item: nodes.Item,</span>
    <span class="s1">argkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, </span><span class="s0">None</span><span class="s1">]]],</span>
    <span class="s1">items_by_argkey: Dict[int, Dict[_Key, </span><span class="s2">&quot;Deque[nodes.Item]&quot;</span><span class="s1">]],</span>
<span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">for </span><span class="s1">scopenum </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s1">, scopenum_function):</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">argkeys_cache[scopenum].get(item, []):</span>
            <span class="s1">items_by_argkey[scopenum][key].appendleft(item)</span>


<span class="s0">def </span><span class="s1">reorder_items_atscope(</span>
    <span class="s1">items: Dict[nodes.Item, </span><span class="s0">None</span><span class="s1">],</span>
    <span class="s1">argkeys_cache: Dict[int, Dict[nodes.Item, Dict[_Key, </span><span class="s0">None</span><span class="s1">]]],</span>
    <span class="s1">items_by_argkey: Dict[int, Dict[_Key, </span><span class="s2">&quot;Deque[nodes.Item]&quot;</span><span class="s1">]],</span>
    <span class="s1">scopenum: int,</span>
<span class="s1">) -&gt; Dict[nodes.Item, </span><span class="s0">None</span><span class="s1">]:</span>
    <span class="s0">if </span><span class="s1">scopenum &gt;= scopenum_function </span><span class="s0">or </span><span class="s1">len(items) &lt; </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">items</span>
    <span class="s1">ignore: Set[Optional[_Key]] = set()</span>
    <span class="s1">items_deque = deque(items)</span>
    <span class="s1">items_done: Dict[nodes.Item, </span><span class="s0">None</span><span class="s1">] = {}</span>
    <span class="s1">scoped_items_by_argkey = items_by_argkey[scopenum]</span>
    <span class="s1">scoped_argkeys_cache = argkeys_cache[scopenum]</span>
    <span class="s0">while </span><span class="s1">items_deque:</span>
        <span class="s1">no_argkey_group: Dict[nodes.Item, </span><span class="s0">None</span><span class="s1">] = {}</span>
        <span class="s1">slicing_argkey = </span><span class="s0">None</span>
        <span class="s0">while </span><span class="s1">items_deque:</span>
            <span class="s1">item = items_deque.popleft()</span>
            <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items_done </span><span class="s0">or </span><span class="s1">item </span><span class="s0">in </span><span class="s1">no_argkey_group:</span>
                <span class="s0">continue</span>
            <span class="s1">argkeys = dict.fromkeys(</span>
                <span class="s1">(k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">scoped_argkeys_cache.get(item, []) </span><span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">ignore), </span><span class="s0">None</span>
            <span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">argkeys:</span>
                <span class="s1">no_argkey_group[item] = </span><span class="s0">None</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">slicing_argkey, _ = argkeys.popitem()</span>
                <span class="s3"># We don't have to remove relevant items from later in the</span>
                <span class="s3"># deque because they'll just be ignored.</span>
                <span class="s1">matching_items = [</span>
                    <span class="s1">i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">scoped_items_by_argkey[slicing_argkey] </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">items</span>
                <span class="s1">]</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">reversed(matching_items):</span>
                    <span class="s1">fix_cache_order(i, argkeys_cache, items_by_argkey)</span>
                    <span class="s1">items_deque.appendleft(i)</span>
                <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">no_argkey_group:</span>
            <span class="s1">no_argkey_group = reorder_items_atscope(</span>
                <span class="s1">no_argkey_group, argkeys_cache, items_by_argkey, scopenum + </span><span class="s4">1</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">no_argkey_group:</span>
                <span class="s1">items_done[item] = </span><span class="s0">None</span>
        <span class="s1">ignore.add(slicing_argkey)</span>
    <span class="s0">return </span><span class="s1">items_done</span>


<span class="s0">def </span><span class="s1">_fillfuncargs(function: </span><span class="s2">&quot;Function&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot;Fill missing fixtures for a test function, old public API (deprecated).&quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(FILLFUNCARGS.format(name=</span><span class="s2">&quot;pytest._fillfuncargs()&quot;</span><span class="s1">), stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">_fill_fixtures_impl(function)</span>


<span class="s0">def </span><span class="s1">fillfixtures(function: </span><span class="s2">&quot;Function&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot;Fill missing fixtures for a test function (deprecated).&quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span>
        <span class="s1">FILLFUNCARGS.format(name=</span><span class="s2">&quot;_pytest.fixtures.fillfixtures()&quot;</span><span class="s1">), stacklevel=</span><span class="s4">2</span>
    <span class="s1">)</span>
    <span class="s1">_fill_fixtures_impl(function)</span>


<span class="s0">def </span><span class="s1">_fill_fixtures_impl(function: </span><span class="s2">&quot;Function&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot;Internal implementation to fill fixtures on the given function object.&quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">request = function._request</span>
    <span class="s0">except </span><span class="s1">AttributeError:</span>
        <span class="s3"># XXX this special code path is only expected to execute</span>
        <span class="s3"># with the oejskit plugin.  It uses classes with funcargs</span>
        <span class="s3"># and we thus have to work a bit to allow this.</span>
        <span class="s1">fm = function.session._fixturemanager</span>
        <span class="s0">assert </span><span class="s1">function.parent </span><span class="s0">is not None</span>
        <span class="s1">fi = fm.getfixtureinfo(function.parent, function.obj, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">function._fixtureinfo = fi</span>
        <span class="s1">request = function._request = FixtureRequest(function, _ispytest=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">request._fillfixtures()</span>
        <span class="s3"># Prune out funcargs for jstests.</span>
        <span class="s1">newfuncargs = {}</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">fi.argnames:</span>
            <span class="s1">newfuncargs[name] = function.funcargs[name]</span>
        <span class="s1">function.funcargs = newfuncargs</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">request._fillfixtures()</span>


<span class="s0">def </span><span class="s1">get_direct_param_fixture_func(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s1">@attr.s(slots=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">FuncFixtureInfo:</span>
    <span class="s3"># Original function argument names.</span>
    <span class="s1">argnames = attr.ib(type=Tuple[str, ...])</span>
    <span class="s3"># Argnames that function immediately requires. These include argnames +</span>
    <span class="s3"># fixture names specified via usefixtures and via autouse=True in fixture</span>
    <span class="s3"># definitions.</span>
    <span class="s1">initialnames = attr.ib(type=Tuple[str, ...])</span>
    <span class="s1">names_closure = attr.ib(type=List[str])</span>
    <span class="s1">name2fixturedefs = attr.ib(type=Dict[str, Sequence[</span><span class="s2">&quot;FixtureDef[Any]&quot;</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">prune_dependency_tree(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Recompute names_closure from initialnames and name2fixturedefs. 
 
        Can only reduce names_closure, which means that the new closure will 
        always be a subset of the old one. The order is preserved. 
 
        This method is needed because direct parametrization may shadow some 
        of the fixtures that were included in the originally built dependency 
        tree. In this way the dependency tree can get pruned, and the closure 
        of argnames may get reduced. 
        &quot;&quot;&quot;</span>
        <span class="s1">closure: Set[str] = set()</span>
        <span class="s1">working_set = set(self.initialnames)</span>
        <span class="s0">while </span><span class="s1">working_set:</span>
            <span class="s1">argname = working_set.pop()</span>
            <span class="s3"># Argname may be smth not included in the original names_closure,</span>
            <span class="s3"># in which case we ignore it. This currently happens with pseudo</span>
            <span class="s3"># FixtureDefs which wrap 'get_direct_param_fixture_func(request)'.</span>
            <span class="s3"># So they introduce the new dependency 'request' which might have</span>
            <span class="s3"># been missing in the original tree (closure).</span>
            <span class="s0">if </span><span class="s1">argname </span><span class="s0">not in </span><span class="s1">closure </span><span class="s0">and </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">self.names_closure:</span>
                <span class="s1">closure.add(argname)</span>
                <span class="s0">if </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">self.name2fixturedefs:</span>
                    <span class="s1">working_set.update(self.name2fixturedefs[argname][-</span><span class="s4">1</span><span class="s1">].argnames)</span>

        <span class="s1">self.names_closure[:] = sorted(closure, key=self.names_closure.index)</span>


<span class="s0">class </span><span class="s1">FixtureRequest:</span>
    <span class="s3">&quot;&quot;&quot;A request for a fixture from a test or fixture function. 
 
    A request object gives access to the requesting test context and has 
    an optional ``param`` attribute in case the fixture is parametrized 
    indirectly. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self, pyfuncitem, *, _ispytest: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s1">self._pyfuncitem = pyfuncitem</span>
        <span class="s3">#: Fixture for which this request is being performed.</span>
        <span class="s1">self.fixturename: Optional[str] = </span><span class="s0">None</span>
        <span class="s3">#: Scope string, one of &quot;function&quot;, &quot;class&quot;, &quot;module&quot;, &quot;session&quot;.</span>
        <span class="s1">self.scope: _Scope = </span><span class="s2">&quot;function&quot;</span>
        <span class="s1">self._fixture_defs: Dict[str, FixtureDef[Any]] = {}</span>
        <span class="s1">fixtureinfo: FuncFixtureInfo = pyfuncitem._fixtureinfo</span>
        <span class="s1">self._arg2fixturedefs = fixtureinfo.name2fixturedefs.copy()</span>
        <span class="s1">self._arg2index: Dict[str, int] = {}</span>
        <span class="s1">self._fixturemanager: FixtureManager = (pyfuncitem.session._fixturemanager)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fixturenames(self) -&gt; List[str]:</span>
        <span class="s3">&quot;&quot;&quot;Names of all active fixtures in this request.&quot;&quot;&quot;</span>
        <span class="s1">result = list(self._pyfuncitem._fixtureinfo.names_closure)</span>
        <span class="s1">result.extend(set(self._fixture_defs).difference(result))</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">node(self):</span>
        <span class="s3">&quot;&quot;&quot;Underlying collection node (depends on current request scope).&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._getscopeitem(self.scope)</span>

    <span class="s0">def </span><span class="s1">_getnextfixturedef(self, argname: str) -&gt; </span><span class="s2">&quot;FixtureDef[Any]&quot;</span><span class="s1">:</span>
        <span class="s1">fixturedefs = self._arg2fixturedefs.get(argname, </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">fixturedefs </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s3"># We arrive here because of a dynamic call to</span>
            <span class="s3"># getfixturevalue(argname) usage which was naturally</span>
            <span class="s3"># not known at parsing/collection time.</span>
            <span class="s0">assert </span><span class="s1">self._pyfuncitem.parent </span><span class="s0">is not None</span>
            <span class="s1">parentid = self._pyfuncitem.parent.nodeid</span>
            <span class="s1">fixturedefs = self._fixturemanager.getfixturedefs(argname, parentid)</span>
            <span class="s3"># TODO: Fix this type ignore. Either add assert or adjust types.</span>
            <span class="s3">#       Can this be None here?</span>
            <span class="s1">self._arg2fixturedefs[argname] = fixturedefs  </span><span class="s3"># type: ignore[assignment]</span>
        <span class="s3"># fixturedefs list is immutable so we maintain a decreasing index.</span>
        <span class="s1">index = self._arg2index.get(argname, </span><span class="s4">0</span><span class="s1">) - </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">fixturedefs </span><span class="s0">is None or </span><span class="s1">(-index &gt; len(fixturedefs)):</span>
            <span class="s0">raise </span><span class="s1">FixtureLookupError(argname, self)</span>
        <span class="s1">self._arg2index[argname] = index</span>
        <span class="s0">return </span><span class="s1">fixturedefs[index]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">config(self) -&gt; Config:</span>
        <span class="s3">&quot;&quot;&quot;The pytest config object associated with this request.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._pyfuncitem.config  </span><span class="s3"># type: ignore[no-any-return]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">function(self):</span>
        <span class="s3">&quot;&quot;&quot;Test function object if the request has a per-function scope.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.scope != </span><span class="s2">&quot;function&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span>
                <span class="s2">f&quot;function not available in </span><span class="s5">{</span><span class="s1">self.scope</span><span class="s5">}</span><span class="s2">-scoped context&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._pyfuncitem.obj</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">cls(self):</span>
        <span class="s3">&quot;&quot;&quot;Class (can be None) where the test function was collected.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.scope </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;class&quot;</span><span class="s1">, </span><span class="s2">&quot;function&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">f&quot;cls not available in </span><span class="s5">{</span><span class="s1">self.scope</span><span class="s5">}</span><span class="s2">-scoped context&quot;</span><span class="s1">)</span>
        <span class="s1">clscol = self._pyfuncitem.getparent(_pytest.python.Class)</span>
        <span class="s0">if </span><span class="s1">clscol:</span>
            <span class="s0">return </span><span class="s1">clscol.obj</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">instance(self):</span>
        <span class="s3">&quot;&quot;&quot;Instance (can be None) on which test function was collected.&quot;&quot;&quot;</span>
        <span class="s3"># unittest support hack, see _pytest.unittest.TestCaseFunction.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._pyfuncitem._testcase</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s1">function = getattr(self, </span><span class="s2">&quot;function&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">getattr(function, </span><span class="s2">&quot;__self__&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">module(self):</span>
        <span class="s3">&quot;&quot;&quot;Python module object where the test function was collected.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.scope </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">, </span><span class="s2">&quot;class&quot;</span><span class="s1">, </span><span class="s2">&quot;module&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">f&quot;module not available in </span><span class="s5">{</span><span class="s1">self.scope</span><span class="s5">}</span><span class="s2">-scoped context&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._pyfuncitem.getparent(_pytest.python.Module).obj</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fspath(self) -&gt; py.path.local:</span>
        <span class="s3">&quot;&quot;&quot;The file system path of the test module which collected this test.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.scope </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">, </span><span class="s2">&quot;class&quot;</span><span class="s1">, </span><span class="s2">&quot;module&quot;</span><span class="s1">, </span><span class="s2">&quot;package&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">f&quot;module not available in </span><span class="s5">{</span><span class="s1">self.scope</span><span class="s5">}</span><span class="s2">-scoped context&quot;</span><span class="s1">)</span>
        <span class="s3"># TODO: Remove ignore once _pyfuncitem is properly typed.</span>
        <span class="s0">return </span><span class="s1">self._pyfuncitem.fspath  </span><span class="s3"># type: ignore</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">keywords(self):</span>
        <span class="s3">&quot;&quot;&quot;Keywords/markers dictionary for the underlying node.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.node.keywords</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">session(self) -&gt; </span><span class="s2">&quot;Session&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Pytest session object.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._pyfuncitem.session  </span><span class="s3"># type: ignore[no-any-return]</span>

    <span class="s0">def </span><span class="s1">addfinalizer(self, finalizer: Callable[[], object]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Add finalizer/teardown function to be called after the last test 
        within the requesting test context finished execution.&quot;&quot;&quot;</span>
        <span class="s3"># XXX usually this method is shadowed by fixturedef specific ones.</span>
        <span class="s1">self._addfinalizer(finalizer, scope=self.scope)</span>

    <span class="s0">def </span><span class="s1">_addfinalizer(self, finalizer: Callable[[], object], scope) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">colitem = self._getscopeitem(scope)</span>
        <span class="s1">self._pyfuncitem.session._setupstate.addfinalizer(</span>
            <span class="s1">finalizer=finalizer, colitem=colitem</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">applymarker(self, marker: Union[str, MarkDecorator]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Apply a marker to a single test function invocation. 
 
        This method is useful if you don't want to have a keyword/marker 
        on all function invocations. 
 
        :param marker: 
            A :py:class:`_pytest.mark.MarkDecorator` object created by a call 
            to ``pytest.mark.NAME(...)``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.node.add_marker(marker)</span>

    <span class="s0">def </span><span class="s1">raiseerror(self, msg: Optional[str]) -&gt; </span><span class="s2">&quot;NoReturn&quot;</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Raise a FixtureLookupError with the given message.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">self._fixturemanager.FixtureLookupError(</span><span class="s0">None</span><span class="s1">, self, msg)</span>

    <span class="s0">def </span><span class="s1">_fillfixtures(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">item = self._pyfuncitem</span>
        <span class="s1">fixturenames = getattr(item, </span><span class="s2">&quot;fixturenames&quot;</span><span class="s1">, self.fixturenames)</span>
        <span class="s0">for </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">fixturenames:</span>
            <span class="s0">if </span><span class="s1">argname </span><span class="s0">not in </span><span class="s1">item.funcargs:</span>
                <span class="s1">item.funcargs[argname] = self.getfixturevalue(argname)</span>

    <span class="s0">def </span><span class="s1">getfixturevalue(self, argname: str) -&gt; Any:</span>
        <span class="s3">&quot;&quot;&quot;Dynamically run a named fixture function. 
 
        Declaring fixtures via function argument is recommended where possible. 
        But if you can only decide whether to use another fixture at test 
        setup time, you may use this function to retrieve it inside a fixture 
        or test function body. 
 
        :raises pytest.FixtureLookupError: 
            If the given fixture could not be found. 
        &quot;&quot;&quot;</span>
        <span class="s1">fixturedef = self._get_active_fixturedef(argname)</span>
        <span class="s0">assert </span><span class="s1">fixturedef.cached_result </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">fixturedef.cached_result[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_get_active_fixturedef(</span>
        <span class="s1">self, argname: str</span>
    <span class="s1">) -&gt; Union[</span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">, PseudoFixtureDef[object]]:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._fixture_defs[argname]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fixturedef = self._getnextfixturedef(argname)</span>
            <span class="s0">except </span><span class="s1">FixtureLookupError:</span>
                <span class="s0">if </span><span class="s1">argname == </span><span class="s2">&quot;request&quot;</span><span class="s1">:</span>
                    <span class="s1">cached_result = (self, [</span><span class="s4">0</span><span class="s1">], </span><span class="s0">None</span><span class="s1">)</span>
                    <span class="s1">scope: _Scope = </span><span class="s2">&quot;function&quot;</span>
                    <span class="s0">return </span><span class="s1">PseudoFixtureDef(cached_result, scope)</span>
                <span class="s0">raise</span>
        <span class="s3"># Remove indent to prevent the python3 exception</span>
        <span class="s3"># from leaking into the call.</span>
        <span class="s1">self._compute_fixture_value(fixturedef)</span>
        <span class="s1">self._fixture_defs[argname] = fixturedef</span>
        <span class="s0">return </span><span class="s1">fixturedef</span>

    <span class="s0">def </span><span class="s1">_get_fixturestack(self) -&gt; List[</span><span class="s2">&quot;FixtureDef[Any]&quot;</span><span class="s1">]:</span>
        <span class="s1">current = self</span>
        <span class="s1">values: List[FixtureDef[Any]] = []</span>
        <span class="s0">while </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">fixturedef = getattr(current, </span><span class="s2">&quot;_fixturedef&quot;</span><span class="s1">, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">fixturedef </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">values.reverse()</span>
                <span class="s0">return </span><span class="s1">values</span>
            <span class="s1">values.append(fixturedef)</span>
            <span class="s0">assert </span><span class="s1">isinstance(current, SubRequest)</span>
            <span class="s1">current = current._parent_request</span>

    <span class="s0">def </span><span class="s1">_compute_fixture_value(self, fixturedef: </span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method 
        of the given FixtureDef object. 
 
        This will force the FixtureDef object to throw away any previous 
        results and compute a new fixture value, which will be stored into 
        the FixtureDef object itself. 
        &quot;&quot;&quot;</span>
        <span class="s3"># prepare a subrequest object before calling fixture function</span>
        <span class="s3"># (latter managed by fixturedef)</span>
        <span class="s1">argname = fixturedef.argname</span>
        <span class="s1">funcitem = self._pyfuncitem</span>
        <span class="s1">scope = fixturedef.scope</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">param = funcitem.callspec.getparam(argname)</span>
        <span class="s0">except </span><span class="s1">(AttributeError, ValueError):</span>
            <span class="s1">param = NOTSET</span>
            <span class="s1">param_index = </span><span class="s4">0</span>
            <span class="s1">has_params = fixturedef.params </span><span class="s0">is not None</span>
            <span class="s1">fixtures_not_supported = getattr(funcitem, </span><span class="s2">&quot;nofuncargs&quot;</span><span class="s1">, </span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">has_params </span><span class="s0">and </span><span class="s1">fixtures_not_supported:</span>
                <span class="s1">msg = (</span>
                    <span class="s2">&quot;{name} does not support fixtures, maybe unittest.TestCase subclass?</span><span class="s5">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Node id: {nodeid}</span><span class="s5">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Function type: {typename}&quot;</span>
                <span class="s1">).format(</span>
                    <span class="s1">name=funcitem.name,</span>
                    <span class="s1">nodeid=funcitem.nodeid,</span>
                    <span class="s1">typename=type(funcitem).__name__,</span>
                <span class="s1">)</span>
                <span class="s1">fail(msg, pytrace=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">has_params:</span>
                <span class="s1">frame = inspect.stack()[</span><span class="s4">3</span><span class="s1">]</span>
                <span class="s1">frameinfo = inspect.getframeinfo(frame[</span><span class="s4">0</span><span class="s1">])</span>
                <span class="s1">source_path = py.path.local(frameinfo.filename)</span>
                <span class="s1">source_lineno = frameinfo.lineno</span>
                <span class="s1">rel_source_path = source_path.relto(funcitem.config.rootdir)</span>
                <span class="s0">if </span><span class="s1">rel_source_path:</span>
                    <span class="s1">source_path_str = rel_source_path</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">source_path_str = str(source_path)</span>
                <span class="s1">msg = (</span>
                    <span class="s2">&quot;The requested fixture has no parameter defined for test:</span><span class="s5">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;    {}</span><span class="s5">\n\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;Requested fixture '{}' defined in:</span><span class="s5">\n</span><span class="s2">{}&quot;</span>
                    <span class="s2">&quot;</span><span class="s5">\n\n</span><span class="s2">Requested here:</span><span class="s5">\n</span><span class="s2">{}:{}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">funcitem.nodeid,</span>
                        <span class="s1">fixturedef.argname,</span>
                        <span class="s1">getlocation(fixturedef.func, funcitem.config.rootdir),</span>
                        <span class="s1">source_path_str,</span>
                        <span class="s1">source_lineno,</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s1">fail(msg, pytrace=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">param_index = funcitem.callspec.indices[argname]</span>
            <span class="s3"># If a parametrize invocation set a scope it will override</span>
            <span class="s3"># the static scope defined with the fixture function.</span>
            <span class="s1">paramscopenum = funcitem.callspec._arg2scopenum.get(argname)</span>
            <span class="s0">if </span><span class="s1">paramscopenum </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">scope = scopes[paramscopenum]</span>

        <span class="s1">subrequest = SubRequest(</span>
            <span class="s1">self, scope, param, param_index, fixturedef, _ispytest=</span><span class="s0">True</span>
        <span class="s1">)</span>

        <span class="s3"># Check if a higher-level scoped fixture accesses a lower level one.</span>
        <span class="s1">subrequest._check_scope(argname, self.scope, scope)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s3"># Call the fixture function.</span>
            <span class="s1">fixturedef.execute(request=subrequest)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">self._schedule_finalizers(fixturedef, subrequest)</span>

    <span class="s0">def </span><span class="s1">_schedule_finalizers(</span>
        <span class="s1">self, fixturedef: </span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">, subrequest: </span><span class="s2">&quot;SubRequest&quot;</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># If fixture function failed it might have registered finalizers.</span>
        <span class="s1">self.session._setupstate.addfinalizer(</span>
            <span class="s1">functools.partial(fixturedef.finish, request=subrequest), subrequest.node</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_scope(</span>
        <span class="s1">self, argname: str, invoking_scope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">, requested_scope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">argname == </span><span class="s2">&quot;request&quot;</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">scopemismatch(invoking_scope, requested_scope):</span>
            <span class="s3"># Try to report something helpful.</span>
            <span class="s1">lines = self._factorytraceback()</span>
            <span class="s1">fail(</span>
                <span class="s2">&quot;ScopeMismatch: You tried to access the %r scoped &quot;</span>
                <span class="s2">&quot;fixture %r with a %r scoped request object, &quot;</span>
                <span class="s2">&quot;involved factories</span><span class="s5">\n</span><span class="s2">%s&quot;</span>
                <span class="s1">% ((requested_scope, argname, invoking_scope, </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">.join(lines))),</span>
                <span class="s1">pytrace=</span><span class="s0">False</span><span class="s1">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_factorytraceback(self) -&gt; List[str]:</span>
        <span class="s1">lines = []</span>
        <span class="s0">for </span><span class="s1">fixturedef </span><span class="s0">in </span><span class="s1">self._get_fixturestack():</span>
            <span class="s1">factory = fixturedef.func</span>
            <span class="s1">fs, lineno = getfslineno(factory)</span>
            <span class="s1">p = self._pyfuncitem.session.fspath.bestrelpath(fs)</span>
            <span class="s1">args = _format_args(factory)</span>
            <span class="s1">lines.append(</span><span class="s2">&quot;%s:%d:  def %s%s&quot; </span><span class="s1">% (p, lineno + </span><span class="s4">1</span><span class="s1">, factory.__name__, args))</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">_getscopeitem(self, scope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">) -&gt; Union[nodes.Item, nodes.Collector]:</span>
        <span class="s0">if </span><span class="s1">scope == </span><span class="s2">&quot;function&quot;</span><span class="s1">:</span>
            <span class="s3"># This might also be a non-function Item despite its attribute name.</span>
            <span class="s1">node: Optional[Union[nodes.Item, nodes.Collector]] = self._pyfuncitem</span>
        <span class="s0">elif </span><span class="s1">scope == </span><span class="s2">&quot;package&quot;</span><span class="s1">:</span>
            <span class="s3"># FIXME: _fixturedef is not defined on FixtureRequest (this class),</span>
            <span class="s3"># but on FixtureRequest (a subclass).</span>
            <span class="s1">node = get_scope_package(self._pyfuncitem, self._fixturedef)  </span><span class="s3"># type: ignore[attr-defined]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">node = get_scope_node(self._pyfuncitem, scope)</span>
        <span class="s0">if </span><span class="s1">node </span><span class="s0">is None and </span><span class="s1">scope == </span><span class="s2">&quot;class&quot;</span><span class="s1">:</span>
            <span class="s3"># Fallback to function item itself.</span>
            <span class="s1">node = self._pyfuncitem</span>
        <span class="s0">assert </span><span class="s1">node, </span><span class="s2">'Could not obtain a node for scope &quot;{}&quot; for function {!r}'</span><span class="s1">.format(</span>
            <span class="s1">scope, self._pyfuncitem</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">node</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;FixtureRequest for %r&gt;&quot; </span><span class="s1">% (self.node)</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">SubRequest(FixtureRequest):</span>
    <span class="s3">&quot;&quot;&quot;A sub request for handling getting a fixture from a test function/fixture.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">request: </span><span class="s2">&quot;FixtureRequest&quot;</span><span class="s1">,</span>
        <span class="s1">scope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">,</span>
        <span class="s1">param,</span>
        <span class="s1">param_index: int,</span>
        <span class="s1">fixturedef: </span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">,</span>
        <span class="s1">*,</span>
        <span class="s1">_ispytest: bool = </span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s1">self._parent_request = request</span>
        <span class="s1">self.fixturename = fixturedef.argname</span>
        <span class="s0">if </span><span class="s1">param </span><span class="s0">is not </span><span class="s1">NOTSET:</span>
            <span class="s1">self.param = param</span>
        <span class="s1">self.param_index = param_index</span>
        <span class="s1">self.scope = scope</span>
        <span class="s1">self._fixturedef = fixturedef</span>
        <span class="s1">self._pyfuncitem = request._pyfuncitem</span>
        <span class="s1">self._fixture_defs = request._fixture_defs</span>
        <span class="s1">self._arg2fixturedefs = request._arg2fixturedefs</span>
        <span class="s1">self._arg2index = request._arg2index</span>
        <span class="s1">self._fixturemanager = request._fixturemanager</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;SubRequest </span><span class="s5">{</span><span class="s1">self.fixturename</span><span class="s5">!r} </span><span class="s2">for </span><span class="s5">{</span><span class="s1">self._pyfuncitem</span><span class="s5">!r}</span><span class="s2">&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">addfinalizer(self, finalizer: Callable[[], object]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Add finalizer/teardown function to be called after the last test 
        within the requesting test context finished execution.&quot;&quot;&quot;</span>
        <span class="s1">self._fixturedef.addfinalizer(finalizer)</span>

    <span class="s0">def </span><span class="s1">_schedule_finalizers(</span>
        <span class="s1">self, fixturedef: </span><span class="s2">&quot;FixtureDef[object]&quot;</span><span class="s1">, subrequest: </span><span class="s2">&quot;SubRequest&quot;</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># If the executing fixturedef was not explicitly requested in the argument list (via</span>
        <span class="s3"># getfixturevalue inside the fixture call) then ensure this fixture def will be finished</span>
        <span class="s3"># first.</span>
        <span class="s0">if </span><span class="s1">fixturedef.argname </span><span class="s0">not in </span><span class="s1">self.fixturenames:</span>
            <span class="s1">fixturedef.addfinalizer(</span>
                <span class="s1">functools.partial(self._fixturedef.finish, request=self)</span>
            <span class="s1">)</span>
        <span class="s1">super()._schedule_finalizers(fixturedef, subrequest)</span>


<span class="s1">scopes: List[</span><span class="s2">&quot;_Scope&quot;</span><span class="s1">] = [</span><span class="s2">&quot;session&quot;</span><span class="s1">, </span><span class="s2">&quot;package&quot;</span><span class="s1">, </span><span class="s2">&quot;module&quot;</span><span class="s1">, </span><span class="s2">&quot;class&quot;</span><span class="s1">, </span><span class="s2">&quot;function&quot;</span><span class="s1">]</span>
<span class="s1">scopenum_function = scopes.index(</span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">scopemismatch(currentscope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">, newscope: </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">) -&gt; bool:</span>
    <span class="s0">return </span><span class="s1">scopes.index(newscope) &gt; scopes.index(currentscope)</span>


<span class="s0">def </span><span class="s1">scope2index(scope: str, descr: str, where: Optional[str] = </span><span class="s0">None</span><span class="s1">) -&gt; int:</span>
    <span class="s3">&quot;&quot;&quot;Look up the index of ``scope`` and raise a descriptive value error 
    if not defined.&quot;&quot;&quot;</span>
    <span class="s1">strscopes: Sequence[str] = scopes</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">strscopes.index(scope)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s1">fail(</span>
            <span class="s2">&quot;{} {}got an unexpected scope value '{}'&quot;</span><span class="s1">.format(</span>
                <span class="s1">descr, </span><span class="s2">f&quot;from </span><span class="s5">{</span><span class="s1">where</span><span class="s5">} </span><span class="s2">&quot; </span><span class="s0">if </span><span class="s1">where </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s1">, scope</span>
            <span class="s1">),</span>
            <span class="s1">pytrace=</span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">)</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">FixtureLookupError(LookupError):</span>
    <span class="s3">&quot;&quot;&quot;Could not return a requested fixture (missing or invalid).&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self, argname: Optional[str], request: FixtureRequest, msg: Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.argname = argname</span>
        <span class="s1">self.request = request</span>
        <span class="s1">self.fixturestack = request._get_fixturestack()</span>
        <span class="s1">self.msg = msg</span>

    <span class="s0">def </span><span class="s1">formatrepr(self) -&gt; </span><span class="s2">&quot;FixtureLookupErrorRepr&quot;</span><span class="s1">:</span>
        <span class="s1">tblines: List[str] = []</span>
        <span class="s1">addline = tblines.append</span>
        <span class="s1">stack = [self.request._pyfuncitem.obj]</span>
        <span class="s1">stack.extend(map(</span><span class="s0">lambda </span><span class="s1">x: x.func, self.fixturestack))</span>
        <span class="s1">msg = self.msg</span>
        <span class="s0">if </span><span class="s1">msg </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># The last fixture raise an error, let's present</span>
            <span class="s3"># it at the requesting side.</span>
            <span class="s1">stack = stack[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">function </span><span class="s0">in </span><span class="s1">stack:</span>
            <span class="s1">fspath, lineno = getfslineno(function)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">lines, _ = inspect.getsourcelines(get_real_func(function))</span>
            <span class="s0">except </span><span class="s1">(OSError, IndexError, TypeError):</span>
                <span class="s1">error_msg = </span><span class="s2">&quot;file %s, line %s: source code not available&quot;</span>
                <span class="s1">addline(error_msg % (fspath, lineno + </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">addline(</span><span class="s2">&quot;file {}, line {}&quot;</span><span class="s1">.format(fspath, lineno + </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s0">for </span><span class="s1">i, line </span><span class="s0">in </span><span class="s1">enumerate(lines):</span>
                    <span class="s1">line = line.rstrip()</span>
                    <span class="s1">addline(</span><span class="s2">&quot;  &quot; </span><span class="s1">+ line)</span>
                    <span class="s0">if </span><span class="s1">line.lstrip().startswith(</span><span class="s2">&quot;def&quot;</span><span class="s1">):</span>
                        <span class="s0">break</span>

        <span class="s0">if </span><span class="s1">msg </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">fm = self.request._fixturemanager</span>
            <span class="s1">available = set()</span>
            <span class="s1">parentid = self.request._pyfuncitem.parent.nodeid</span>
            <span class="s0">for </span><span class="s1">name, fixturedefs </span><span class="s0">in </span><span class="s1">fm._arg2fixturedefs.items():</span>
                <span class="s1">faclist = list(fm._matchfactories(fixturedefs, parentid))</span>
                <span class="s0">if </span><span class="s1">faclist:</span>
                    <span class="s1">available.add(name)</span>
            <span class="s0">if </span><span class="s1">self.argname </span><span class="s0">in </span><span class="s1">available:</span>
                <span class="s1">msg = </span><span class="s2">&quot; recursive dependency involving fixture '{}' detected&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self.argname</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s2">f&quot;fixture '</span><span class="s5">{</span><span class="s1">self.argname</span><span class="s5">}</span><span class="s2">' not found&quot;</span>
            <span class="s1">msg += </span><span class="s2">&quot;</span><span class="s5">\n </span><span class="s2">available fixtures: {}&quot;</span><span class="s1">.format(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(sorted(available)))</span>
            <span class="s1">msg += </span><span class="s2">&quot;</span><span class="s5">\n </span><span class="s2">use 'pytest --fixtures [testpath]' for help on them.&quot;</span>

        <span class="s0">return </span><span class="s1">FixtureLookupErrorRepr(fspath, lineno, tblines, msg, self.argname)</span>


<span class="s0">class </span><span class="s1">FixtureLookupErrorRepr(TerminalRepr):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">filename: Union[str, py.path.local],</span>
        <span class="s1">firstlineno: int,</span>
        <span class="s1">tblines: Sequence[str],</span>
        <span class="s1">errorstring: str,</span>
        <span class="s1">argname: Optional[str],</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.tblines = tblines</span>
        <span class="s1">self.errorstring = errorstring</span>
        <span class="s1">self.filename = filename</span>
        <span class="s1">self.firstlineno = firstlineno</span>
        <span class="s1">self.argname = argname</span>

    <span class="s0">def </span><span class="s1">toterminal(self, tw: TerminalWriter) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># tw.line(&quot;FixtureLookupError: %s&quot; %(self.argname), red=True)</span>
        <span class="s0">for </span><span class="s1">tbline </span><span class="s0">in </span><span class="s1">self.tblines:</span>
            <span class="s1">tw.line(tbline.rstrip())</span>
        <span class="s1">lines = self.errorstring.split(</span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">lines:</span>
            <span class="s1">tw.line(</span>
                <span class="s2">&quot;{}       {}&quot;</span><span class="s1">.format(FormattedExcinfo.fail_marker, lines[</span><span class="s4">0</span><span class="s1">].strip()),</span>
                <span class="s1">red=</span><span class="s0">True</span><span class="s1">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">lines[</span><span class="s4">1</span><span class="s1">:]:</span>
                <span class="s1">tw.line(</span>
                    <span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">FormattedExcinfo.flow_marker</span><span class="s5">}       {</span><span class="s1">line.strip()</span><span class="s5">}</span><span class="s2">&quot;</span><span class="s1">, red=</span><span class="s0">True</span><span class="s1">,</span>
                <span class="s1">)</span>
        <span class="s1">tw.line()</span>
        <span class="s1">tw.line(</span><span class="s2">&quot;%s:%d&quot; </span><span class="s1">% (self.filename, self.firstlineno + </span><span class="s4">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">fail_fixturefunc(fixturefunc, msg: str) -&gt; </span><span class="s2">&quot;NoReturn&quot;</span><span class="s1">:</span>
    <span class="s1">fs, lineno = getfslineno(fixturefunc)</span>
    <span class="s1">location = </span><span class="s2">&quot;{}:{}&quot;</span><span class="s1">.format(fs, lineno + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">source = _pytest._code.Source(fixturefunc)</span>
    <span class="s1">fail(msg + </span><span class="s2">&quot;:</span><span class="s5">\n\n</span><span class="s2">&quot; </span><span class="s1">+ str(source.indent()) + </span><span class="s2">&quot;</span><span class="s5">\n</span><span class="s2">&quot; </span><span class="s1">+ location, pytrace=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">call_fixture_func(</span>
    <span class="s1">fixturefunc: </span><span class="s2">&quot;_FixtureFunc[_FixtureValue]&quot;</span><span class="s1">, request: FixtureRequest, kwargs</span>
<span class="s1">) -&gt; _FixtureValue:</span>
    <span class="s0">if </span><span class="s1">is_generator(fixturefunc):</span>
        <span class="s1">fixturefunc = cast(</span>
            <span class="s1">Callable[..., Generator[_FixtureValue, </span><span class="s0">None</span><span class="s1">, </span><span class="s0">None</span><span class="s1">]], fixturefunc</span>
        <span class="s1">)</span>
        <span class="s1">generator = fixturefunc(**kwargs)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">fixture_result = next(generator)</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f&quot;</span><span class="s5">{</span><span class="s1">request.fixturename</span><span class="s5">} </span><span class="s2">did not yield a value&quot;</span><span class="s1">) </span><span class="s0">from None</span>
        <span class="s1">finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)</span>
        <span class="s1">request.addfinalizer(finalizer)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">fixturefunc = cast(Callable[..., _FixtureValue], fixturefunc)</span>
        <span class="s1">fixture_result = fixturefunc(**kwargs)</span>
    <span class="s0">return </span><span class="s1">fixture_result</span>


<span class="s0">def </span><span class="s1">_teardown_yield_fixture(fixturefunc, it) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot;Execute the teardown of a fixture function by advancing the iterator 
    after the yield and ensure the iteration ends (if not it means there is 
    more than one yield in the function).&quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">fail_fixturefunc(fixturefunc, </span><span class="s2">&quot;fixture function has more than one 'yield'&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_eval_scope_callable(</span>
    <span class="s1">scope_callable: </span><span class="s2">&quot;Callable[[str, Config], _Scope]&quot;</span><span class="s1">,</span>
    <span class="s1">fixture_name: str,</span>
    <span class="s1">config: Config,</span>
<span class="s1">) -&gt; </span><span class="s2">&quot;_Scope&quot;</span><span class="s1">:</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s3"># Type ignored because there is no typing mechanism to specify</span>
        <span class="s3"># keyword arguments, currently.</span>
        <span class="s1">result = scope_callable(fixture_name=fixture_name, config=config)  </span><span class="s3"># type: ignore[call-arg]</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s2">&quot;Error evaluating {} while defining fixture '{}'.</span><span class="s5">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Expected a function with the signature (*, fixture_name, config)&quot;</span><span class="s1">.format(</span>
                <span class="s1">scope_callable, fixture_name</span>
            <span class="s1">)</span>
        <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">if not </span><span class="s1">isinstance(result, str):</span>
        <span class="s1">fail(</span>
            <span class="s2">&quot;Expected {} to return a 'str' while defining fixture '{}', but it returned:</span><span class="s5">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;{!r}&quot;</span><span class="s1">.format(scope_callable, fixture_name, result),</span>
            <span class="s1">pytrace=</span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">FixtureDef(Generic[_FixtureValue]):</span>
    <span class="s3">&quot;&quot;&quot;A container for a factory definition.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self,</span>
        <span class="s1">fixturemanager: </span><span class="s2">&quot;FixtureManager&quot;</span><span class="s1">,</span>
        <span class="s1">baseid: Optional[str],</span>
        <span class="s1">argname: str,</span>
        <span class="s1">func: </span><span class="s2">&quot;_FixtureFunc[_FixtureValue]&quot;</span><span class="s1">,</span>
        <span class="s1">scope: </span><span class="s2">&quot;Union[_Scope, Callable[[str, Config], _Scope]]&quot;</span><span class="s1">,</span>
        <span class="s1">params: Optional[Sequence[object]],</span>
        <span class="s1">unittest: bool = </span><span class="s0">False</span><span class="s1">,</span>
        <span class="s1">ids: Optional[</span>
            <span class="s1">Union[</span>
                <span class="s1">Tuple[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool], ...],</span>
                <span class="s1">Callable[[Any], Optional[object]],</span>
            <span class="s1">]</span>
        <span class="s1">] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._fixturemanager = fixturemanager</span>
        <span class="s1">self.baseid = baseid </span><span class="s0">or </span><span class="s2">&quot;&quot;</span>
        <span class="s1">self.has_location = baseid </span><span class="s0">is not None</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.argname = argname</span>
        <span class="s0">if </span><span class="s1">callable(scope):</span>
            <span class="s1">scope_ = _eval_scope_callable(scope, argname, fixturemanager.config)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">scope_ = scope</span>
        <span class="s1">self.scopenum = scope2index(</span>
            <span class="s3"># TODO: Check if the `or` here is really necessary.</span>
            <span class="s1">scope_ </span><span class="s0">or </span><span class="s2">&quot;function&quot;</span><span class="s1">,  </span><span class="s3"># type: ignore[unreachable]</span>
            <span class="s1">descr=</span><span class="s2">f&quot;Fixture '</span><span class="s5">{</span><span class="s1">func.__name__</span><span class="s5">}</span><span class="s2">'&quot;</span><span class="s1">,</span>
            <span class="s1">where=baseid,</span>
        <span class="s1">)</span>
        <span class="s1">self.scope = scope_</span>
        <span class="s1">self.params: Optional[Sequence[object]] = params</span>
        <span class="s1">self.argnames: Tuple[str, ...] = getfuncargnames(</span>
            <span class="s1">func, name=argname, is_method=unittest</span>
        <span class="s1">)</span>
        <span class="s1">self.unittest = unittest</span>
        <span class="s1">self.ids = ids</span>
        <span class="s1">self.cached_result: Optional[_FixtureCachedResult[_FixtureValue]] = </span><span class="s0">None</span>
        <span class="s1">self._finalizers: List[Callable[[], object]] = []</span>

    <span class="s0">def </span><span class="s1">addfinalizer(self, finalizer: Callable[[], object]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._finalizers.append(finalizer)</span>

    <span class="s0">def </span><span class="s1">finish(self, request: SubRequest) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">exc = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while </span><span class="s1">self._finalizers:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">func = self._finalizers.pop()</span>
                    <span class="s1">func()</span>
                <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">e:</span>
                    <span class="s3"># XXX Only first exception will be seen by user,</span>
                    <span class="s3">#     ideally all should be reported.</span>
                    <span class="s0">if </span><span class="s1">exc </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s1">exc = e</span>
            <span class="s0">if </span><span class="s1">exc:</span>
                <span class="s0">raise </span><span class="s1">exc</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">hook = self._fixturemanager.session.gethookproxy(request.node.fspath)</span>
            <span class="s1">hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)</span>
            <span class="s3"># Even if finalization fails, we invalidate the cached fixture</span>
            <span class="s3"># value and remove all finalizers because they may be bound methods</span>
            <span class="s3"># which will keep instances alive.</span>
            <span class="s1">self.cached_result = </span><span class="s0">None</span>
            <span class="s1">self._finalizers = []</span>

    <span class="s0">def </span><span class="s1">execute(self, request: SubRequest) -&gt; _FixtureValue:</span>
        <span class="s3"># Get required arguments and register our own finish()</span>
        <span class="s3"># with their finalization.</span>
        <span class="s0">for </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">self.argnames:</span>
            <span class="s1">fixturedef = request._get_active_fixturedef(argname)</span>
            <span class="s0">if </span><span class="s1">argname != </span><span class="s2">&quot;request&quot;</span><span class="s1">:</span>
                <span class="s3"># PseudoFixtureDef is only for &quot;request&quot;.</span>
                <span class="s0">assert </span><span class="s1">isinstance(fixturedef, FixtureDef)</span>
                <span class="s1">fixturedef.addfinalizer(functools.partial(self.finish, request=request))</span>

        <span class="s1">my_cache_key = self.cache_key(request)</span>
        <span class="s0">if </span><span class="s1">self.cached_result </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># note: comparison with `==` can fail (or be expensive) for e.g.</span>
            <span class="s3"># numpy arrays (#6497).</span>
            <span class="s1">cache_key = self.cached_result[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">my_cache_key </span><span class="s0">is </span><span class="s1">cache_key:</span>
                <span class="s0">if </span><span class="s1">self.cached_result[</span><span class="s4">2</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">_, val, tb = self.cached_result[</span><span class="s4">2</span><span class="s1">]</span>
                    <span class="s0">raise </span><span class="s1">val.with_traceback(tb)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result = self.cached_result[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s0">return </span><span class="s1">result</span>
            <span class="s3"># We have a previous but differently parametrized fixture instance</span>
            <span class="s3"># so we need to tear it down before creating a new one.</span>
            <span class="s1">self.finish(request)</span>
            <span class="s0">assert </span><span class="s1">self.cached_result </span><span class="s0">is None</span>

        <span class="s1">hook = self._fixturemanager.session.gethookproxy(request.node.fspath)</span>
        <span class="s1">result = hook.pytest_fixture_setup(fixturedef=self, request=request)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">cache_key(self, request: SubRequest) -&gt; object:</span>
        <span class="s0">return </span><span class="s1">request.param_index </span><span class="s0">if not </span><span class="s1">hasattr(request, </span><span class="s2">&quot;param&quot;</span><span class="s1">) </span><span class="s0">else </span><span class="s1">request.param</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;FixtureDef argname={!r} scope={!r} baseid={!r}&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self.argname, self.scope, self.baseid</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">resolve_fixture_function(</span>
    <span class="s1">fixturedef: FixtureDef[_FixtureValue], request: FixtureRequest</span>
<span class="s1">) -&gt; </span><span class="s2">&quot;_FixtureFunc[_FixtureValue]&quot;</span><span class="s1">:</span>
    <span class="s3">&quot;&quot;&quot;Get the actual callable that can be called to obtain the fixture 
    value, dealing with unittest-specific instances and bound methods.&quot;&quot;&quot;</span>
    <span class="s1">fixturefunc = fixturedef.func</span>
    <span class="s0">if </span><span class="s1">fixturedef.unittest:</span>
        <span class="s0">if </span><span class="s1">request.instance </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># Bind the unbound method to the TestCase instance.</span>
            <span class="s1">fixturefunc = fixturedef.func.__get__(request.instance)  </span><span class="s3"># type: ignore[union-attr]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># The fixture function needs to be bound to the actual</span>
        <span class="s3"># request.instance so that code working with &quot;fixturedef&quot; behaves</span>
        <span class="s3"># as expected.</span>
        <span class="s0">if </span><span class="s1">request.instance </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># Handle the case where fixture is defined not in a test class, but some other class</span>
            <span class="s3"># (for example a plugin class with a fixture), see #2270.</span>
            <span class="s0">if </span><span class="s1">hasattr(fixturefunc, </span><span class="s2">&quot;__self__&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">isinstance(</span>
                <span class="s1">request.instance, fixturefunc.__self__.__class__  </span><span class="s3"># type: ignore[union-attr]</span>
            <span class="s1">):</span>
                <span class="s0">return </span><span class="s1">fixturefunc</span>
            <span class="s1">fixturefunc = getimfunc(fixturedef.func)</span>
            <span class="s0">if </span><span class="s1">fixturefunc != fixturedef.func:</span>
                <span class="s1">fixturefunc = fixturefunc.__get__(request.instance)  </span><span class="s3"># type: ignore[union-attr]</span>
    <span class="s0">return </span><span class="s1">fixturefunc</span>


<span class="s0">def </span><span class="s1">pytest_fixture_setup(</span>
    <span class="s1">fixturedef: FixtureDef[_FixtureValue], request: SubRequest</span>
<span class="s1">) -&gt; _FixtureValue:</span>
    <span class="s3">&quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;</span>
    <span class="s1">kwargs = {}</span>
    <span class="s0">for </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">fixturedef.argnames:</span>
        <span class="s1">fixdef = request._get_active_fixturedef(argname)</span>
        <span class="s0">assert </span><span class="s1">fixdef.cached_result </span><span class="s0">is not None</span>
        <span class="s1">result, arg_cache_key, exc = fixdef.cached_result</span>
        <span class="s1">request._check_scope(argname, request.scope, fixdef.scope)</span>
        <span class="s1">kwargs[argname] = result</span>

    <span class="s1">fixturefunc = resolve_fixture_function(fixturedef, request)</span>
    <span class="s1">my_cache_key = fixturedef.cache_key(request)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">result = call_fixture_func(fixturefunc, request, kwargs)</span>
    <span class="s0">except </span><span class="s1">TEST_OUTCOME:</span>
        <span class="s1">exc_info = sys.exc_info()</span>
        <span class="s0">assert </span><span class="s1">exc_info[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">is not None</span>
        <span class="s1">fixturedef.cached_result = (</span><span class="s0">None</span><span class="s1">, my_cache_key, exc_info)</span>
        <span class="s0">raise</span>
    <span class="s1">fixturedef.cached_result = (result, my_cache_key, </span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_ensure_immutable_ids(</span>
    <span class="s1">ids: Optional[</span>
        <span class="s1">Union[</span>
            <span class="s1">Iterable[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool]],</span>
            <span class="s1">Callable[[Any], Optional[object]],</span>
        <span class="s1">]</span>
    <span class="s1">],</span>
<span class="s1">) -&gt; Optional[</span>
    <span class="s1">Union[</span>
        <span class="s1">Tuple[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool], ...],</span>
        <span class="s1">Callable[[Any], Optional[object]],</span>
    <span class="s1">]</span>
<span class="s1">]:</span>
    <span class="s0">if </span><span class="s1">ids </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return None</span>
    <span class="s0">if </span><span class="s1">callable(ids):</span>
        <span class="s0">return </span><span class="s1">ids</span>
    <span class="s0">return </span><span class="s1">tuple(ids)</span>


<span class="s0">def </span><span class="s1">_params_converter(</span>
    <span class="s1">params: Optional[Iterable[object]],</span>
<span class="s1">) -&gt; Optional[Tuple[object, ...]]:</span>
    <span class="s0">return </span><span class="s1">tuple(params) </span><span class="s0">if </span><span class="s1">params </span><span class="s0">is not None else None</span>


<span class="s0">def </span><span class="s1">wrap_function_to_error_out_if_called_directly(</span>
    <span class="s1">function: _FixtureFunction, fixture_marker: </span><span class="s2">&quot;FixtureFunctionMarker&quot;</span><span class="s1">,</span>
<span class="s1">) -&gt; _FixtureFunction:</span>
    <span class="s3">&quot;&quot;&quot;Wrap the given fixture function so we can raise an error about it being called directly, 
    instead of used as an argument in a test function.&quot;&quot;&quot;</span>
    <span class="s1">message = (</span>
        <span class="s2">'Fixture &quot;{name}&quot; called directly. Fixtures are not meant to be called directly,</span><span class="s5">\n</span><span class="s2">'</span>
        <span class="s2">&quot;but are created automatically when test functions request them as parameters.</span><span class="s5">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;See https://docs.pytest.org/en/stable/fixture.html for more information about fixtures, and</span><span class="s5">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;https://docs.pytest.org/en/stable/deprecations.html#calling-fixtures-directly about how to update your code.&quot;</span>
    <span class="s1">).format(name=fixture_marker.name </span><span class="s0">or </span><span class="s1">function.__name__)</span>

    <span class="s1">@functools.wraps(function)</span>
    <span class="s0">def </span><span class="s1">result(*args, **kwargs):</span>
        <span class="s1">fail(message, pytrace=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s3"># Keep reference to the original function in our own custom attribute so we don't unwrap</span>
    <span class="s3"># further than this point and lose useful wrappings like @mock.patch (#3774).</span>
    <span class="s1">result.__pytest_wrapped__ = _PytestWrapper(function)  </span><span class="s3"># type: ignore[attr-defined]</span>

    <span class="s0">return </span><span class="s1">cast(_FixtureFunction, result)</span>


<span class="s1">@final</span>
<span class="s1">@attr.s(frozen=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">FixtureFunctionMarker:</span>
    <span class="s1">scope = attr.ib(type=</span><span class="s2">&quot;Union[_Scope, Callable[[str, Config], _Scope]]&quot;</span><span class="s1">)</span>
    <span class="s1">params = attr.ib(type=Optional[Tuple[object, ...]], converter=_params_converter)</span>
    <span class="s1">autouse = attr.ib(type=bool, default=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">ids = attr.ib(</span>
        <span class="s1">type=Union[</span>
            <span class="s1">Tuple[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool], ...],</span>
            <span class="s1">Callable[[Any], Optional[object]],</span>
        <span class="s1">],</span>
        <span class="s1">default=</span><span class="s0">None</span><span class="s1">,</span>
        <span class="s1">converter=_ensure_immutable_ids,</span>
    <span class="s1">)</span>
    <span class="s1">name = attr.ib(type=Optional[str], default=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self, function: _FixtureFunction) -&gt; _FixtureFunction:</span>
        <span class="s0">if </span><span class="s1">inspect.isclass(function):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;class fixtures not supported (maybe in the future)&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">getattr(function, </span><span class="s2">&quot;_pytestfixturefunction&quot;</span><span class="s1">, </span><span class="s0">False</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;fixture is being applied more than once to the same function&quot;</span>
            <span class="s1">)</span>

        <span class="s1">function = wrap_function_to_error_out_if_called_directly(function, self)</span>

        <span class="s1">name = self.name </span><span class="s0">or </span><span class="s1">function.__name__</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s2">&quot;request&quot;</span><span class="s1">:</span>
            <span class="s1">location = getlocation(function)</span>
            <span class="s1">fail(</span>
                <span class="s2">&quot;'request' is a reserved word for fixtures, use another name:</span><span class="s5">\n  </span><span class="s2">{}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">location</span>
                <span class="s1">),</span>
                <span class="s1">pytrace=</span><span class="s0">False</span><span class="s1">,</span>
            <span class="s1">)</span>

        <span class="s3"># Type ignored because https://github.com/python/mypy/issues/2087.</span>
        <span class="s1">function._pytestfixturefunction = self  </span><span class="s3"># type: ignore[attr-defined]</span>
        <span class="s0">return </span><span class="s1">function</span>


<span class="s1">@overload</span>
<span class="s0">def </span><span class="s1">fixture(</span>
    <span class="s1">fixture_function: _FixtureFunction,</span>
    <span class="s1">*,</span>
    <span class="s1">scope: </span><span class="s2">&quot;Union[_Scope, Callable[[str, Config], _Scope]]&quot; </span><span class="s1">= ...,</span>
    <span class="s1">params: Optional[Iterable[object]] = ...,</span>
    <span class="s1">autouse: bool = ...,</span>
    <span class="s1">ids: Optional[</span>
        <span class="s1">Union[</span>
            <span class="s1">Iterable[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool]],</span>
            <span class="s1">Callable[[Any], Optional[object]],</span>
        <span class="s1">]</span>
    <span class="s1">] = ...,</span>
    <span class="s1">name: Optional[str] = ...,</span>
<span class="s1">) -&gt; _FixtureFunction:</span>
    <span class="s1">...</span>


<span class="s1">@overload</span>
<span class="s0">def </span><span class="s1">fixture(</span>
    <span class="s1">fixture_function: </span><span class="s0">None </span><span class="s1">= ...,</span>
    <span class="s1">*,</span>
    <span class="s1">scope: </span><span class="s2">&quot;Union[_Scope, Callable[[str, Config], _Scope]]&quot; </span><span class="s1">= ...,</span>
    <span class="s1">params: Optional[Iterable[object]] = ...,</span>
    <span class="s1">autouse: bool = ...,</span>
    <span class="s1">ids: Optional[</span>
        <span class="s1">Union[</span>
            <span class="s1">Iterable[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool]],</span>
            <span class="s1">Callable[[Any], Optional[object]],</span>
        <span class="s1">]</span>
    <span class="s1">] = ...,</span>
    <span class="s1">name: Optional[str] = </span><span class="s0">None</span><span class="s1">,</span>
<span class="s1">) -&gt; FixtureFunctionMarker:</span>
    <span class="s1">...</span>


<span class="s0">def </span><span class="s1">fixture(</span>
    <span class="s1">fixture_function: Optional[_FixtureFunction] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">*,</span>
    <span class="s1">scope: </span><span class="s2">&quot;Union[_Scope, Callable[[str, Config], _Scope]]&quot; </span><span class="s1">= </span><span class="s2">&quot;function&quot;</span><span class="s1">,</span>
    <span class="s1">params: Optional[Iterable[object]] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">autouse: bool = </span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">ids: Optional[</span>
        <span class="s1">Union[</span>
            <span class="s1">Iterable[Union[</span><span class="s0">None</span><span class="s1">, str, float, int, bool]],</span>
            <span class="s1">Callable[[Any], Optional[object]],</span>
        <span class="s1">]</span>
    <span class="s1">] = </span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">name: Optional[str] = </span><span class="s0">None</span><span class="s1">,</span>
<span class="s1">) -&gt; Union[FixtureFunctionMarker, _FixtureFunction]:</span>
    <span class="s3">&quot;&quot;&quot;Decorator to mark a fixture factory function. 
 
    This decorator can be used, with or without parameters, to define a 
    fixture function. 
 
    The name of the fixture function can later be referenced to cause its 
    invocation ahead of running tests: test modules or classes can use the 
    ``pytest.mark.usefixtures(fixturename)`` marker. 
 
    Test functions can directly use fixture names as input arguments in which 
    case the fixture instance returned from the fixture function will be 
    injected. 
 
    Fixtures can provide their values to test functions using ``return`` or 
    ``yield`` statements. When using ``yield`` the code block after the 
    ``yield`` statement is executed as teardown code regardless of the test 
    outcome, and must yield exactly once. 
 
    :param scope: 
        The scope for which this fixture is shared; one of ``&quot;function&quot;`` 
        (default), ``&quot;class&quot;``, ``&quot;module&quot;``, ``&quot;package&quot;`` or ``&quot;session&quot;``. 
 
        This parameter may also be a callable which receives ``(fixture_name, config)`` 
        as parameters, and must return a ``str`` with one of the values mentioned above. 
 
        See :ref:`dynamic scope` in the docs for more information. 
 
    :param params: 
        An optional list of parameters which will cause multiple invocations 
        of the fixture function and all of the tests using it. The current 
        parameter is available in ``request.param``. 
 
    :param autouse: 
        If True, the fixture func is activated for all tests that can see it. 
        If False (the default), an explicit reference is needed to activate 
        the fixture. 
 
    :param ids: 
        List of string ids each corresponding to the params so that they are 
        part of the test id. If no ids are provided they will be generated 
        automatically from the params. 
 
    :param name: 
        The name of the fixture. This defaults to the name of the decorated 
        function. If a fixture is used in the same module in which it is 
        defined, the function name of the fixture will be shadowed by the 
        function arg that requests the fixture; one way to resolve this is to 
        name the decorated function ``fixture_&lt;fixturename&gt;`` and then use 
        ``@pytest.fixture(name='&lt;fixturename&gt;')``. 
    &quot;&quot;&quot;</span>
    <span class="s1">fixture_marker = FixtureFunctionMarker(</span>
        <span class="s1">scope=scope, params=params, autouse=autouse, ids=ids, name=name,</span>
    <span class="s1">)</span>

    <span class="s3"># Direct decoration.</span>
    <span class="s0">if </span><span class="s1">fixture_function:</span>
        <span class="s0">return </span><span class="s1">fixture_marker(fixture_function)</span>

    <span class="s0">return </span><span class="s1">fixture_marker</span>


<span class="s0">def </span><span class="s1">yield_fixture(</span>
    <span class="s1">fixture_function=</span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">*args,</span>
    <span class="s1">scope=</span><span class="s2">&quot;function&quot;</span><span class="s1">,</span>
    <span class="s1">params=</span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">autouse=</span><span class="s0">False</span><span class="s1">,</span>
    <span class="s1">ids=</span><span class="s0">None</span><span class="s1">,</span>
    <span class="s1">name=</span><span class="s0">None</span><span class="s1">,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot;(Return a) decorator to mark a yield-fixture factory function. 
 
    .. deprecated:: 3.0 
        Use :py:func:`pytest.fixture` directly instead. 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(YIELD_FIXTURE, stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">fixture(</span>
        <span class="s1">fixture_function,</span>
        <span class="s1">*args,</span>
        <span class="s1">scope=scope,</span>
        <span class="s1">params=params,</span>
        <span class="s1">autouse=autouse,</span>
        <span class="s1">ids=ids,</span>
        <span class="s1">name=name,</span>
    <span class="s1">)</span>


<span class="s1">@fixture(scope=</span><span class="s2">&quot;session&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">pytestconfig(request: FixtureRequest) -&gt; Config:</span>
    <span class="s3">&quot;&quot;&quot;Session-scoped fixture that returns the :class:`_pytest.config.Config` object. 
 
    Example:: 
 
        def test_foo(pytestconfig): 
            if pytestconfig.getoption(&quot;verbose&quot;) &gt; 0: 
                ... 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">request.config</span>


<span class="s0">def </span><span class="s1">pytest_addoption(parser: Parser) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s1">parser.addini(</span>
        <span class="s2">&quot;usefixtures&quot;</span><span class="s1">,</span>
        <span class="s1">type=</span><span class="s2">&quot;args&quot;</span><span class="s1">,</span>
        <span class="s1">default=[],</span>
        <span class="s1">help=</span><span class="s2">&quot;list of default fixtures to be used with this project&quot;</span><span class="s1">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">FixtureManager:</span>
    <span class="s3">&quot;&quot;&quot;pytest fixture definitions and information is stored and managed 
    from this class. 
 
    During collection fm.parsefactories() is called multiple times to parse 
    fixture function definitions into FixtureDef objects and internal 
    data structures. 
 
    During collection of test functions, metafunc-mechanics instantiate 
    a FuncFixtureInfo object which is cached per node/func-name. 
    This FuncFixtureInfo object is later retrieved by Function nodes 
    which themselves offer a fixturenames attribute. 
 
    The FuncFixtureInfo object holds information about fixtures and FixtureDefs 
    relevant for a particular function. An initial list of fixtures is 
    assembled like this: 
 
    - ini-defined usefixtures 
    - autouse-marked fixtures along the collection chain up from the function 
    - usefixtures markers at module/class/function level 
    - test function funcargs 
 
    Subsequently the funcfixtureinfo.fixturenames attribute is computed 
    as the closure of the fixtures needed to setup the initial fixtures, 
    i.e. fixtures needed by fixture functions themselves are appended 
    to the fixturenames list. 
 
    Upon the test-setup phases all fixturenames are instantiated, retrieved 
    by a lookup of their FuncFixtureInfo. 
    &quot;&quot;&quot;</span>

    <span class="s1">FixtureLookupError = FixtureLookupError</span>
    <span class="s1">FixtureLookupErrorRepr = FixtureLookupErrorRepr</span>

    <span class="s0">def </span><span class="s1">__init__(self, session: </span><span class="s2">&quot;Session&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.session = session</span>
        <span class="s1">self.config: Config = session.config</span>
        <span class="s1">self._arg2fixturedefs: Dict[str, List[FixtureDef[Any]]] = {}</span>
        <span class="s1">self._holderobjseen: Set[object] = set()</span>
        <span class="s3"># A mapping from a nodeid to a list of autouse fixtures it defines.</span>
        <span class="s1">self._nodeid_autousenames: Dict[str, List[str]] = {</span>
            <span class="s2">&quot;&quot;</span><span class="s1">: self.config.getini(</span><span class="s2">&quot;usefixtures&quot;</span><span class="s1">),</span>
        <span class="s1">}</span>
        <span class="s1">session.config.pluginmanager.register(self, </span><span class="s2">&quot;funcmanage&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_direct_parametrize_args(self, node: nodes.Node) -&gt; List[str]:</span>
        <span class="s3">&quot;&quot;&quot;Return all direct parametrization arguments of a node, so we don't 
        mistake them for fixtures. 
 
        Check https://github.com/pytest-dev/pytest/issues/5036. 
 
        These things are done later as well when dealing with parametrization 
        so this could be improved. 
        &quot;&quot;&quot;</span>
        <span class="s1">parametrize_argnames: List[str] = []</span>
        <span class="s0">for </span><span class="s1">marker </span><span class="s0">in </span><span class="s1">node.iter_markers(name=</span><span class="s2">&quot;parametrize&quot;</span><span class="s1">):</span>
            <span class="s0">if not </span><span class="s1">marker.kwargs.get(</span><span class="s2">&quot;indirect&quot;</span><span class="s1">, </span><span class="s0">False</span><span class="s1">):</span>
                <span class="s1">p_argnames, _ = ParameterSet._parse_parametrize_args(</span>
                    <span class="s1">*marker.args, **marker.kwargs</span>
                <span class="s1">)</span>
                <span class="s1">parametrize_argnames.extend(p_argnames)</span>

        <span class="s0">return </span><span class="s1">parametrize_argnames</span>

    <span class="s0">def </span><span class="s1">getfixtureinfo(</span>
        <span class="s1">self, node: nodes.Node, func, cls, funcargs: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; FuncFixtureInfo:</span>
        <span class="s0">if </span><span class="s1">funcargs </span><span class="s0">and not </span><span class="s1">getattr(node, </span><span class="s2">&quot;nofuncargs&quot;</span><span class="s1">, </span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">argnames = getfuncargnames(func, name=node.name, cls=cls)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">argnames = ()</span>

        <span class="s1">usefixtures = tuple(</span>
            <span class="s1">arg </span><span class="s0">for </span><span class="s1">mark </span><span class="s0">in </span><span class="s1">node.iter_markers(name=</span><span class="s2">&quot;usefixtures&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">mark.args</span>
        <span class="s1">)</span>
        <span class="s1">initialnames = usefixtures + argnames</span>
        <span class="s1">fm = node.session._fixturemanager</span>
        <span class="s1">initialnames, names_closure, arg2fixturedefs = fm.getfixtureclosure(</span>
            <span class="s1">initialnames, node, ignore_args=self._get_direct_parametrize_args(node)</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">FuncFixtureInfo(argnames, initialnames, names_closure, arg2fixturedefs)</span>

    <span class="s0">def </span><span class="s1">pytest_plugin_registered(self, plugin: _PluggyPlugin) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">nodeid = </span><span class="s0">None</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">p = absolutepath(plugin.__file__)  </span><span class="s3"># type: ignore[attr-defined]</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Construct the base nodeid which is later used to check</span>
            <span class="s3"># what fixtures are visible for particular tests (as denoted</span>
            <span class="s3"># by their test id).</span>
            <span class="s0">if </span><span class="s1">p.name.startswith(</span><span class="s2">&quot;conftest.py&quot;</span><span class="s1">):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">nodeid = str(p.parent.relative_to(self.config.rootpath))</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s1">nodeid = </span><span class="s2">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">nodeid == </span><span class="s2">&quot;.&quot;</span><span class="s1">:</span>
                    <span class="s1">nodeid = </span><span class="s2">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">os.sep != nodes.SEP:</span>
                    <span class="s1">nodeid = nodeid.replace(os.sep, nodes.SEP)</span>

        <span class="s1">self.parsefactories(plugin, nodeid)</span>

    <span class="s0">def </span><span class="s1">_getautousenames(self, nodeid: str) -&gt; Iterator[str]:</span>
        <span class="s3">&quot;&quot;&quot;Return the names of autouse fixtures applicable to nodeid.&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">parentnodeid </span><span class="s0">in </span><span class="s1">nodes.iterparentnodeids(nodeid):</span>
            <span class="s1">basenames = self._nodeid_autousenames.get(parentnodeid)</span>
            <span class="s0">if </span><span class="s1">basenames:</span>
                <span class="s0">yield from </span><span class="s1">basenames</span>

    <span class="s0">def </span><span class="s1">getfixtureclosure(</span>
        <span class="s1">self,</span>
        <span class="s1">fixturenames: Tuple[str, ...],</span>
        <span class="s1">parentnode: nodes.Node,</span>
        <span class="s1">ignore_args: Sequence[str] = (),</span>
    <span class="s1">) -&gt; Tuple[Tuple[str, ...], List[str], Dict[str, Sequence[FixtureDef[Any]]]]:</span>
        <span class="s3"># Collect the closure of all fixtures, starting with the given</span>
        <span class="s3"># fixturenames as the initial set.  As we have to visit all</span>
        <span class="s3"># factory definitions anyway, we also return an arg2fixturedefs</span>
        <span class="s3"># mapping so that the caller can reuse it and does not have</span>
        <span class="s3"># to re-discover fixturedefs again for each fixturename</span>
        <span class="s3"># (discovering matching fixtures for a given name/node is expensive).</span>

        <span class="s1">parentid = parentnode.nodeid</span>
        <span class="s1">fixturenames_closure = list(self._getautousenames(parentid))</span>

        <span class="s0">def </span><span class="s1">merge(otherlist: Iterable[str]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">otherlist:</span>
                <span class="s0">if </span><span class="s1">arg </span><span class="s0">not in </span><span class="s1">fixturenames_closure:</span>
                    <span class="s1">fixturenames_closure.append(arg)</span>

        <span class="s1">merge(fixturenames)</span>

        <span class="s3"># At this point, fixturenames_closure contains what we call &quot;initialnames&quot;,</span>
        <span class="s3"># which is a set of fixturenames the function immediately requests. We</span>
        <span class="s3"># need to return it as well, so save this.</span>
        <span class="s1">initialnames = tuple(fixturenames_closure)</span>

        <span class="s1">arg2fixturedefs: Dict[str, Sequence[FixtureDef[Any]]] = {}</span>
        <span class="s1">lastlen = -</span><span class="s4">1</span>
        <span class="s0">while </span><span class="s1">lastlen != len(fixturenames_closure):</span>
            <span class="s1">lastlen = len(fixturenames_closure)</span>
            <span class="s0">for </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">fixturenames_closure:</span>
                <span class="s0">if </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">ignore_args:</span>
                    <span class="s0">continue</span>
                <span class="s0">if </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">arg2fixturedefs:</span>
                    <span class="s0">continue</span>
                <span class="s1">fixturedefs = self.getfixturedefs(argname, parentid)</span>
                <span class="s0">if </span><span class="s1">fixturedefs:</span>
                    <span class="s1">arg2fixturedefs[argname] = fixturedefs</span>
                    <span class="s1">merge(fixturedefs[-</span><span class="s4">1</span><span class="s1">].argnames)</span>

        <span class="s0">def </span><span class="s1">sort_by_scope(arg_name: str) -&gt; int:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">fixturedefs = arg2fixturedefs[arg_name]</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">return </span><span class="s1">scopes.index(</span><span class="s2">&quot;function&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">fixturedefs[-</span><span class="s4">1</span><span class="s1">].scopenum</span>

        <span class="s1">fixturenames_closure.sort(key=sort_by_scope)</span>
        <span class="s0">return </span><span class="s1">initialnames, fixturenames_closure, arg2fixturedefs</span>

    <span class="s0">def </span><span class="s1">pytest_generate_tests(self, metafunc: </span><span class="s2">&quot;Metafunc&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3">&quot;&quot;&quot;Generate new tests based on parametrized fixtures used by the given metafunc&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">get_parametrize_mark_argnames(mark: Mark) -&gt; Sequence[str]:</span>
            <span class="s1">args, _ = ParameterSet._parse_parametrize_args(*mark.args, **mark.kwargs)</span>
            <span class="s0">return </span><span class="s1">args</span>

        <span class="s0">for </span><span class="s1">argname </span><span class="s0">in </span><span class="s1">metafunc.fixturenames:</span>
            <span class="s3"># Get the FixtureDefs for the argname.</span>
            <span class="s1">fixture_defs = metafunc._arg2fixturedefs.get(argname)</span>
            <span class="s0">if not </span><span class="s1">fixture_defs:</span>
                <span class="s3"># Will raise FixtureLookupError at setup time if not parametrized somewhere</span>
                <span class="s3"># else (e.g @pytest.mark.parametrize)</span>
                <span class="s0">continue</span>

            <span class="s3"># If the test itself parametrizes using this argname, give it</span>
            <span class="s3"># precedence.</span>
            <span class="s0">if </span><span class="s1">any(</span>
                <span class="s1">argname </span><span class="s0">in </span><span class="s1">get_parametrize_mark_argnames(mark)</span>
                <span class="s0">for </span><span class="s1">mark </span><span class="s0">in </span><span class="s1">metafunc.definition.iter_markers(</span><span class="s2">&quot;parametrize&quot;</span><span class="s1">)</span>
            <span class="s1">):</span>
                <span class="s0">continue</span>

            <span class="s3"># In the common case we only look at the fixture def with the</span>
            <span class="s3"># closest scope (last in the list). But if the fixture overrides</span>
            <span class="s3"># another fixture, while requesting the super fixture, keep going</span>
            <span class="s3"># in case the super fixture is parametrized (#1953).</span>
            <span class="s0">for </span><span class="s1">fixturedef </span><span class="s0">in </span><span class="s1">reversed(fixture_defs):</span>
                <span class="s3"># Fixture is parametrized, apply it and stop.</span>
                <span class="s0">if </span><span class="s1">fixturedef.params </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">metafunc.parametrize(</span>
                        <span class="s1">argname,</span>
                        <span class="s1">fixturedef.params,</span>
                        <span class="s1">indirect=</span><span class="s0">True</span><span class="s1">,</span>
                        <span class="s1">scope=fixturedef.scope,</span>
                        <span class="s1">ids=fixturedef.ids,</span>
                    <span class="s1">)</span>
                    <span class="s0">break</span>

                <span class="s3"># Not requesting the overridden super fixture, stop.</span>
                <span class="s0">if </span><span class="s1">argname </span><span class="s0">not in </span><span class="s1">fixturedef.argnames:</span>
                    <span class="s0">break</span>

                <span class="s3"># Try next super fixture, if any.</span>

    <span class="s0">def </span><span class="s1">pytest_collection_modifyitems(self, items: List[nodes.Item]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># Separate parametrized setups.</span>
        <span class="s1">items[:] = reorder_items(items)</span>

    <span class="s0">def </span><span class="s1">parsefactories(</span>
        <span class="s1">self, node_or_obj, nodeid=NOTSET, unittest: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">is not </span><span class="s1">NOTSET:</span>
            <span class="s1">holderobj = node_or_obj</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">holderobj = node_or_obj.obj</span>
            <span class="s1">nodeid = node_or_obj.nodeid</span>
        <span class="s0">if </span><span class="s1">holderobj </span><span class="s0">in </span><span class="s1">self._holderobjseen:</span>
            <span class="s0">return</span>

        <span class="s1">self._holderobjseen.add(holderobj)</span>
        <span class="s1">autousenames = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(holderobj):</span>
            <span class="s3"># The attribute can be an arbitrary descriptor, so the attribute</span>
            <span class="s3"># access below can raise. safe_getatt() ignores such exceptions.</span>
            <span class="s1">obj = safe_getattr(holderobj, name, </span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">marker = getfixturemarker(obj)</span>
            <span class="s0">if not </span><span class="s1">isinstance(marker, FixtureFunctionMarker):</span>
                <span class="s3"># Magic globals  with __getattr__ might have got us a wrong</span>
                <span class="s3"># fixture attribute.</span>
                <span class="s0">continue</span>

            <span class="s0">if </span><span class="s1">marker.name:</span>
                <span class="s1">name = marker.name</span>

            <span class="s3"># During fixture definition we wrap the original fixture function</span>
            <span class="s3"># to issue a warning if called directly, so here we unwrap it in</span>
            <span class="s3"># order to not emit the warning when pytest itself calls the</span>
            <span class="s3"># fixture function.</span>
            <span class="s1">obj = get_real_method(obj, holderobj)</span>

            <span class="s1">fixture_def = FixtureDef(</span>
                <span class="s1">fixturemanager=self,</span>
                <span class="s1">baseid=nodeid,</span>
                <span class="s1">argname=name,</span>
                <span class="s1">func=obj,</span>
                <span class="s1">scope=marker.scope,</span>
                <span class="s1">params=marker.params,</span>
                <span class="s1">unittest=unittest,</span>
                <span class="s1">ids=marker.ids,</span>
            <span class="s1">)</span>

            <span class="s1">faclist = self._arg2fixturedefs.setdefault(name, [])</span>
            <span class="s0">if </span><span class="s1">fixture_def.has_location:</span>
                <span class="s1">faclist.append(fixture_def)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># fixturedefs with no location are at the front</span>
                <span class="s3"># so this inserts the current fixturedef after the</span>
                <span class="s3"># existing fixturedefs from external plugins but</span>
                <span class="s3"># before the fixturedefs provided in conftests.</span>
                <span class="s1">i = len([f </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">faclist </span><span class="s0">if not </span><span class="s1">f.has_location])</span>
                <span class="s1">faclist.insert(i, fixture_def)</span>
            <span class="s0">if </span><span class="s1">marker.autouse:</span>
                <span class="s1">autousenames.append(name)</span>

        <span class="s0">if </span><span class="s1">autousenames:</span>
            <span class="s1">self._nodeid_autousenames.setdefault(nodeid </span><span class="s0">or </span><span class="s2">&quot;&quot;</span><span class="s1">, []).extend(autousenames)</span>

    <span class="s0">def </span><span class="s1">getfixturedefs(</span>
        <span class="s1">self, argname: str, nodeid: str</span>
    <span class="s1">) -&gt; Optional[Sequence[FixtureDef[Any]]]:</span>
        <span class="s3">&quot;&quot;&quot;Get a list of fixtures which are applicable to the given node id. 
 
        :param str argname: Name of the fixture to search for. 
        :param str nodeid: Full node id of the requesting test. 
        :rtype: Sequence[FixtureDef] 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">fixturedefs = self._arg2fixturedefs[argname]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">return None</span>
        <span class="s0">return </span><span class="s1">tuple(self._matchfactories(fixturedefs, nodeid))</span>

    <span class="s0">def </span><span class="s1">_matchfactories(</span>
        <span class="s1">self, fixturedefs: Iterable[FixtureDef[Any]], nodeid: str</span>
    <span class="s1">) -&gt; Iterator[FixtureDef[Any]]:</span>
        <span class="s1">parentnodeids = set(nodes.iterparentnodeids(nodeid))</span>
        <span class="s0">for </span><span class="s1">fixturedef </span><span class="s0">in </span><span class="s1">fixturedefs:</span>
            <span class="s0">if </span><span class="s1">fixturedef.baseid </span><span class="s0">in </span><span class="s1">parentnodeids:</span>
                <span class="s0">yield </span><span class="s1">fixturedef</span>
</pre>
</body>
</html>