<html>
<head>
<title>_check_docs_utils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_check_docs_utils.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2016 Yuri Bochkarev &lt;baltazar.bz@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;</span>
<span class="s0"># Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;</span>
<span class="s0"># Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 Mitar &lt;mitar.github@tnode.com&gt;</span>
<span class="s0"># Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;</span>
<span class="s0"># Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Mitchell T.H. Young &lt;mitchelly@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Adrian Chirieac &lt;chirieacam@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Danny Hermes &lt;daniel.j.hermes@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Zeb Nicholls &lt;zebedee.nicholls@climate-energy-college.org&gt;</span>
<span class="s0"># Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>

<span class="s0"># Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html</span>
<span class="s0"># For details: https://github.com/PyCQA/pylint/blob/master/LICENSE</span>

<span class="s0">&quot;&quot;&quot;Utility methods for docstring checking.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>

<span class="s2">import </span><span class="s1">astroid</span>

<span class="s2">from </span><span class="s1">pylint.checkers </span><span class="s2">import </span><span class="s1">utils</span>


<span class="s2">def </span><span class="s1">space_indentation(s):</span>
    <span class="s0">&quot;&quot;&quot;The number of leading spaces in a string 
 
    :param str s: input string 
 
    :rtype: int 
    :return: number of leading spaces 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">len(s) - len(s.lstrip(</span><span class="s3">&quot; &quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">get_setters_property_name(node):</span>
    <span class="s0">&quot;&quot;&quot;Get the name of the property that the given node is a setter for. 
 
    :param node: The node to get the property name for. 
    :type node: str 
 
    :rtype: str or None 
    :returns: The name of the property that the node is a setter for, 
        or None if one could not be found. 
    &quot;&quot;&quot;</span>
    <span class="s1">decorators = node.decorators.nodes </span><span class="s2">if </span><span class="s1">node.decorators </span><span class="s2">else </span><span class="s1">[]</span>
    <span class="s2">for </span><span class="s1">decorator </span><span class="s2">in </span><span class="s1">decorators:</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(decorator, astroid.Attribute)</span>
            <span class="s2">and </span><span class="s1">decorator.attrname == </span><span class="s3">&quot;setter&quot;</span>
            <span class="s2">and </span><span class="s1">isinstance(decorator.expr, astroid.Name)</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">decorator.expr.name</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">get_setters_property(node):</span>
    <span class="s0">&quot;&quot;&quot;Get the property node for the given setter node. 
 
    :param node: The node to get the property for. 
    :type node: astroid.FunctionDef 
 
    :rtype: astroid.FunctionDef or None 
    :returns: The node relating to the property of the given setter node, 
        or None if one could not be found. 
    &quot;&quot;&quot;</span>
    <span class="s1">property_ = </span><span class="s2">None</span>

    <span class="s1">property_name = get_setters_property_name(node)</span>
    <span class="s1">class_node = utils.node_frame_class(node)</span>
    <span class="s2">if </span><span class="s1">property_name </span><span class="s2">and </span><span class="s1">class_node:</span>
        <span class="s1">class_attrs = class_node.getattr(node.name)</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">class_attrs:</span>
            <span class="s2">if </span><span class="s1">utils.decorated_with_property(attr):</span>
                <span class="s1">property_ = attr</span>
                <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">property_</span>


<span class="s2">def </span><span class="s1">returns_something(return_node):</span>
    <span class="s0">&quot;&quot;&quot;Check if a return node returns a value other than None. 
 
    :param return_node: The return node to check. 
    :type return_node: astroid.Return 
 
    :rtype: bool 
    :return: True if the return node returns a value other than None, 
        False otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">returns = return_node.value</span>

    <span class="s2">if </span><span class="s1">returns </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return False</span>

    <span class="s2">return not </span><span class="s1">(isinstance(returns, astroid.Const) </span><span class="s2">and </span><span class="s1">returns.value </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_get_raise_target(node):</span>
    <span class="s2">if </span><span class="s1">isinstance(node.exc, astroid.Call):</span>
        <span class="s1">func = node.exc.func</span>
        <span class="s2">if </span><span class="s1">isinstance(func, (astroid.Name, astroid.Attribute)):</span>
            <span class="s2">return </span><span class="s1">utils.safe_infer(func)</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_split_multiple_exc_types(target: str) -&gt; List[str]:</span>
    <span class="s1">delimiters = </span><span class="s3">r&quot;(\s*,(?:\s*or\s)?\s*|\s+or\s+)&quot;</span>
    <span class="s2">return </span><span class="s1">re.split(delimiters, target)</span>


<span class="s2">def </span><span class="s1">possible_exc_types(node):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gets all of the possible raised exception types for the given raise node. 
 
    .. note:: 
 
        Caught exception types are ignored. 
 
 
    :param node: The raise node to find exception types for. 
    :type node: astroid.node_classes.NodeNG 
 
    :returns: A list of exception types possibly raised by :param:`node`. 
    :rtype: set(str) 
    &quot;&quot;&quot;</span>
    <span class="s1">excs = []</span>
    <span class="s2">if </span><span class="s1">isinstance(node.exc, astroid.Name):</span>
        <span class="s1">inferred = utils.safe_infer(node.exc)</span>
        <span class="s2">if </span><span class="s1">inferred:</span>
            <span class="s1">excs = [inferred.name]</span>
    <span class="s2">elif </span><span class="s1">node.exc </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">handler = node.parent</span>
        <span class="s2">while </span><span class="s1">handler </span><span class="s2">and not </span><span class="s1">isinstance(handler, astroid.ExceptHandler):</span>
            <span class="s1">handler = handler.parent</span>

        <span class="s2">if </span><span class="s1">handler </span><span class="s2">and </span><span class="s1">handler.type:</span>
            <span class="s1">inferred_excs = astroid.unpack_infer(handler.type)</span>
            <span class="s1">excs = (exc.name </span><span class="s2">for </span><span class="s1">exc </span><span class="s2">in </span><span class="s1">inferred_excs </span><span class="s2">if </span><span class="s1">exc </span><span class="s2">is not </span><span class="s1">astroid.Uninferable)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">target = _get_raise_target(node)</span>
        <span class="s2">if </span><span class="s1">isinstance(target, astroid.ClassDef):</span>
            <span class="s1">excs = [target.name]</span>
        <span class="s2">elif </span><span class="s1">isinstance(target, astroid.FunctionDef):</span>
            <span class="s2">for </span><span class="s1">ret </span><span class="s2">in </span><span class="s1">target.nodes_of_class(astroid.Return):</span>
                <span class="s2">if </span><span class="s1">ret.frame() != target:</span>
                    <span class="s0"># return from inner function - ignore it</span>
                    <span class="s2">continue</span>

                <span class="s1">val = utils.safe_infer(ret.value)</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">val</span>
                    <span class="s2">and </span><span class="s1">isinstance(val, (astroid.Instance, astroid.ClassDef))</span>
                    <span class="s2">and </span><span class="s1">utils.inherit_from_std_ex(val)</span>
                <span class="s1">):</span>
                    <span class="s1">excs.append(val.name)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">{exc </span><span class="s2">for </span><span class="s1">exc </span><span class="s2">in </span><span class="s1">excs </span><span class="s2">if not </span><span class="s1">utils.node_ignores_exception(node, exc)}</span>
    <span class="s2">except </span><span class="s1">astroid.InferenceError:</span>
        <span class="s2">return </span><span class="s1">set()</span>


<span class="s2">def </span><span class="s1">docstringify(docstring, default_type=</span><span class="s3">&quot;default&quot;</span><span class="s1">):</span>
    <span class="s2">for </span><span class="s1">docstring_type </span><span class="s2">in </span><span class="s1">[</span>
        <span class="s1">SphinxDocstring,</span>
        <span class="s1">EpytextDocstring,</span>
        <span class="s1">GoogleDocstring,</span>
        <span class="s1">NumpyDocstring,</span>
    <span class="s1">]:</span>
        <span class="s1">instance = docstring_type(docstring)</span>
        <span class="s2">if </span><span class="s1">instance.is_valid():</span>
            <span class="s2">return </span><span class="s1">instance</span>

    <span class="s1">docstring_type = DOCSTRING_TYPES.get(default_type, Docstring)</span>
    <span class="s2">return </span><span class="s1">docstring_type(docstring)</span>


<span class="s2">class </span><span class="s1">Docstring:</span>
    <span class="s1">re_for_parameters_see = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        For\s+the\s+(other)?\s*parameters\s*,\s+see 
        &quot;&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">re.X | re.S,</span>
    <span class="s1">)</span>

    <span class="s1">supports_yields: bool = </span><span class="s2">False</span>
    <span class="s3">&quot;&quot;&quot;True if the docstring supports a &quot;yield&quot; section. 
 
    False if the docstring uses the returns section to document generators. 
    &quot;&quot;&quot;</span>

    <span class="s0"># These methods are designed to be overridden</span>
    <span class="s0"># pylint: disable=no-self-use</span>
    <span class="s2">def </span><span class="s1">__init__(self, doc):</span>
        <span class="s1">doc = doc </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.doc = doc.expandtabs()</span>

    <span class="s2">def </span><span class="s1">is_valid(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">exceptions(self):</span>
        <span class="s2">return </span><span class="s1">set()</span>

    <span class="s2">def </span><span class="s1">has_params(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_returns(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_rtype(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_property_returns(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_property_type(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_yields(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_yields_type(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">match_param_docs(self):</span>
        <span class="s2">return </span><span class="s1">set(), set()</span>

    <span class="s2">def </span><span class="s1">params_documented_elsewhere(self):</span>
        <span class="s2">return </span><span class="s1">self.re_for_parameters_see.search(self.doc) </span><span class="s2">is not None</span>


<span class="s2">class </span><span class="s1">SphinxDocstring(Docstring):</span>
    <span class="s1">re_type = </span><span class="s3">r&quot;&quot;&quot; 
        [~!.]?               # Optional link style prefix 
        \w(?:\w|\.[^\.])*    # Valid python name 
        &quot;&quot;&quot;</span>

    <span class="s1">re_simple_container_type = </span><span class="s3">r&quot;&quot;&quot; 
        {type}                        # a container type 
        [\(\[] [^\n\s]+ [\)\]]        # with the contents of the container 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_type</span>
    <span class="s1">)</span>

    <span class="s1">re_multiple_simple_type = </span><span class="s3">r&quot;&quot;&quot; 
        (?:{container_type}|{type}) 
        (?:(?:\s+(?:of|or)\s+|\s*,\s*)(?:{container_type}|{type}))* 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_type, container_type=re_simple_container_type</span>
    <span class="s1">)</span>

    <span class="s1">re_xref = </span><span class="s3">r&quot;&quot;&quot; 
        (?::\w+:)?                    # optional tag 
        `{}`                         # what to reference 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">re_type</span>
    <span class="s1">)</span>

    <span class="s1">re_param_raw = </span><span class="s3">r&quot;&quot;&quot; 
        :                       # initial colon 
        (?:                     # Sphinx keywords 
        param|parameter| 
        arg|argument| 
        key|keyword 
        ) 
        \s+                     # whitespace 
 
        (?:                     # optional type declaration 
        ({type}|{container_type}) 
        \s+ 
        )? 
 
        (\w+)                   # Parameter name 
        \s*                     # whitespace 
        :                       # final colon 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_type, container_type=re_simple_container_type</span>
    <span class="s1">)</span>
    <span class="s1">re_param_in_docstring = re.compile(re_param_raw, re.X | re.S)</span>

    <span class="s1">re_type_raw = </span><span class="s3">r&quot;&quot;&quot; 
        :type                   # Sphinx keyword 
        \s+                     # whitespace 
        ({type})                # Parameter name 
        \s*                     # whitespace 
        :                       # final colon 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_multiple_simple_type</span>
    <span class="s1">)</span>
    <span class="s1">re_type_in_docstring = re.compile(re_type_raw, re.X | re.S)</span>

    <span class="s1">re_property_type_raw = </span><span class="s3">r&quot;&quot;&quot; 
        :type:                  # Sphinx keyword 
        \s+                     # whitespace 
        {type}                  # type declaration 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_multiple_simple_type</span>
    <span class="s1">)</span>
    <span class="s1">re_property_type_in_docstring = re.compile(re_property_type_raw, re.X | re.S)</span>

    <span class="s1">re_raise_raw = </span><span class="s3">r&quot;&quot;&quot; 
        :                       # initial colon 
        (?:                     # Sphinx keyword 
        raises?| 
        except|exception 
        ) 
        \s+                     # whitespace 
        ({type})                # exception type 
        \s*                     # whitespace 
        :                       # final colon 
        &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_multiple_simple_type</span>
    <span class="s1">)</span>
    <span class="s1">re_raise_in_docstring = re.compile(re_raise_raw, re.X | re.S)</span>

    <span class="s1">re_rtype_in_docstring = re.compile(</span><span class="s3">r&quot;:rtype:&quot;</span><span class="s1">)</span>

    <span class="s1">re_returns_in_docstring = re.compile(</span><span class="s3">r&quot;:returns?:&quot;</span><span class="s1">)</span>

    <span class="s1">supports_yields = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">is_valid(self):</span>
        <span class="s2">return </span><span class="s1">bool(</span>
            <span class="s1">self.re_param_in_docstring.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_raise_in_docstring.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_rtype_in_docstring.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_returns_in_docstring.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_property_type_in_docstring.search(self.doc)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">exceptions(self):</span>
        <span class="s1">types = set()</span>

        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">re.finditer(self.re_raise_in_docstring, self.doc):</span>
            <span class="s1">raise_type = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">types.update(_split_multiple_exc_types(raise_type))</span>

        <span class="s2">return </span><span class="s1">types</span>

    <span class="s2">def </span><span class="s1">has_params(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">self.re_param_in_docstring.search(self.doc) </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">has_returns(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">bool(self.re_returns_in_docstring.search(self.doc))</span>

    <span class="s2">def </span><span class="s1">has_rtype(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">bool(self.re_rtype_in_docstring.search(self.doc))</span>

    <span class="s2">def </span><span class="s1">has_property_returns(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s0"># The summary line is the return doc,</span>
        <span class="s0"># so the first line must not be a known directive.</span>
        <span class="s2">return not </span><span class="s1">self.doc.lstrip().startswith(</span><span class="s3">&quot;:&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">has_property_type(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">bool(self.re_property_type_in_docstring.search(self.doc))</span>

    <span class="s2">def </span><span class="s1">match_param_docs(self):</span>
        <span class="s1">params_with_doc = set()</span>
        <span class="s1">params_with_type = set()</span>

        <span class="s2">for </span><span class="s1">match </span><span class="s2">in </span><span class="s1">re.finditer(self.re_param_in_docstring, self.doc):</span>
            <span class="s1">name = match.group(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">params_with_doc.add(name)</span>
            <span class="s1">param_type = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">param_type </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">params_with_type.add(name)</span>

        <span class="s1">params_with_type.update(re.findall(self.re_type_in_docstring, self.doc))</span>
        <span class="s2">return </span><span class="s1">params_with_doc, params_with_type</span>


<span class="s2">class </span><span class="s1">EpytextDocstring(SphinxDocstring):</span>
    <span class="s0">&quot;&quot;&quot; 
    Epytext is similar to Sphinx. See the docs: 
        http://epydoc.sourceforge.net/epytext.html 
        http://epydoc.sourceforge.net/fields.html#fields 
 
    It's used in PyCharm: 
        https://www.jetbrains.com/help/pycharm/2016.1/creating-documentation-comments.html#d848203e314 
        https://www.jetbrains.com/help/pycharm/2016.1/using-docstrings-to-specify-types.html 
    &quot;&quot;&quot;</span>

    <span class="s1">re_param_in_docstring = re.compile(</span>
        <span class="s1">SphinxDocstring.re_param_raw.replace(</span><span class="s3">&quot;:&quot;</span><span class="s1">, </span><span class="s3">&quot;@&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">), re.X | re.S</span>
    <span class="s1">)</span>

    <span class="s1">re_type_in_docstring = re.compile(</span>
        <span class="s1">SphinxDocstring.re_type_raw.replace(</span><span class="s3">&quot;:&quot;</span><span class="s1">, </span><span class="s3">&quot;@&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">), re.X | re.S</span>
    <span class="s1">)</span>

    <span class="s1">re_property_type_in_docstring = re.compile(</span>
        <span class="s1">SphinxDocstring.re_property_type_raw.replace(</span><span class="s3">&quot;:&quot;</span><span class="s1">, </span><span class="s3">&quot;@&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">), re.X | re.S</span>
    <span class="s1">)</span>

    <span class="s1">re_raise_in_docstring = re.compile(</span>
        <span class="s1">SphinxDocstring.re_raise_raw.replace(</span><span class="s3">&quot;:&quot;</span><span class="s1">, </span><span class="s3">&quot;@&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">), re.X | re.S</span>
    <span class="s1">)</span>

    <span class="s1">re_rtype_in_docstring = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        @                       # initial &quot;at&quot; symbol 
        (?:                     # Epytext keyword 
        rtype|returntype 
        ) 
        :                       # final colon 
        &quot;&quot;&quot;</span><span class="s1">,</span>
        <span class="s1">re.X | re.S,</span>
    <span class="s1">)</span>

    <span class="s1">re_returns_in_docstring = re.compile(</span><span class="s3">r&quot;@returns?:&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">has_property_returns(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s0"># If this is a property docstring, the summary is the return doc.</span>
        <span class="s2">if </span><span class="s1">self.has_property_type():</span>
            <span class="s0"># The summary line is the return doc,</span>
            <span class="s0"># so the first line must not be a known directive.</span>
            <span class="s2">return not </span><span class="s1">self.doc.lstrip().startswith(</span><span class="s3">&quot;@&quot;</span><span class="s1">)</span>

        <span class="s2">return False</span>


<span class="s2">class </span><span class="s1">GoogleDocstring(Docstring):</span>
    <span class="s1">re_type = SphinxDocstring.re_type</span>

    <span class="s1">re_xref = SphinxDocstring.re_xref</span>

    <span class="s1">re_container_type = </span><span class="s3">r&quot;&quot;&quot; 
        (?:{type}|{xref})             # a container type 
        [\(\[] [^\n]+ [\)\]]          # with the contents of the container 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_type, xref=re_xref</span>
    <span class="s1">)</span>

    <span class="s1">re_multiple_type = </span><span class="s3">r&quot;&quot;&quot; 
        (?:{container_type}|{type}|{xref}) 
        (?:(?:\s+(?:of|or)\s+|\s*,\s*)(?:{container_type}|{type}|{xref}))* 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
        <span class="s1">type=re_type, xref=re_xref, container_type=re_container_type</span>
    <span class="s1">)</span>

    <span class="s1">_re_section_template = </span><span class="s3">r&quot;&quot;&quot; 
        ^([ ]*)   {0} \s*:   \s*$     # Google parameter header 
        (  .* )                       # section 
        &quot;&quot;&quot;</span>

    <span class="s1">re_param_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;(?:Args|Arguments|Parameters)&quot;</span><span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_keyword_param_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Keyword\s(?:Args|Arguments|Parameters)&quot;</span><span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_param_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s*  \*{{0,2}}(\w+)             # identifier potentially with asterisks 
        \s*  ( [(] 
            {type} 
            (?:,\s+optional)? 
            [)] )? \s* :                # optional type declaration 
        \s*  (.*)                       # beginning of optional description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_raise_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Raises&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_raise_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s*  ({type}) \s* :              # identifier 
        \s*  (.*)                        # beginning of optional description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_returns_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Returns?&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_returns_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s* ({type}:)?                    # identifier 
        \s* (.*)                          # beginning of description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_property_returns_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        ^{type}:                       # indentifier 
        \s* (.*)                       # Summary line / description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_yields_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Yields?&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_yields_line = re_returns_line</span>

    <span class="s1">supports_yields = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">is_valid(self):</span>
        <span class="s2">return </span><span class="s1">bool(</span>
            <span class="s1">self.re_param_section.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_raise_section.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_returns_section.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_yields_section.search(self.doc)</span>
            <span class="s2">or </span><span class="s1">self.re_property_returns_line.search(self._first_line())</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">has_params(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">self.re_param_section.search(self.doc) </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">has_returns(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s1">entries = self._parse_section(self.re_returns_section)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_returns_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">return_desc = match.group(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">return_desc:</span>
                <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_rtype(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s1">entries = self._parse_section(self.re_returns_section)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_returns_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">return_type = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">return_type:</span>
                <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_property_returns(self):</span>
        <span class="s0"># The summary line is the return doc,</span>
        <span class="s0"># so the first line must not be a known directive.</span>
        <span class="s1">first_line = self._first_line()</span>
        <span class="s2">return not </span><span class="s1">bool(</span>
            <span class="s1">self.re_param_section.search(first_line)</span>
            <span class="s2">or </span><span class="s1">self.re_raise_section.search(first_line)</span>
            <span class="s2">or </span><span class="s1">self.re_returns_section.search(first_line)</span>
            <span class="s2">or </span><span class="s1">self.re_yields_section.search(first_line)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">has_property_type(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">bool(self.re_property_returns_line.match(self._first_line()))</span>

    <span class="s2">def </span><span class="s1">has_yields(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s1">entries = self._parse_section(self.re_yields_section)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_yields_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">yield_desc = match.group(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">yield_desc:</span>
                <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">has_yields_type(self):</span>
        <span class="s2">if not </span><span class="s1">self.doc:</span>
            <span class="s2">return False</span>

        <span class="s1">entries = self._parse_section(self.re_yields_section)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_yields_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">yield_type = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">yield_type:</span>
                <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">exceptions(self):</span>
        <span class="s1">types = set()</span>

        <span class="s1">entries = self._parse_section(self.re_raise_section)</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_raise_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">exc_type = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">exc_desc = match.group(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">exc_desc:</span>
                <span class="s1">types.update(_split_multiple_exc_types(exc_type))</span>

        <span class="s2">return </span><span class="s1">types</span>

    <span class="s2">def </span><span class="s1">match_param_docs(self):</span>
        <span class="s1">params_with_doc = set()</span>
        <span class="s1">params_with_type = set()</span>

        <span class="s1">entries = self._parse_section(self.re_param_section)</span>
        <span class="s1">entries.extend(self._parse_section(self.re_keyword_param_section))</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">entries:</span>
            <span class="s1">match = self.re_param_line.match(entry)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">continue</span>

            <span class="s1">param_name = match.group(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">param_type = match.group(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">param_desc = match.group(</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">param_type:</span>
                <span class="s1">params_with_type.add(param_name)</span>

            <span class="s2">if </span><span class="s1">param_desc:</span>
                <span class="s1">params_with_doc.add(param_name)</span>

        <span class="s2">return </span><span class="s1">params_with_doc, params_with_type</span>

    <span class="s2">def </span><span class="s1">_first_line(self):</span>
        <span class="s2">return </span><span class="s1">self.doc.lstrip().split(</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">min_section_indent(section_match):</span>
        <span class="s2">return </span><span class="s1">len(section_match.group(</span><span class="s4">1</span><span class="s1">)) + </span><span class="s4">1</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_is_section_header(_):</span>
        <span class="s0"># Google parsing does not need to detect section headers,</span>
        <span class="s0"># because it works off of indentation level only</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">_parse_section(self, section_re):</span>
        <span class="s1">section_match = section_re.search(self.doc)</span>
        <span class="s2">if </span><span class="s1">section_match </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">min_indentation = self.min_section_indent(section_match)</span>

        <span class="s1">entries = []</span>
        <span class="s1">entry = []</span>
        <span class="s1">is_first = </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">section_match.group(</span><span class="s4">2</span><span class="s1">).splitlines():</span>
            <span class="s2">if not </span><span class="s1">line.strip():</span>
                <span class="s2">continue</span>
            <span class="s1">indentation = space_indentation(line)</span>
            <span class="s2">if </span><span class="s1">indentation &lt; min_indentation:</span>
                <span class="s2">break</span>

            <span class="s0"># The first line after the header defines the minimum</span>
            <span class="s0"># indentation.</span>
            <span class="s2">if </span><span class="s1">is_first:</span>
                <span class="s1">min_indentation = indentation</span>
                <span class="s1">is_first = </span><span class="s2">False</span>

            <span class="s2">if </span><span class="s1">indentation == min_indentation:</span>
                <span class="s2">if </span><span class="s1">self._is_section_header(line):</span>
                    <span class="s2">break</span>
                <span class="s0"># Lines with minimum indentation must contain the beginning</span>
                <span class="s0"># of a new parameter documentation.</span>
                <span class="s2">if </span><span class="s1">entry:</span>
                    <span class="s1">entries.append(</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">.join(entry))</span>
                    <span class="s1">entry = []</span>

            <span class="s1">entry.append(line)</span>

        <span class="s2">if </span><span class="s1">entry:</span>
            <span class="s1">entries.append(</span><span class="s3">&quot;</span><span class="s5">\n</span><span class="s3">&quot;</span><span class="s1">.join(entry))</span>

        <span class="s2">return </span><span class="s1">entries</span>


<span class="s2">class </span><span class="s1">NumpyDocstring(GoogleDocstring):</span>
    <span class="s1">_re_section_template = </span><span class="s3">r&quot;&quot;&quot; 
        ^([ ]*)   {0}   \s*?$          # Numpy parameters header 
        \s*     [-=]+   \s*?$          # underline 
        (  .* )                        # section 
    &quot;&quot;&quot;</span>

    <span class="s1">re_param_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;(?:Args|Arguments|Parameters)&quot;</span><span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_param_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s*  (\w+)                      # identifier 
        \s*  : 
        \s*  (?:({type})(?:,\s+optional)?)? # optional type declaration 
        \n                              # description starts on a new line 
        \s* (.*)                        # description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=GoogleDocstring.re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S,</span>
    <span class="s1">)</span>

    <span class="s1">re_raise_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Raises&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_raise_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s* ({type})$   # type declaration 
        \s* (.*)        # optional description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=GoogleDocstring.re_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_returns_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Returns?&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_returns_line = re.compile(</span>
        <span class="s3">r&quot;&quot;&quot; 
        \s* (?:\w+\s+:\s+)? # optional name 
        ({type})$                         # type declaration 
        \s* (.*)                          # optional description 
    &quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">type=GoogleDocstring.re_multiple_type</span>
        <span class="s1">),</span>
        <span class="s1">re.X | re.S | re.M,</span>
    <span class="s1">)</span>

    <span class="s1">re_yields_section = re.compile(</span>
        <span class="s1">_re_section_template.format(</span><span class="s3">r&quot;Yields?&quot;</span><span class="s1">), re.X | re.S | re.M</span>
    <span class="s1">)</span>

    <span class="s1">re_yields_line = re_returns_line</span>

    <span class="s1">supports_yields = </span><span class="s2">True</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">min_section_indent(section_match):</span>
        <span class="s2">return </span><span class="s1">len(section_match.group(</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_is_section_header(line):</span>
        <span class="s2">return </span><span class="s1">bool(re.match(</span><span class="s3">r&quot;\s*-+$&quot;</span><span class="s1">, line))</span>


<span class="s1">DOCSTRING_TYPES = {</span>
    <span class="s3">&quot;sphinx&quot;</span><span class="s1">: SphinxDocstring,</span>
    <span class="s3">&quot;epytext&quot;</span><span class="s1">: EpytextDocstring,</span>
    <span class="s3">&quot;google&quot;</span><span class="s1">: GoogleDocstring,</span>
    <span class="s3">&quot;numpy&quot;</span><span class="s1">: NumpyDocstring,</span>
    <span class="s3">&quot;default&quot;</span><span class="s1">: Docstring,</span>
<span class="s1">}</span>
<span class="s3">&quot;&quot;&quot;A map of the name of the docstring type to its class. 
 
:type: dict(str, type) 
&quot;&quot;&quot;</span>
</pre>
</body>
</html>