<html>
<head>
<title>objectmodel.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
objectmodel.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2016 Derek Gustafson &lt;degustaf@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 Ceridwen &lt;ceridwenv@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 Calen Pennington &lt;cale@edx.org&gt;</span>
<span class="s0"># Copyright (c) 2018 Ville Skytt√§ &lt;ville.skytta@iki.fi&gt;</span>
<span class="s0"># Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;</span>
<span class="s0"># Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html</span>
<span class="s0"># For details: https://github.com/PyCQA/astroid/blob/master/LICENSE</span>
<span class="s0">&quot;&quot;&quot; 
Data object model, as per https://docs.python.org/3/reference/datamodel.html. 
 
This module describes, at least partially, a data object model for some 
of astroid's nodes. The model contains special attributes that nodes such 
as functions, classes, modules etc have, such as __doc__, __class__, 
__module__ etc, being used when doing attribute lookups over nodes. 
 
For instance, inferring `obj.__class__` will first trigger an inference 
of the `obj` variable. If it was successfully inferred, then an attribute 
`__class__ will be looked for in the inferred object. This is the part 
where the data model occurs. The model is attached to those nodes 
and the lookup mechanism will try to see if attributes such as 
`__class__` are defined by the model or not. If they are defined, 
the model will be requested to return the corresponding value of that 
attribute. Thus the model can be viewed as a special part of the lookup 
mechanism. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pprint</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">lru_cache</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>

<span class="s2">import </span><span class="s1">astroid</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">context </span><span class="s2">as </span><span class="s1">contextmod</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">exceptions, node_classes, util</span>

<span class="s0"># Prevents circular imports</span>
<span class="s1">objects = util.lazy_import(</span><span class="s3">&quot;objects&quot;</span><span class="s1">)</span>


<span class="s1">IMPL_PREFIX = </span><span class="s3">&quot;attr_&quot;</span>


<span class="s2">def </span><span class="s1">_dunder_dict(instance, attributes):</span>
    <span class="s1">obj = node_classes.Dict(parent=instance)</span>

    <span class="s0"># Convert the keys to node strings</span>
    <span class="s1">keys = [</span>
        <span class="s1">node_classes.Const(value=value, parent=obj) </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">list(attributes.keys())</span>
    <span class="s1">]</span>

    <span class="s0"># The original attribute has a list of elements for each key,</span>
    <span class="s0"># but that is not useful for retrieving the special attribute's value.</span>
    <span class="s0"># In this case, we're picking the last value from each list.</span>
    <span class="s1">values = [elem[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">attributes.values()]</span>

    <span class="s1">obj.postinit(list(zip(keys, values)))</span>
    <span class="s2">return </span><span class="s1">obj</span>


<span class="s2">class </span><span class="s1">ObjectModel:</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._instance = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">result = []</span>
        <span class="s1">cname = type(self).__name__</span>
        <span class="s1">string = </span><span class="s3">&quot;%(cname)s(%(fields)s)&quot;</span>
        <span class="s1">alignment = len(cname) + </span><span class="s4">1</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">sorted(self.attributes()):</span>
            <span class="s1">width = </span><span class="s4">80 </span><span class="s1">- len(field) - alignment</span>
            <span class="s1">lines = pprint.pformat(field, indent=</span><span class="s4">2</span><span class="s1">, width=width).splitlines(</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s1">inner = [lines[</span><span class="s4">0</span><span class="s1">]]</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines[</span><span class="s4">1</span><span class="s1">:]:</span>
                <span class="s1">inner.append(</span><span class="s3">&quot; &quot; </span><span class="s1">* alignment + line)</span>
            <span class="s1">result.append(field)</span>

        <span class="s2">return </span><span class="s1">string % {</span>
            <span class="s3">&quot;cname&quot;</span><span class="s1">: cname,</span>
            <span class="s3">&quot;fields&quot;</span><span class="s1">: (</span><span class="s3">&quot;,</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">+ </span><span class="s3">&quot; &quot; </span><span class="s1">* alignment).join(result),</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__call__(self, instance):</span>
        <span class="s1">self._instance = instance</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__get__(self, instance, cls=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0"># ObjectModel needs to be a descriptor so that just doing</span>
        <span class="s0"># `special_attributes = SomeObjectModel` should be enough in the body of a node.</span>
        <span class="s0"># But at the same time, node.special_attributes should return an object</span>
        <span class="s0"># which can be used for manipulating the special attributes. That's the reason</span>
        <span class="s0"># we pass the instance through which it got accessed to ObjectModel.__call__,</span>
        <span class="s0"># returning itself afterwards, so we can still have access to the</span>
        <span class="s0"># underlying data model and to the instance for which it got accessed.</span>
        <span class="s2">return </span><span class="s1">self(instance)</span>

    <span class="s2">def </span><span class="s1">__contains__(self, name):</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.attributes()</span>

    <span class="s1">@lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">attributes(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the attributes which are exported by this object model.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">obj[len(IMPL_PREFIX) :] </span><span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">dir(self) </span><span class="s2">if </span><span class="s1">obj.startswith(IMPL_PREFIX)</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">lookup(self, name):</span>
        <span class="s0">&quot;&quot;&quot;Look up the given *name* in the current model 
 
        It should return an AST or an interpreter object, 
        but if the name is not found, then an AttributeInferenceError will be raised. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.attributes():</span>
            <span class="s2">return </span><span class="s1">getattr(self, IMPL_PREFIX + name)</span>
        <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(target=self._instance, attribute=name)</span>


<span class="s2">class </span><span class="s1">ModuleModel(ObjectModel):</span>
    <span class="s2">def </span><span class="s1">_builtins(self):</span>
        <span class="s1">builtins_ast_module = astroid.MANAGER.builtins_module</span>
        <span class="s2">return </span><span class="s1">builtins_ast_module.special_attributes.lookup(</span><span class="s3">&quot;__dict__&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_builtins(self):</span>
        <span class="s2">return </span><span class="s1">self._builtins()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___path__(self):</span>
        <span class="s2">if not </span><span class="s1">self._instance.package:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self._instance, attribute=</span><span class="s3">&quot;__path__&quot;</span>
            <span class="s1">)</span>

        <span class="s1">path_objs = [</span>
            <span class="s1">node_classes.Const(</span>
                <span class="s1">value=path</span>
                <span class="s2">if not </span><span class="s1">path.endswith(</span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">)</span>
                <span class="s2">else </span><span class="s1">os.path.dirname(path),</span>
                <span class="s1">parent=self._instance,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self._instance.path</span>
        <span class="s1">]</span>

        <span class="s1">container = node_classes.List(parent=self._instance)</span>
        <span class="s1">container.postinit(path_objs)</span>

        <span class="s2">return </span><span class="s1">container</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___name__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.name, parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___doc__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.doc, parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___file__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.file, parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___dict__(self):</span>
        <span class="s2">return </span><span class="s1">_dunder_dict(self._instance, self._instance.globals)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___package__(self):</span>
        <span class="s2">if not </span><span class="s1">self._instance.package:</span>
            <span class="s1">value = </span><span class="s3">&quot;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">value = self._instance.name</span>

        <span class="s2">return </span><span class="s1">node_classes.Const(value=value, parent=self._instance)</span>

    <span class="s0"># These are related to the Python 3 implementation of the</span>
    <span class="s0"># import system,</span>
    <span class="s0"># https://docs.python.org/3/reference/import.html#import-related-module-attributes</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___spec__(self):</span>
        <span class="s0"># No handling for now.</span>
        <span class="s2">return </span><span class="s1">node_classes.Unknown()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___loader__(self):</span>
        <span class="s0"># No handling for now.</span>
        <span class="s2">return </span><span class="s1">node_classes.Unknown()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___cached__(self):</span>
        <span class="s0"># No handling for now.</span>
        <span class="s2">return </span><span class="s1">node_classes.Unknown()</span>


<span class="s2">class </span><span class="s1">FunctionModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___name__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.name, parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___doc__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.doc, parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___qualname__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=self._instance.qname(), parent=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___defaults__(self):</span>
        <span class="s1">func = self._instance</span>
        <span class="s2">if not </span><span class="s1">func.args.defaults:</span>
            <span class="s2">return </span><span class="s1">node_classes.Const(value=</span><span class="s2">None</span><span class="s1">, parent=func)</span>

        <span class="s1">defaults_obj = node_classes.Tuple(parent=func)</span>
        <span class="s1">defaults_obj.postinit(func.args.defaults)</span>
        <span class="s2">return </span><span class="s1">defaults_obj</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___annotations__(self):</span>
        <span class="s1">obj = node_classes.Dict(parent=self._instance)</span>

        <span class="s2">if not </span><span class="s1">self._instance.returns:</span>
            <span class="s1">returns = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">returns = self._instance.returns</span>

        <span class="s1">args = self._instance.args</span>
        <span class="s1">pair_annotations = itertools.chain(</span>
            <span class="s1">zip(args.args </span><span class="s2">or </span><span class="s1">[], args.annotations),</span>
            <span class="s1">zip(args.kwonlyargs, args.kwonlyargs_annotations),</span>
            <span class="s1">zip(args.posonlyargs </span><span class="s2">or </span><span class="s1">[], args.posonlyargs_annotations),</span>
        <span class="s1">)</span>

        <span class="s1">annotations = {</span>
            <span class="s1">arg.name: annotation </span><span class="s2">for </span><span class="s1">(arg, annotation) </span><span class="s2">in </span><span class="s1">pair_annotations </span><span class="s2">if </span><span class="s1">annotation</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">args.varargannotation:</span>
            <span class="s1">annotations[args.vararg] = args.varargannotation</span>
        <span class="s2">if </span><span class="s1">args.kwargannotation:</span>
            <span class="s1">annotations[args.kwarg] = args.kwargannotation</span>
        <span class="s2">if </span><span class="s1">returns:</span>
            <span class="s1">annotations[</span><span class="s3">&quot;return&quot;</span><span class="s1">] = returns</span>

        <span class="s1">items = [</span>
            <span class="s1">(node_classes.Const(key, parent=obj), value)</span>
            <span class="s2">for </span><span class="s1">(key, value) </span><span class="s2">in </span><span class="s1">annotations.items()</span>
        <span class="s1">]</span>

        <span class="s1">obj.postinit(items)</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___dict__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Dict(parent=self._instance)</span>

    <span class="s1">attr___globals__ = attr___dict__</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___kwdefaults__(self):</span>
        <span class="s2">def </span><span class="s1">_default_args(args, parent):</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args.kwonlyargs:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">default = args.default_value(arg.name)</span>
                <span class="s2">except </span><span class="s1">exceptions.NoDefault:</span>
                    <span class="s2">continue</span>

                <span class="s1">name = node_classes.Const(arg.name, parent=parent)</span>
                <span class="s2">yield </span><span class="s1">name, default</span>

        <span class="s1">args = self._instance.args</span>
        <span class="s1">obj = node_classes.Dict(parent=self._instance)</span>
        <span class="s1">defaults = dict(_default_args(args, obj))</span>

        <span class="s1">obj.postinit(list(defaults.items()))</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___module__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.root().qname())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___get__(self):</span>
        <span class="s0"># pylint: disable=import-outside-toplevel; circular import</span>
        <span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">bases</span>

        <span class="s1">func = self._instance</span>

        <span class="s2">class </span><span class="s1">DescriptorBoundMethod(bases.BoundMethod):</span>
            <span class="s0">&quot;&quot;&quot;Bound method which knows how to understand calling descriptor binding.&quot;&quot;&quot;</span>

            <span class="s2">def </span><span class="s1">implicit_parameters(self):</span>
                <span class="s0"># Different than BoundMethod since the signature</span>
                <span class="s0"># is different.</span>
                <span class="s2">return </span><span class="s4">0</span>

            <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">len(caller.args) &gt; </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">len(caller.args) &lt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;Invalid arguments for descriptor binding&quot;</span><span class="s1">,</span>
                        <span class="s1">target=self,</span>
                        <span class="s1">context=context,</span>
                    <span class="s1">)</span>

                <span class="s1">context = contextmod.copy_context(context)</span>
                <span class="s1">cls = next(caller.args[</span><span class="s4">0</span><span class="s1">].infer(context=context))</span>

                <span class="s2">if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">astroid.Uninferable:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;Invalid class inferred&quot;</span><span class="s1">, target=self, context=context</span>
                    <span class="s1">)</span>

                <span class="s0"># For some reason func is a Node that the below</span>
                <span class="s0"># code is not expecting</span>
                <span class="s2">if </span><span class="s1">isinstance(func, bases.BoundMethod):</span>
                    <span class="s2">yield </span><span class="s1">func</span>
                    <span class="s2">return</span>

                <span class="s0"># Rebuild the original value, but with the parent set as the</span>
                <span class="s0"># class where it will be bound.</span>
                <span class="s1">new_func = func.__class__(</span>
                    <span class="s1">name=func.name,</span>
                    <span class="s1">doc=func.doc,</span>
                    <span class="s1">lineno=func.lineno,</span>
                    <span class="s1">col_offset=func.col_offset,</span>
                    <span class="s1">parent=func.parent,</span>
                <span class="s1">)</span>
                <span class="s0"># pylint: disable=no-member</span>
                <span class="s1">new_func.postinit(func.args, func.body, func.decorators, func.returns)</span>

                <span class="s0"># Build a proper bound method that points to our newly built function.</span>
                <span class="s1">proxy = bases.UnboundMethod(new_func)</span>
                <span class="s2">yield </span><span class="s1">bases.BoundMethod(proxy=proxy, bound=cls)</span>

            <span class="s1">@property</span>
            <span class="s2">def </span><span class="s1">args(self):</span>
                <span class="s0">&quot;&quot;&quot;Overwrite the underlying args to match those of the underlying func 
 
                Usually the underlying *func* is a function/method, as in: 
 
                    def test(self): 
                        pass 
 
                This has only the *self* parameter but when we access test.__get__ 
                we get a new object which has two parameters, *self* and *type*. 
                &quot;&quot;&quot;</span>
                <span class="s2">nonlocal </span><span class="s1">func</span>
                <span class="s1">positional_or_keyword_params = func.args.args.copy()</span>
                <span class="s1">positional_or_keyword_params.append(astroid.AssignName(name=</span><span class="s3">&quot;type&quot;</span><span class="s1">))</span>

                <span class="s1">positional_only_params = func.args.posonlyargs.copy()</span>

                <span class="s1">arguments = astroid.Arguments(parent=func.args.parent)</span>
                <span class="s1">arguments.postinit(</span>
                    <span class="s1">args=positional_or_keyword_params,</span>
                    <span class="s1">posonlyargs=positional_only_params,</span>
                    <span class="s1">defaults=[],</span>
                    <span class="s1">kwonlyargs=[],</span>
                    <span class="s1">kw_defaults=[],</span>
                    <span class="s1">annotations=[],</span>
                <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">arguments</span>

        <span class="s2">return </span><span class="s1">DescriptorBoundMethod(proxy=self._instance, bound=self._instance)</span>

    <span class="s0"># These are here just for completion.</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___ne__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Unknown()</span>

    <span class="s1">attr___subclasshook__ = attr___ne__</span>
    <span class="s1">attr___str__ = attr___ne__</span>
    <span class="s1">attr___sizeof__ = attr___ne__</span>
    <span class="s1">attr___setattr___ = attr___ne__</span>
    <span class="s1">attr___repr__ = attr___ne__</span>
    <span class="s1">attr___reduce__ = attr___ne__</span>
    <span class="s1">attr___reduce_ex__ = attr___ne__</span>
    <span class="s1">attr___new__ = attr___ne__</span>
    <span class="s1">attr___lt__ = attr___ne__</span>
    <span class="s1">attr___eq__ = attr___ne__</span>
    <span class="s1">attr___gt__ = attr___ne__</span>
    <span class="s1">attr___format__ = attr___ne__</span>
    <span class="s1">attr___delattr___ = attr___ne__</span>
    <span class="s1">attr___getattribute__ = attr___ne__</span>
    <span class="s1">attr___hash__ = attr___ne__</span>
    <span class="s1">attr___init__ = attr___ne__</span>
    <span class="s1">attr___dir__ = attr___ne__</span>
    <span class="s1">attr___call__ = attr___ne__</span>
    <span class="s1">attr___class__ = attr___ne__</span>
    <span class="s1">attr___closure__ = attr___ne__</span>
    <span class="s1">attr___code__ = attr___ne__</span>


<span class="s2">class </span><span class="s1">ClassModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___module__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.root().qname())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___name__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.name)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___qualname__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.qname())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___doc__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.doc)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___mro__(self):</span>
        <span class="s2">if not </span><span class="s1">self._instance.newstyle:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self._instance, attribute=</span><span class="s3">&quot;__mro__&quot;</span>
            <span class="s1">)</span>

        <span class="s1">mro = self._instance.mro()</span>
        <span class="s1">obj = node_classes.Tuple(parent=self._instance)</span>
        <span class="s1">obj.postinit(mro)</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_mro(self):</span>
        <span class="s2">if not </span><span class="s1">self._instance.newstyle:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self._instance, attribute=</span><span class="s3">&quot;mro&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># pylint: disable=import-outside-toplevel; circular import</span>
        <span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">bases</span>

        <span class="s1">other_self = self</span>

        <span class="s0"># Cls.mro is a method and we need to return one in order to have a proper inference.</span>
        <span class="s0"># The method we're returning is capable of inferring the underlying MRO though.</span>
        <span class="s2">class </span><span class="s1">MroBoundMethod(bases.BoundMethod):</span>
            <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">yield </span><span class="s1">other_self.attr___mro__</span>

        <span class="s1">implicit_metaclass = self._instance.implicit_metaclass()</span>
        <span class="s1">mro_method = implicit_metaclass.locals[</span><span class="s3">&quot;mro&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">MroBoundMethod(proxy=mro_method, bound=implicit_metaclass)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___bases__(self):</span>
        <span class="s1">obj = node_classes.Tuple()</span>
        <span class="s1">context = contextmod.InferenceContext()</span>
        <span class="s1">elts = list(self._instance._inferred_bases(context))</span>
        <span class="s1">obj.postinit(elts=elts)</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___class__(self):</span>
        <span class="s0"># pylint: disable=import-outside-toplevel; circular import</span>
        <span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">helpers</span>

        <span class="s2">return </span><span class="s1">helpers.object_type(self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___subclasses__(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the subclasses of the underlying class 
 
        This looks only in the current module for retrieving the subclasses, 
        thus it might miss a couple of them. 
        &quot;&quot;&quot;</span>
        <span class="s0"># pylint: disable=import-outside-toplevel; circular import</span>
        <span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">bases, scoped_nodes</span>

        <span class="s2">if not </span><span class="s1">self._instance.newstyle:</span>
            <span class="s2">raise </span><span class="s1">exceptions.AttributeInferenceError(</span>
                <span class="s1">target=self._instance, attribute=</span><span class="s3">&quot;__subclasses__&quot;</span>
            <span class="s1">)</span>

        <span class="s1">qname = self._instance.qname()</span>
        <span class="s1">root = self._instance.root()</span>
        <span class="s1">classes = [</span>
            <span class="s1">cls</span>
            <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">root.nodes_of_class(scoped_nodes.ClassDef)</span>
            <span class="s2">if </span><span class="s1">cls != self._instance </span><span class="s2">and </span><span class="s1">cls.is_subtype_of(qname)</span>
        <span class="s1">]</span>

        <span class="s1">obj = node_classes.List(parent=self._instance)</span>
        <span class="s1">obj.postinit(classes)</span>

        <span class="s2">class </span><span class="s1">SubclassesBoundMethod(bases.BoundMethod):</span>
            <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">yield </span><span class="s1">obj</span>

        <span class="s1">implicit_metaclass = self._instance.implicit_metaclass()</span>
        <span class="s1">subclasses_method = implicit_metaclass.locals[</span><span class="s3">&quot;__subclasses__&quot;</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">SubclassesBoundMethod(proxy=subclasses_method, bound=implicit_metaclass)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___dict__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Dict(parent=self._instance)</span>


<span class="s2">class </span><span class="s1">SuperModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___thisclass__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance.mro_pointer</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___self_class__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._self_class</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___self__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance.type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___class__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._proxied</span>


<span class="s2">class </span><span class="s1">UnboundMethodModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___class__(self):</span>
        <span class="s0"># pylint: disable=import-outside-toplevel; circular import</span>
        <span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">helpers</span>

        <span class="s2">return </span><span class="s1">helpers.object_type(self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___func__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._proxied</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___self__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(value=</span><span class="s2">None</span><span class="s1">, parent=self._instance)</span>

    <span class="s1">attr_im_func = attr___func__</span>
    <span class="s1">attr_im_class = attr___class__</span>
    <span class="s1">attr_im_self = attr___self__</span>


<span class="s2">class </span><span class="s1">BoundMethodModel(FunctionModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___func__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._proxied._proxied</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___self__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance.bound</span>


<span class="s2">class </span><span class="s1">GeneratorModel(FunctionModel):</span>
    <span class="s2">def </span><span class="s1">__new__(cls, *args, **kwargs):</span>
        <span class="s0"># Append the values from the GeneratorType unto this object.</span>
        <span class="s1">ret = super().__new__(cls, *args, **kwargs)</span>
        <span class="s1">generator = astroid.MANAGER.builtins_module[</span><span class="s3">&quot;generator&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">name, values </span><span class="s2">in </span><span class="s1">generator.locals.items():</span>
            <span class="s1">method = values[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">patched = </span><span class="s2">lambda </span><span class="s1">cls, meth=method: meth</span>

            <span class="s1">setattr(type(ret), IMPL_PREFIX + name, property(patched))</span>

        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___name__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span>
            <span class="s1">value=self._instance.parent.name, parent=self._instance</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___doc__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span>
            <span class="s1">value=self._instance.parent.doc, parent=self._instance</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">AsyncGeneratorModel(GeneratorModel):</span>
    <span class="s2">def </span><span class="s1">__new__(cls, *args, **kwargs):</span>
        <span class="s0"># Append the values from the AGeneratorType unto this object.</span>
        <span class="s1">ret = super().__new__(cls, *args, **kwargs)</span>
        <span class="s1">astroid_builtins = astroid.MANAGER.builtins_module</span>
        <span class="s1">generator = astroid_builtins.get(</span><span class="s3">&quot;async_generator&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">generator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Make it backward compatible.</span>
            <span class="s1">generator = astroid_builtins.get(</span><span class="s3">&quot;generator&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">name, values </span><span class="s2">in </span><span class="s1">generator.locals.items():</span>
            <span class="s1">method = values[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">patched = </span><span class="s2">lambda </span><span class="s1">cls, meth=method: meth</span>

            <span class="s1">setattr(type(ret), IMPL_PREFIX + name, property(patched))</span>

        <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">InstanceModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___class__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._proxied</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___module__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.root().qname())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___doc__(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(self._instance.doc)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___dict__(self):</span>
        <span class="s2">return </span><span class="s1">_dunder_dict(self._instance, self._instance.instance_attrs)</span>


<span class="s0"># Exception instances</span>


<span class="s2">class </span><span class="s1">ExceptionInstanceModel(InstanceModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_args(self):</span>
        <span class="s1">message = node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">args = node_classes.Tuple(parent=self._instance)</span>
        <span class="s1">args.postinit((message,))</span>
        <span class="s2">return </span><span class="s1">args</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___traceback__(self):</span>
        <span class="s1">builtins_ast_module = astroid.MANAGER.builtins_module</span>
        <span class="s1">traceback_type = builtins_ast_module[types.TracebackType.__name__]</span>
        <span class="s2">return </span><span class="s1">traceback_type.instantiate_class()</span>


<span class="s2">class </span><span class="s1">SyntaxErrorInstanceModel(ExceptionInstanceModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_text(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">OSErrorInstanceModel(ExceptionInstanceModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_filename(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_errno(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_strerror(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">attr_filename2 = attr_filename</span>


<span class="s2">class </span><span class="s1">ImportErrorInstanceModel(ExceptionInstanceModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_name(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_path(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">UnicodeDecodeErrorInstanceModel(ExceptionInstanceModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_object(self):</span>
        <span class="s2">return </span><span class="s1">node_classes.Const(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>


<span class="s1">BUILTIN_EXCEPTIONS = {</span>
    <span class="s3">&quot;builtins.SyntaxError&quot;</span><span class="s1">: SyntaxErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ImportError&quot;</span><span class="s1">: ImportErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.UnicodeDecodeError&quot;</span><span class="s1">: UnicodeDecodeErrorInstanceModel,</span>
    <span class="s0"># These are all similar to OSError in terms of attributes</span>
    <span class="s3">&quot;builtins.OSError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.BlockingIOError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.BrokenPipeError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ChildProcessError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ConnectionAbortedError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ConnectionError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ConnectionRefusedError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ConnectionResetError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.FileExistsError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.FileNotFoundError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.InterruptedError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.IsADirectoryError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.NotADirectoryError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.PermissionError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.ProcessLookupError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
    <span class="s3">&quot;builtins.TimeoutError&quot;</span><span class="s1">: OSErrorInstanceModel,</span>
<span class="s1">}</span>


<span class="s2">class </span><span class="s1">DictModel(ObjectModel):</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr___class__(self):</span>
        <span class="s2">return </span><span class="s1">self._instance._proxied</span>

    <span class="s2">def </span><span class="s1">_generic_dict_attribute(self, obj, name):</span>
        <span class="s0">&quot;&quot;&quot;Generate a bound method that can infer the given *obj*.&quot;&quot;&quot;</span>

        <span class="s2">class </span><span class="s1">DictMethodBoundMethod(astroid.BoundMethod):</span>
            <span class="s2">def </span><span class="s1">infer_call_result(self, caller, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">yield </span><span class="s1">obj</span>

        <span class="s1">meth = next(self._instance._proxied.igetattr(name))</span>
        <span class="s2">return </span><span class="s1">DictMethodBoundMethod(proxy=meth, bound=self._instance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_items(self):</span>
        <span class="s1">elems = []</span>
        <span class="s1">obj = node_classes.List(parent=self._instance)</span>
        <span class="s2">for </span><span class="s1">key, value </span><span class="s2">in </span><span class="s1">self._instance.items:</span>
            <span class="s1">elem = node_classes.Tuple(parent=obj)</span>
            <span class="s1">elem.postinit((key, value))</span>
            <span class="s1">elems.append(elem)</span>
        <span class="s1">obj.postinit(elts=elems)</span>

        <span class="s1">obj = objects.DictItems(obj)</span>
        <span class="s2">return </span><span class="s1">self._generic_dict_attribute(obj, </span><span class="s3">&quot;items&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_keys(self):</span>
        <span class="s1">keys = [key </span><span class="s2">for </span><span class="s1">(key, _) </span><span class="s2">in </span><span class="s1">self._instance.items]</span>
        <span class="s1">obj = node_classes.List(parent=self._instance)</span>
        <span class="s1">obj.postinit(elts=keys)</span>

        <span class="s1">obj = objects.DictKeys(obj)</span>
        <span class="s2">return </span><span class="s1">self._generic_dict_attribute(obj, </span><span class="s3">&quot;keys&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_values(self):</span>

        <span class="s1">values = [value </span><span class="s2">for </span><span class="s1">(_, value) </span><span class="s2">in </span><span class="s1">self._instance.items]</span>
        <span class="s1">obj = node_classes.List(parent=self._instance)</span>
        <span class="s1">obj.postinit(values)</span>

        <span class="s1">obj = objects.DictValues(obj)</span>
        <span class="s2">return </span><span class="s1">self._generic_dict_attribute(obj, </span><span class="s3">&quot;values&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">PropertyModel(ObjectModel):</span>
    <span class="s0">&quot;&quot;&quot;Model for a builtin property&quot;&quot;&quot;</span>

    <span class="s0"># pylint: disable=import-outside-toplevel</span>
    <span class="s2">def </span><span class="s1">_init_function(self, name):</span>
        <span class="s2">from </span><span class="s1">astroid.node_classes </span><span class="s2">import </span><span class="s1">Arguments</span>
        <span class="s2">from </span><span class="s1">astroid.scoped_nodes </span><span class="s2">import </span><span class="s1">FunctionDef</span>

        <span class="s1">args = Arguments()</span>
        <span class="s1">args.postinit(</span>
            <span class="s1">args=[],</span>
            <span class="s1">defaults=[],</span>
            <span class="s1">kwonlyargs=[],</span>
            <span class="s1">kw_defaults=[],</span>
            <span class="s1">annotations=[],</span>
            <span class="s1">posonlyargs=[],</span>
            <span class="s1">posonlyargs_annotations=[],</span>
            <span class="s1">kwonlyargs_annotations=[],</span>
        <span class="s1">)</span>

        <span class="s1">function = FunctionDef(name=name, parent=self._instance)</span>

        <span class="s1">function.postinit(args=args, body=[])</span>
        <span class="s2">return </span><span class="s1">function</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_fget(self):</span>
        <span class="s2">from </span><span class="s1">astroid.scoped_nodes </span><span class="s2">import </span><span class="s1">FunctionDef</span>

        <span class="s1">func = self._instance</span>

        <span class="s2">class </span><span class="s1">PropertyFuncAccessor(FunctionDef):</span>
            <span class="s2">def </span><span class="s1">infer_call_result(self, caller=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">nonlocal </span><span class="s1">func</span>
                <span class="s2">if </span><span class="s1">caller </span><span class="s2">and </span><span class="s1">len(caller.args) != </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;fget() needs a single argument&quot;</span><span class="s1">, target=self, context=context</span>
                    <span class="s1">)</span>

                <span class="s2">yield from </span><span class="s1">func.function.infer_call_result(</span>
                    <span class="s1">caller=caller, context=context</span>
                <span class="s1">)</span>

        <span class="s1">property_accessor = PropertyFuncAccessor(name=</span><span class="s3">&quot;fget&quot;</span><span class="s1">, parent=self._instance)</span>
        <span class="s1">property_accessor.postinit(args=func.args, body=func.body)</span>
        <span class="s2">return </span><span class="s1">property_accessor</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_fset(self):</span>
        <span class="s2">from </span><span class="s1">astroid.scoped_nodes </span><span class="s2">import </span><span class="s1">FunctionDef</span>

        <span class="s1">func = self._instance</span>

        <span class="s2">def </span><span class="s1">find_setter(func: objects.Property) -&gt; Optional[astroid.FunctionDef]:</span>
            <span class="s0">&quot;&quot;&quot; 
            Given a property, find the corresponding setter function and returns it. 
 
            :param func: property for which the setter has to be found 
            :return: the setter function or None 
            &quot;&quot;&quot;</span>
            <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">func.parent.get_children() </span><span class="s2">if </span><span class="s1">t.name == func.function.name</span>
            <span class="s1">]:</span>
                <span class="s2">for </span><span class="s1">dec_name </span><span class="s2">in </span><span class="s1">target.decoratornames():</span>
                    <span class="s2">if </span><span class="s1">dec_name.endswith(func.function.name + </span><span class="s3">&quot;.setter&quot;</span><span class="s1">):</span>
                        <span class="s2">return </span><span class="s1">target</span>
            <span class="s2">return None</span>

        <span class="s1">func_setter = find_setter(func)</span>
        <span class="s2">if not </span><span class="s1">func_setter:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s3">f&quot;Unable to find the setter of property </span><span class="s5">{</span><span class="s1">func.function.name</span><span class="s5">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">class </span><span class="s1">PropertyFuncAccessor(FunctionDef):</span>
            <span class="s2">def </span><span class="s1">infer_call_result(self, caller=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">):</span>
                <span class="s2">nonlocal </span><span class="s1">func_setter</span>
                <span class="s2">if </span><span class="s1">caller </span><span class="s2">and </span><span class="s1">len(caller.args) != </span><span class="s4">2</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;fset() needs two arguments&quot;</span><span class="s1">, target=self, context=context</span>
                    <span class="s1">)</span>
                <span class="s2">yield from </span><span class="s1">func_setter.infer_call_result(caller=caller, context=context)</span>

        <span class="s1">property_accessor = PropertyFuncAccessor(name=</span><span class="s3">&quot;fset&quot;</span><span class="s1">, parent=self._instance)</span>
        <span class="s1">property_accessor.postinit(args=func_setter.args, body=func_setter.body)</span>
        <span class="s2">return </span><span class="s1">property_accessor</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_setter(self):</span>
        <span class="s2">return </span><span class="s1">self._init_function(</span><span class="s3">&quot;setter&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_deleter(self):</span>
        <span class="s2">return </span><span class="s1">self._init_function(</span><span class="s3">&quot;deleter&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">attr_getter(self):</span>
        <span class="s2">return </span><span class="s1">self._init_function(</span><span class="s3">&quot;getter&quot;</span><span class="s1">)</span>

    <span class="s0"># pylint: enable=import-outside-toplevel</span>
</pre>
</body>
</html>