<html>
<head>
<title>protocols.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
protocols.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;</span>
<span class="s0"># Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2014 Google, Inc.</span>
<span class="s0"># Copyright (c) 2014 Eevee (Alex Munroe) &lt;amunroe@yelp.com&gt;</span>
<span class="s0"># Copyright (c) 2015-2016 Ceridwen &lt;ceridwenv@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;</span>
<span class="s0"># Copyright (c) 2016 Derek Gustafson &lt;degustaf@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017-2018 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;</span>
<span class="s0"># Copyright (c) 2017 Łukasz Rogalski &lt;rogalski.91@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2017 rr- &lt;rr-@sakuya.pl&gt;</span>
<span class="s0"># Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 Ville Skyttä &lt;ville.skytta@iki.fi&gt;</span>
<span class="s0"># Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2018 HoverHell &lt;hoverhell@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;</span>
<span class="s0"># Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Vilnis Termanis &lt;vilnis.termanis@iotics.com&gt;</span>
<span class="s0"># Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;</span>
<span class="s0"># Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;</span>

<span class="s0"># Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html</span>
<span class="s0"># For details: https://github.com/PyCQA/astroid/blob/master/LICENSE</span>

<span class="s0">&quot;&quot;&quot;this module contains a set of functions to handle python protocols for nodes 
where it makes sense. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">operator </span><span class="s2">as </span><span class="s1">operator_mod</span>

<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">Store, arguments, bases</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">context </span><span class="s2">as </span><span class="s1">contextmod</span>
<span class="s2">from </span><span class="s1">astroid </span><span class="s2">import </span><span class="s1">decorators, exceptions, helpers, node_classes, nodes, util</span>

<span class="s1">raw_building = util.lazy_import(</span><span class="s3">&quot;raw_building&quot;</span><span class="s1">)</span>
<span class="s1">objects = util.lazy_import(</span><span class="s3">&quot;objects&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_reflected_name(name):</span>
    <span class="s2">return </span><span class="s3">&quot;__r&quot; </span><span class="s1">+ name[</span><span class="s4">2</span><span class="s1">:]</span>


<span class="s2">def </span><span class="s1">_augmented_name(name):</span>
    <span class="s2">return </span><span class="s3">&quot;__i&quot; </span><span class="s1">+ name[</span><span class="s4">2</span><span class="s1">:]</span>


<span class="s1">_CONTEXTLIB_MGR = </span><span class="s3">&quot;contextlib.contextmanager&quot;</span>
<span class="s1">BIN_OP_METHOD = {</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: </span><span class="s3">&quot;__add__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: </span><span class="s3">&quot;__sub__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;/&quot;</span><span class="s1">: </span><span class="s3">&quot;__truediv__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;//&quot;</span><span class="s1">: </span><span class="s3">&quot;__floordiv__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;*&quot;</span><span class="s1">: </span><span class="s3">&quot;__mul__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;**&quot;</span><span class="s1">: </span><span class="s3">&quot;__pow__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;%&quot;</span><span class="s1">: </span><span class="s3">&quot;__mod__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;&amp;&quot;</span><span class="s1">: </span><span class="s3">&quot;__and__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;|&quot;</span><span class="s1">: </span><span class="s3">&quot;__or__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;^&quot;</span><span class="s1">: </span><span class="s3">&quot;__xor__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;&lt;&lt;&quot;</span><span class="s1">: </span><span class="s3">&quot;__lshift__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;&gt;&gt;&quot;</span><span class="s1">: </span><span class="s3">&quot;__rshift__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;@&quot;</span><span class="s1">: </span><span class="s3">&quot;__matmul__&quot;</span><span class="s1">,</span>
<span class="s1">}</span>

<span class="s1">REFLECTED_BIN_OP_METHOD = {</span>
    <span class="s1">key: _reflected_name(value) </span><span class="s2">for </span><span class="s1">(key, value) </span><span class="s2">in </span><span class="s1">BIN_OP_METHOD.items()</span>
<span class="s1">}</span>
<span class="s1">AUGMENTED_OP_METHOD = {</span>
    <span class="s1">key + </span><span class="s3">&quot;=&quot;</span><span class="s1">: _augmented_name(value) </span><span class="s2">for </span><span class="s1">(key, value) </span><span class="s2">in </span><span class="s1">BIN_OP_METHOD.items()</span>
<span class="s1">}</span>

<span class="s1">UNARY_OP_METHOD = {</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: </span><span class="s3">&quot;__pos__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: </span><span class="s3">&quot;__neg__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;~&quot;</span><span class="s1">: </span><span class="s3">&quot;__invert__&quot;</span><span class="s1">,</span>
    <span class="s3">&quot;not&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">,  </span><span class="s0"># XXX not '__nonzero__'</span>
<span class="s1">}</span>
<span class="s1">_UNARY_OPERATORS = {</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: operator_mod.pos,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: operator_mod.neg,</span>
    <span class="s3">&quot;~&quot;</span><span class="s1">: operator_mod.invert,</span>
    <span class="s3">&quot;not&quot;</span><span class="s1">: operator_mod.not_,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">_infer_unary_op(obj, op):</span>
    <span class="s1">func = _UNARY_OPERATORS[op]</span>
    <span class="s1">value = func(obj)</span>
    <span class="s2">return </span><span class="s1">nodes.const_factory(value)</span>


<span class="s1">nodes.Tuple.infer_unary_op = </span><span class="s2">lambda </span><span class="s1">self, op: _infer_unary_op(tuple(self.elts), op)</span>
<span class="s1">nodes.List.infer_unary_op = </span><span class="s2">lambda </span><span class="s1">self, op: _infer_unary_op(self.elts, op)</span>
<span class="s1">nodes.Set.infer_unary_op = </span><span class="s2">lambda </span><span class="s1">self, op: _infer_unary_op(set(self.elts), op)</span>
<span class="s1">nodes.Const.infer_unary_op = </span><span class="s2">lambda </span><span class="s1">self, op: _infer_unary_op(self.value, op)</span>
<span class="s1">nodes.Dict.infer_unary_op = </span><span class="s2">lambda </span><span class="s1">self, op: _infer_unary_op(dict(self.items), op)</span>

<span class="s0"># Binary operations</span>

<span class="s1">BIN_OP_IMPL = {</span>
    <span class="s3">&quot;+&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a + b,</span>
    <span class="s3">&quot;-&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a - b,</span>
    <span class="s3">&quot;/&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a / b,</span>
    <span class="s3">&quot;//&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a // b,</span>
    <span class="s3">&quot;*&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a * b,</span>
    <span class="s3">&quot;**&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a ** b,</span>
    <span class="s3">&quot;%&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a % b,</span>
    <span class="s3">&quot;&amp;&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a &amp; b,</span>
    <span class="s3">&quot;|&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a | b,</span>
    <span class="s3">&quot;^&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a ^ b,</span>
    <span class="s3">&quot;&lt;&lt;&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a &lt;&lt; b,</span>
    <span class="s3">&quot;&gt;&gt;&quot;</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">a, b: a &gt;&gt; b,</span>
    <span class="s3">&quot;@&quot;</span><span class="s1">: operator_mod.matmul,</span>
<span class="s1">}</span>
<span class="s2">for </span><span class="s1">_KEY, _IMPL </span><span class="s2">in </span><span class="s1">list(BIN_OP_IMPL.items()):</span>
    <span class="s1">BIN_OP_IMPL[_KEY + </span><span class="s3">&quot;=&quot;</span><span class="s1">] = _IMPL</span>


<span class="s1">@decorators.yes_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">const_infer_binary_op(self, opnode, operator, other, context, _):</span>
    <span class="s1">not_implemented = nodes.Const(NotImplemented)</span>
    <span class="s2">if </span><span class="s1">isinstance(other, nodes.Const):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">impl = BIN_OP_IMPL[operator]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">nodes.const_factory(impl(self.value, other.value))</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s0"># ArithmeticError is not enough: float &gt;&gt; float is a TypeError</span>
                <span class="s2">yield </span><span class="s1">not_implemented</span>
            <span class="s2">except </span><span class="s1">Exception:  </span><span class="s0"># pylint: disable=broad-except</span>
                <span class="s2">yield </span><span class="s1">util.Uninferable</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">yield </span><span class="s1">not_implemented</span>
    <span class="s2">elif </span><span class="s1">isinstance(self.value, str) </span><span class="s2">and </span><span class="s1">operator == </span><span class="s3">&quot;%&quot;</span><span class="s1">:</span>
        <span class="s0"># TODO(cpopa): implement string interpolation later on.</span>
        <span class="s2">yield </span><span class="s1">util.Uninferable</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">not_implemented</span>


<span class="s1">nodes.Const.infer_binary_op = const_infer_binary_op</span>


<span class="s2">def </span><span class="s1">_multiply_seq_by_int(self, opnode, other, context):</span>
    <span class="s1">node = self.__class__(parent=opnode)</span>
    <span class="s1">filtered_elts = (</span>
        <span class="s1">helpers.safe_infer(elt, context) </span><span class="s2">or </span><span class="s1">util.Uninferable</span>
        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">self.elts</span>
        <span class="s2">if </span><span class="s1">elt </span><span class="s2">is not </span><span class="s1">util.Uninferable</span>
    <span class="s1">)</span>
    <span class="s1">node.elts = list(filtered_elts) * other.value</span>
    <span class="s2">return </span><span class="s1">node</span>


<span class="s2">def </span><span class="s1">_filter_uninferable_nodes(elts, context):</span>
    <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">elts:</span>
        <span class="s2">if </span><span class="s1">elt </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
            <span class="s2">yield </span><span class="s1">nodes.Unknown()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">elt.infer(context):</span>
                <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is not </span><span class="s1">util.Uninferable:</span>
                    <span class="s2">yield </span><span class="s1">inferred</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">yield </span><span class="s1">nodes.Unknown()</span>


<span class="s1">@decorators.yes_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">tl_infer_binary_op(self, opnode, operator, other, context, method):</span>
    <span class="s1">not_implemented = nodes.Const(NotImplemented)</span>
    <span class="s2">if </span><span class="s1">isinstance(other, self.__class__) </span><span class="s2">and </span><span class="s1">operator == </span><span class="s3">&quot;+&quot;</span><span class="s1">:</span>
        <span class="s1">node = self.__class__(parent=opnode)</span>
        <span class="s1">node.elts = list(</span>
            <span class="s1">itertools.chain(</span>
                <span class="s1">_filter_uninferable_nodes(self.elts, context),</span>
                <span class="s1">_filter_uninferable_nodes(other.elts, context),</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">yield </span><span class="s1">node</span>
    <span class="s2">elif </span><span class="s1">isinstance(other, nodes.Const) </span><span class="s2">and </span><span class="s1">operator == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">isinstance(other.value, int):</span>
            <span class="s2">yield </span><span class="s1">not_implemented</span>
            <span class="s2">return</span>
        <span class="s2">yield </span><span class="s1">_multiply_seq_by_int(self, opnode, other, context)</span>
    <span class="s2">elif </span><span class="s1">isinstance(other, bases.Instance) </span><span class="s2">and </span><span class="s1">operator == </span><span class="s3">&quot;*&quot;</span><span class="s1">:</span>
        <span class="s0"># Verify if the instance supports __index__.</span>
        <span class="s1">as_index = helpers.class_instance_as_index(other)</span>
        <span class="s2">if not </span><span class="s1">as_index:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">_multiply_seq_by_int(self, opnode, as_index, context)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">yield </span><span class="s1">not_implemented</span>


<span class="s1">nodes.Tuple.infer_binary_op = tl_infer_binary_op</span>
<span class="s1">nodes.List.infer_binary_op = tl_infer_binary_op</span>


<span class="s1">@decorators.yes_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">instance_class_infer_binary_op(self, opnode, operator, other, context, method):</span>
    <span class="s2">return </span><span class="s1">method.infer_call_result(self, context)</span>


<span class="s1">bases.Instance.infer_binary_op = instance_class_infer_binary_op</span>
<span class="s1">nodes.ClassDef.infer_binary_op = instance_class_infer_binary_op</span>


<span class="s0"># assignment ##################################################################</span>

<span class="s3">&quot;&quot;&quot;the assigned_stmts method is responsible to return the assigned statement 
(e.g. not inferred) according to the assignment type. 
 
The `assign_path` argument is used to record the lhs path of the original node. 
For instance if we want assigned statements for 'c' in 'a, (b,c)', assign_path 
will be [1, 1] once arrived to the Assign node. 
 
The `context` argument is the current inference context which should be given 
to any intermediary inference necessary. 
&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_resolve_looppart(parts, assign_path, context):</span>
    <span class="s0">&quot;&quot;&quot;recursive function to resolve multiple assignments on loops&quot;&quot;&quot;</span>
    <span class="s1">assign_path = assign_path[:]</span>
    <span class="s1">index = assign_path.pop(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts:</span>
        <span class="s2">if </span><span class="s1">part </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
            <span class="s2">continue</span>
        <span class="s2">if not </span><span class="s1">hasattr(part, </span><span class="s3">&quot;itered&quot;</span><span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">itered = part.itered()</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">continue</span>
        <span class="s2">for </span><span class="s1">stmt </span><span class="s2">in </span><span class="s1">itered:</span>
            <span class="s1">index_node = nodes.Const(index)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">assigned = stmt.getitem(index_node, context)</span>
            <span class="s2">except </span><span class="s1">(</span>
                <span class="s1">AttributeError,</span>
                <span class="s1">exceptions.AstroidTypeError,</span>
                <span class="s1">exceptions.AstroidIndexError,</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>
            <span class="s2">if not </span><span class="s1">assign_path:</span>
                <span class="s0"># we achieved to resolved the assignment path,</span>
                <span class="s0"># don't infer the last part</span>
                <span class="s2">yield </span><span class="s1">assigned</span>
            <span class="s2">elif </span><span class="s1">assigned </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
                <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># we are not yet on the last part of the path</span>
                <span class="s0"># search on each possibly inferred value</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">yield from </span><span class="s1">_resolve_looppart(</span>
                        <span class="s1">assigned.infer(context), assign_path, context</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                    <span class="s2">break</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">for_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">isinstance(self, nodes.AsyncFor) </span><span class="s2">or </span><span class="s1">getattr(self, </span><span class="s3">&quot;is_async&quot;</span><span class="s1">, </span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0"># Skip inferring of async code for now</span>
        <span class="s2">return </span><span class="s1">dict(node=self, unknown=node, assign_path=assign_path, context=context)</span>
    <span class="s2">if </span><span class="s1">assign_path </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">lst </span><span class="s2">in </span><span class="s1">self.iter.infer(context):</span>
            <span class="s2">if </span><span class="s1">isinstance(lst, (nodes.Tuple, nodes.List)):</span>
                <span class="s2">yield from </span><span class="s1">lst.elts</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">yield from </span><span class="s1">_resolve_looppart(self.iter.infer(context), assign_path, context)</span>
    <span class="s2">return </span><span class="s1">dict(node=self, unknown=node, assign_path=assign_path, context=context)</span>


<span class="s1">nodes.For.assigned_stmts = for_assigned_stmts</span>
<span class="s1">nodes.Comprehension.assigned_stmts = for_assigned_stmts</span>


<span class="s2">def </span><span class="s1">sequence_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">assign_path </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">assign_path = []</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">index = self.elts.index(node)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">exc:</span>
        <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
            <span class="s3">&quot;Tried to retrieve a node {node!r} which does not exist&quot;</span><span class="s1">,</span>
            <span class="s1">node=self,</span>
            <span class="s1">assign_path=assign_path,</span>
            <span class="s1">context=context,</span>
        <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>

    <span class="s1">assign_path.insert(</span><span class="s4">0</span><span class="s1">, index)</span>
    <span class="s2">return </span><span class="s1">self.parent.assigned_stmts(</span>
        <span class="s1">node=self, context=context, assign_path=assign_path</span>
    <span class="s1">)</span>


<span class="s1">nodes.Tuple.assigned_stmts = sequence_assigned_stmts</span>
<span class="s1">nodes.List.assigned_stmts = sequence_assigned_stmts</span>


<span class="s2">def </span><span class="s1">assend_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">self.parent.assigned_stmts(node=self, context=context)</span>


<span class="s1">nodes.AssignName.assigned_stmts = assend_assigned_stmts</span>
<span class="s1">nodes.AssignAttr.assigned_stmts = assend_assigned_stmts</span>


<span class="s2">def </span><span class="s1">_arguments_infer_argname(self, name, context):</span>
    <span class="s0"># arguments information may be missing, in which case we can't do anything</span>
    <span class="s0"># more</span>
    <span class="s2">if not </span><span class="s1">(self.arguments </span><span class="s2">or </span><span class="s1">self.vararg </span><span class="s2">or </span><span class="s1">self.kwarg):</span>
        <span class="s2">yield </span><span class="s1">util.Uninferable</span>
        <span class="s2">return</span>

    <span class="s1">functype = self.parent.type</span>
    <span class="s0"># first argument of instance/class method</span>
    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">self.arguments</span>
        <span class="s2">and </span><span class="s1">getattr(self.arguments[</span><span class="s4">0</span><span class="s1">], </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">) == name</span>
        <span class="s2">and </span><span class="s1">functype != </span><span class="s3">&quot;staticmethod&quot;</span>
    <span class="s1">):</span>
        <span class="s1">cls = self.parent.parent.scope()</span>
        <span class="s1">is_metaclass = isinstance(cls, nodes.ClassDef) </span><span class="s2">and </span><span class="s1">cls.type == </span><span class="s3">&quot;metaclass&quot;</span>
        <span class="s0"># If this is a metaclass, then the first argument will always</span>
        <span class="s0"># be the class, not an instance.</span>
        <span class="s2">if </span><span class="s1">context.boundnode </span><span class="s2">and </span><span class="s1">isinstance(context.boundnode, bases.Instance):</span>
            <span class="s1">cls = context.boundnode._proxied</span>
        <span class="s2">if </span><span class="s1">is_metaclass </span><span class="s2">or </span><span class="s1">functype == </span><span class="s3">&quot;classmethod&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">cls</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">functype == </span><span class="s3">&quot;method&quot;</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">cls.instantiate_class()</span>
            <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">context </span><span class="s2">and </span><span class="s1">context.callcontext:</span>
        <span class="s1">call_site = arguments.CallSite(context.callcontext, context.extra_context)</span>
        <span class="s2">yield from </span><span class="s1">call_site.infer_argument(self.parent, name, context)</span>
        <span class="s2">return</span>

    <span class="s2">if </span><span class="s1">name == self.vararg:</span>
        <span class="s1">vararg = nodes.const_factory(())</span>
        <span class="s1">vararg.parent = self</span>
        <span class="s2">if not </span><span class="s1">self.arguments </span><span class="s2">and </span><span class="s1">self.parent.name == </span><span class="s3">&quot;__init__&quot;</span><span class="s1">:</span>
            <span class="s1">cls = self.parent.parent.scope()</span>
            <span class="s1">vararg.elts = [cls.instantiate_class()]</span>
        <span class="s2">yield </span><span class="s1">vararg</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">name == self.kwarg:</span>
        <span class="s1">kwarg = nodes.const_factory({})</span>
        <span class="s1">kwarg.parent = self</span>
        <span class="s2">yield </span><span class="s1">kwarg</span>
        <span class="s2">return</span>
    <span class="s0"># if there is a default value, yield it. And then yield Uninferable to reflect</span>
    <span class="s0"># we can't guess given argument value</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">context = contextmod.copy_context(context)</span>
        <span class="s2">yield from </span><span class="s1">self.default_value(name).infer(context)</span>
        <span class="s2">yield </span><span class="s1">util.Uninferable</span>
    <span class="s2">except </span><span class="s1">exceptions.NoDefault:</span>
        <span class="s2">yield </span><span class="s1">util.Uninferable</span>


<span class="s2">def </span><span class="s1">arguments_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">context.callcontext:</span>
        <span class="s0"># reset call context/name</span>
        <span class="s1">callcontext = context.callcontext</span>
        <span class="s1">context = contextmod.copy_context(context)</span>
        <span class="s1">context.callcontext = </span><span class="s2">None</span>
        <span class="s1">args = arguments.CallSite(callcontext, context=context)</span>
        <span class="s2">return </span><span class="s1">args.infer_argument(self.parent, node.name, context)</span>
    <span class="s2">return </span><span class="s1">_arguments_infer_argname(self, node.name, context)</span>


<span class="s1">nodes.Arguments.assigned_stmts = arguments_assigned_stmts</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">assign_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if not </span><span class="s1">assign_path:</span>
        <span class="s2">yield </span><span class="s1">self.value</span>
        <span class="s2">return None</span>
    <span class="s2">yield from </span><span class="s1">_resolve_assignment_parts(</span>
        <span class="s1">self.value.infer(context), assign_path, context</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">dict(node=self, unknown=node, assign_path=assign_path, context=context)</span>


<span class="s2">def </span><span class="s1">assign_annassigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">for </span><span class="s1">inferred </span><span class="s2">in </span><span class="s1">assign_assigned_stmts(self, node, context, assign_path):</span>
        <span class="s2">if </span><span class="s1">inferred </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">inferred</span>


<span class="s1">nodes.Assign.assigned_stmts = assign_assigned_stmts</span>
<span class="s1">nodes.AnnAssign.assigned_stmts = assign_annassigned_stmts</span>
<span class="s1">nodes.AugAssign.assigned_stmts = assign_assigned_stmts</span>


<span class="s2">def </span><span class="s1">_resolve_assignment_parts(parts, assign_path, context):</span>
    <span class="s0">&quot;&quot;&quot;recursive function to resolve multiple assignments&quot;&quot;&quot;</span>
    <span class="s1">assign_path = assign_path[:]</span>
    <span class="s1">index = assign_path.pop(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">parts:</span>
        <span class="s1">assigned = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(part, nodes.Dict):</span>
            <span class="s0"># A dictionary in an iterating context</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">assigned, _ = part.items[index]</span>
            <span class="s2">except </span><span class="s1">IndexError:</span>
                <span class="s2">return</span>

        <span class="s2">elif </span><span class="s1">hasattr(part, </span><span class="s3">&quot;getitem&quot;</span><span class="s1">):</span>
            <span class="s1">index_node = nodes.Const(index)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">assigned = part.getitem(index_node, context)</span>
            <span class="s2">except </span><span class="s1">(exceptions.AstroidTypeError, exceptions.AstroidIndexError):</span>
                <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">assigned:</span>
            <span class="s2">return</span>

        <span class="s2">if not </span><span class="s1">assign_path:</span>
            <span class="s0"># we achieved to resolved the assignment path, don't infer the</span>
            <span class="s0"># last part</span>
            <span class="s2">yield </span><span class="s1">assigned</span>
        <span class="s2">elif </span><span class="s1">assigned </span><span class="s2">is </span><span class="s1">util.Uninferable:</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># we are not yet on the last part of the path search on each</span>
            <span class="s0"># possibly inferred value</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">yield from </span><span class="s1">_resolve_assignment_parts(</span>
                    <span class="s1">assigned.infer(context), assign_path, context</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
                <span class="s2">return</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">excepthandler_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">for </span><span class="s1">assigned </span><span class="s2">in </span><span class="s1">node_classes.unpack_infer(self.type):</span>
        <span class="s2">if </span><span class="s1">isinstance(assigned, nodes.ClassDef):</span>
            <span class="s1">assigned = objects.ExceptionInstance(assigned)</span>

        <span class="s2">yield </span><span class="s1">assigned</span>
    <span class="s2">return </span><span class="s1">dict(node=self, unknown=node, assign_path=assign_path, context=context)</span>


<span class="s1">nodes.ExceptHandler.assigned_stmts = excepthandler_assigned_stmts</span>


<span class="s2">def </span><span class="s1">_infer_context_manager(self, mgr, context):</span>
    <span class="s1">inferred = next(mgr.infer(context=context))</span>
    <span class="s2">if </span><span class="s1">isinstance(inferred, bases.Generator):</span>
        <span class="s0"># Check if it is decorated with contextlib.contextmanager.</span>
        <span class="s1">func = inferred.parent</span>
        <span class="s2">if not </span><span class="s1">func.decorators:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s3">&quot;No decorators found on inferred generator %s&quot;</span><span class="s1">, node=func</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">decorator_node </span><span class="s2">in </span><span class="s1">func.decorators.nodes:</span>
            <span class="s1">decorator = next(decorator_node.infer(context=context))</span>
            <span class="s2">if </span><span class="s1">isinstance(decorator, nodes.FunctionDef):</span>
                <span class="s2">if </span><span class="s1">decorator.qname() == _CONTEXTLIB_MGR:</span>
                    <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># It doesn't interest us.</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(node=func)</span>

        <span class="s0"># Get the first yield point. If it has multiple yields,</span>
        <span class="s0"># then a RuntimeError will be raised.</span>

        <span class="s1">possible_yield_points = func.nodes_of_class(nodes.Yield)</span>
        <span class="s0"># Ignore yields in nested functions</span>
        <span class="s1">yield_point = next(</span>
            <span class="s1">(node </span><span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">possible_yield_points </span><span class="s2">if </span><span class="s1">node.scope() == func), </span><span class="s2">None</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">yield_point:</span>
            <span class="s2">if not </span><span class="s1">yield_point.value:</span>
                <span class="s1">const = nodes.Const(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s1">const.parent = yield_point</span>
                <span class="s1">const.lineno = yield_point.lineno</span>
                <span class="s2">yield </span><span class="s1">const</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">yield from </span><span class="s1">yield_point.value.infer(context=context)</span>
    <span class="s2">elif </span><span class="s1">isinstance(inferred, bases.Instance):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">enter = next(inferred.igetattr(</span><span class="s3">&quot;__enter__&quot;</span><span class="s1">, context=context))</span>
        <span class="s2">except </span><span class="s1">(exceptions.InferenceError, exceptions.AttributeInferenceError) </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(node=inferred) </span><span class="s2">from </span><span class="s1">exc</span>
        <span class="s2">if not </span><span class="s1">isinstance(enter, bases.BoundMethod):</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(node=enter)</span>
        <span class="s2">yield from </span><span class="s1">enter.infer_call_result(self, context)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">exceptions.InferenceError(node=mgr)</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">with_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Infer names and other nodes from a *with* statement. 
 
    This enables only inference for name binding in a *with* statement. 
    For instance, in the following code, inferring `func` will return 
    the `ContextManager` class, not whatever ``__enter__`` returns. 
    We are doing this intentionally, because we consider that the context 
    manager result is whatever __enter__ returns and what it is binded 
    using the ``as`` keyword. 
 
        class ContextManager(object): 
            def __enter__(self): 
                return 42 
        with ContextManager() as f: 
            pass 
 
        # ContextManager().infer() will return ContextManager 
        # f.infer() will return 42. 
 
    Arguments: 
        self: nodes.With 
        node: The target of the assignment, `as (a, b)` in `with foo as (a, b)`. 
        context: Inference context used for caching already inferred objects 
        assign_path: 
            A list of indices, where each index specifies what item to fetch from 
            the inference results. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">mgr = next(mgr </span><span class="s2">for </span><span class="s1">(mgr, vars) </span><span class="s2">in </span><span class="s1">self.items </span><span class="s2">if </span><span class="s1">vars == node)</span>
    <span class="s2">except </span><span class="s1">StopIteration:</span>
        <span class="s2">return None</span>
    <span class="s2">if </span><span class="s1">assign_path </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">yield from </span><span class="s1">_infer_context_manager(self, mgr, context)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">_infer_context_manager(self, mgr, context):</span>
            <span class="s0"># Walk the assign_path and get the item at the final index.</span>
            <span class="s1">obj = result</span>
            <span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">assign_path:</span>
                <span class="s2">if not </span><span class="s1">hasattr(obj, </span><span class="s3">&quot;elts&quot;</span><span class="s1">):</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;Wrong type ({targets!r}) for {node!r} assignment&quot;</span><span class="s1">,</span>
                        <span class="s1">node=self,</span>
                        <span class="s1">targets=node,</span>
                        <span class="s1">assign_path=assign_path,</span>
                        <span class="s1">context=context,</span>
                    <span class="s1">)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">obj = obj.elts[index]</span>
                <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">exc:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;Tried to infer a nonexistent target with index {index} &quot;</span>
                        <span class="s3">&quot;in {node!r}.&quot;</span><span class="s1">,</span>
                        <span class="s1">node=self,</span>
                        <span class="s1">targets=node,</span>
                        <span class="s1">assign_path=assign_path,</span>
                        <span class="s1">context=context,</span>
                    <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
                <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">exc:</span>
                    <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                        <span class="s3">&quot;Tried to unpack a non-iterable value &quot; &quot;in {node!r}.&quot;</span><span class="s1">,</span>
                        <span class="s1">node=self,</span>
                        <span class="s1">targets=node,</span>
                        <span class="s1">assign_path=assign_path,</span>
                        <span class="s1">context=context,</span>
                    <span class="s1">) </span><span class="s2">from </span><span class="s1">exc</span>
            <span class="s2">yield </span><span class="s1">obj</span>
    <span class="s2">return </span><span class="s1">dict(node=self, unknown=node, assign_path=assign_path, context=context)</span>


<span class="s1">nodes.With.assigned_stmts = with_assigned_stmts</span>


<span class="s1">@decorators.raise_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">named_expr_assigned_stmts(self, node, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Infer names and other nodes from an assignment expression&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">self.target == node:</span>
        <span class="s2">yield from </span><span class="s1">self.value.infer(context=context)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
            <span class="s3">&quot;Cannot infer NamedExpr node {node!r}&quot;</span><span class="s1">,</span>
            <span class="s1">node=self,</span>
            <span class="s1">assign_path=assign_path,</span>
            <span class="s1">context=context,</span>
        <span class="s1">)</span>


<span class="s1">nodes.NamedExpr.assigned_stmts = named_expr_assigned_stmts</span>


<span class="s1">@decorators.yes_if_nothing_inferred</span>
<span class="s2">def </span><span class="s1">starred_assigned_stmts(self, node=</span><span class="s2">None</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">, assign_path=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Arguments: 
        self: nodes.Starred 
        node: a node related to the current underlying Node. 
        context: Inference context used for caching already inferred objects 
        assign_path: 
            A list of indices, where each index specifies what item to fetch from 
            the inference results. 
    &quot;&quot;&quot;</span>
    <span class="s0"># pylint: disable=too-many-locals,too-many-statements</span>
    <span class="s2">def </span><span class="s1">_determine_starred_iteration_lookups(starred, target, lookups):</span>
        <span class="s0"># Determine the lookups for the rhs of the iteration</span>
        <span class="s1">itered = target.itered()</span>
        <span class="s2">for </span><span class="s1">index, element </span><span class="s2">in </span><span class="s1">enumerate(itered):</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">isinstance(element, nodes.Starred)</span>
                <span class="s2">and </span><span class="s1">element.value.name == starred.value.name</span>
            <span class="s1">):</span>
                <span class="s1">lookups.append((index, len(itered)))</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">isinstance(element, nodes.Tuple):</span>
                <span class="s1">lookups.append((index, len(element.itered())))</span>
                <span class="s1">_determine_starred_iteration_lookups(starred, element, lookups)</span>

    <span class="s1">stmt = self.statement()</span>
    <span class="s2">if not </span><span class="s1">isinstance(stmt, (nodes.Assign, nodes.For)):</span>
        <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
            <span class="s3">&quot;Statement {stmt!r} enclosing {node!r} &quot; &quot;must be an Assign or For node.&quot;</span><span class="s1">,</span>
            <span class="s1">node=self,</span>
            <span class="s1">stmt=stmt,</span>
            <span class="s1">unknown=node,</span>
            <span class="s1">context=context,</span>
        <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">context </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">context = contextmod.InferenceContext()</span>

    <span class="s2">if </span><span class="s1">isinstance(stmt, nodes.Assign):</span>
        <span class="s1">value = stmt.value</span>
        <span class="s1">lhs = stmt.targets[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">sum(</span><span class="s4">1 </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">lhs.nodes_of_class(nodes.Starred)) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s3">&quot;Too many starred arguments in the &quot; &quot; assignment targets {lhs!r}.&quot;</span><span class="s1">,</span>
                <span class="s1">node=self,</span>
                <span class="s1">targets=lhs,</span>
                <span class="s1">unknown=node,</span>
                <span class="s1">context=context,</span>
            <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">rhs = next(value.infer(context))</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">rhs </span><span class="s2">is </span><span class="s1">util.Uninferable </span><span class="s2">or not </span><span class="s1">hasattr(rhs, </span><span class="s3">&quot;itered&quot;</span><span class="s1">):</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">elts = collections.deque(rhs.itered())</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>

        <span class="s0"># Unpack iteratively the values from the rhs of the assignment,</span>
        <span class="s0"># until the find the starred node. What will remain will</span>
        <span class="s0"># be the list of values which the Starred node will represent</span>
        <span class="s0"># This is done in two steps, from left to right to remove</span>
        <span class="s0"># anything before the starred node and from right to left</span>
        <span class="s0"># to remove anything after the starred node.</span>

        <span class="s2">for </span><span class="s1">index, left_node </span><span class="s2">in </span><span class="s1">enumerate(lhs.elts):</span>
            <span class="s2">if not </span><span class="s1">isinstance(left_node, nodes.Starred):</span>
                <span class="s2">if not </span><span class="s1">elts:</span>
                    <span class="s2">break</span>
                <span class="s1">elts.popleft()</span>
                <span class="s2">continue</span>
            <span class="s1">lhs_elts = collections.deque(reversed(lhs.elts[index:]))</span>
            <span class="s2">for </span><span class="s1">right_node </span><span class="s2">in </span><span class="s1">lhs_elts:</span>
                <span class="s2">if not </span><span class="s1">isinstance(right_node, nodes.Starred):</span>
                    <span class="s2">if not </span><span class="s1">elts:</span>
                        <span class="s2">break</span>
                    <span class="s1">elts.pop()</span>
                    <span class="s2">continue</span>

                <span class="s0"># We're done unpacking.</span>
                <span class="s1">packed = nodes.List(</span>
                    <span class="s1">ctx=Store, parent=self, lineno=lhs.lineno, col_offset=lhs.col_offset</span>
                <span class="s1">)</span>
                <span class="s1">packed.postinit(elts=list(elts))</span>
                <span class="s2">yield </span><span class="s1">packed</span>
                <span class="s2">break</span>

    <span class="s2">if </span><span class="s1">isinstance(stmt, nodes.For):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">inferred_iterable = next(stmt.iter.infer(context=context))</span>
        <span class="s2">except </span><span class="s1">exceptions.InferenceError:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">inferred_iterable </span><span class="s2">is </span><span class="s1">util.Uninferable </span><span class="s2">or not </span><span class="s1">hasattr(</span>
            <span class="s1">inferred_iterable, </span><span class="s3">&quot;itered&quot;</span>
        <span class="s1">):</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">itered = inferred_iterable.itered()</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">yield </span><span class="s1">util.Uninferable</span>
            <span class="s2">return</span>

        <span class="s1">target = stmt.target</span>

        <span class="s2">if not </span><span class="s1">isinstance(target, nodes.Tuple):</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s3">&quot;Could not make sense of this, the target must be a tuple&quot;</span><span class="s1">,</span>
                <span class="s1">context=context,</span>
            <span class="s1">)</span>

        <span class="s1">lookups = []</span>
        <span class="s1">_determine_starred_iteration_lookups(self, target, lookups)</span>
        <span class="s2">if not </span><span class="s1">lookups:</span>
            <span class="s2">raise </span><span class="s1">exceptions.InferenceError(</span>
                <span class="s3">&quot;Could not make sense of this, needs at least a lookup&quot;</span><span class="s1">, context=context</span>
            <span class="s1">)</span>

        <span class="s0"># Make the last lookup a slice, since that what we want for a Starred node</span>
        <span class="s1">last_element_index, last_element_length = lookups[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">is_starred_last = last_element_index == (last_element_length - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">lookup_slice = slice(</span>
            <span class="s1">last_element_index,</span>
            <span class="s2">None if </span><span class="s1">is_starred_last </span><span class="s2">else </span><span class="s1">(last_element_length - last_element_index),</span>
        <span class="s1">)</span>
        <span class="s1">lookups[-</span><span class="s4">1</span><span class="s1">] = lookup_slice</span>

        <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">itered:</span>

            <span class="s0"># We probably want to infer the potential values *for each* element in an</span>
            <span class="s0"># iterable, but we can't infer a list of all values, when only a list of</span>
            <span class="s0"># step values are expected:</span>
            <span class="s0">#</span>
            <span class="s0"># for a, *b in [...]:</span>
            <span class="s0">#   b</span>
            <span class="s0">#</span>
            <span class="s0"># *b* should now point to just the elements at that particular iteration step,</span>
            <span class="s0"># which astroid can't know about.</span>

            <span class="s1">found_element = </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">lookup </span><span class="s2">in </span><span class="s1">lookups:</span>
                <span class="s2">if not </span><span class="s1">hasattr(element, </span><span class="s3">&quot;itered&quot;</span><span class="s1">):</span>
                    <span class="s2">break</span>
                <span class="s2">if not </span><span class="s1">isinstance(lookup, slice):</span>
                    <span class="s0"># Grab just the index, not the whole length</span>
                    <span class="s1">lookup = lookup[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">itered_inner_element = element.itered()</span>
                    <span class="s1">element = itered_inner_element[lookup]</span>
                <span class="s2">except </span><span class="s1">IndexError:</span>
                    <span class="s2">break</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s0"># Most likely the itered() call failed, cannot make sense of this</span>
                    <span class="s2">yield </span><span class="s1">util.Uninferable</span>
                    <span class="s2">return</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">found_element = element</span>

            <span class="s1">unpacked = nodes.List(</span>
                <span class="s1">ctx=Store, parent=self, lineno=self.lineno, col_offset=self.col_offset</span>
            <span class="s1">)</span>
            <span class="s1">unpacked.postinit(elts=found_element </span><span class="s2">or </span><span class="s1">[])</span>
            <span class="s2">yield </span><span class="s1">unpacked</span>
            <span class="s2">return</span>

        <span class="s2">yield </span><span class="s1">util.Uninferable</span>


<span class="s1">nodes.Starred.assigned_stmts = starred_assigned_stmts</span>
</pre>
</body>
</html>