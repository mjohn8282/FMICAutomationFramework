<html>
<head>
<title>control.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #abb2bf;}
.s2 { color: #c678dd;}
.s3 { color: #98c379;}
.s4 { color: #d19a66;}
.s5 { color: #56b6c2;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
control.py</font>
</center></td></tr></table>
<pre><span class="s0"># Licensed under the Apache License: http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0"># For details: https://github.com/nedbat/coveragepy/blob/master/NOTICE.txt</span>

<span class="s0">&quot;&quot;&quot;Core control stuff for coverage.py.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">atexit</span>
<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">os.path</span>
<span class="s2">import </span><span class="s1">platform</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>

<span class="s2">from </span><span class="s1">coverage </span><span class="s2">import </span><span class="s1">env</span>
<span class="s2">from </span><span class="s1">coverage.annotate </span><span class="s2">import </span><span class="s1">AnnotateReporter</span>
<span class="s2">from </span><span class="s1">coverage.backward </span><span class="s2">import </span><span class="s1">string_class, iitems</span>
<span class="s2">from </span><span class="s1">coverage.collector </span><span class="s2">import </span><span class="s1">Collector, CTracer</span>
<span class="s2">from </span><span class="s1">coverage.config </span><span class="s2">import </span><span class="s1">read_coverage_config</span>
<span class="s2">from </span><span class="s1">coverage.context </span><span class="s2">import </span><span class="s1">should_start_context_test_function, combine_context_switchers</span>
<span class="s2">from </span><span class="s1">coverage.data </span><span class="s2">import </span><span class="s1">CoverageData, combine_parallel_data</span>
<span class="s2">from </span><span class="s1">coverage.debug </span><span class="s2">import </span><span class="s1">DebugControl, short_stack, write_formatted_info</span>
<span class="s2">from </span><span class="s1">coverage.disposition </span><span class="s2">import </span><span class="s1">disposition_debug_msg</span>
<span class="s2">from </span><span class="s1">coverage.files </span><span class="s2">import </span><span class="s1">PathAliases, abs_file, relative_filename, set_relative_directory</span>
<span class="s2">from </span><span class="s1">coverage.html </span><span class="s2">import </span><span class="s1">HtmlReporter</span>
<span class="s2">from </span><span class="s1">coverage.inorout </span><span class="s2">import </span><span class="s1">InOrOut</span>
<span class="s2">from </span><span class="s1">coverage.jsonreport </span><span class="s2">import </span><span class="s1">JsonReporter</span>
<span class="s2">from </span><span class="s1">coverage.misc </span><span class="s2">import </span><span class="s1">CoverageException, bool_or_none, join_regex</span>
<span class="s2">from </span><span class="s1">coverage.misc </span><span class="s2">import </span><span class="s1">DefaultValue, ensure_dir_for_file, isolate_module</span>
<span class="s2">from </span><span class="s1">coverage.plugin </span><span class="s2">import </span><span class="s1">FileReporter</span>
<span class="s2">from </span><span class="s1">coverage.plugin_support </span><span class="s2">import </span><span class="s1">Plugins</span>
<span class="s2">from </span><span class="s1">coverage.python </span><span class="s2">import </span><span class="s1">PythonFileReporter</span>
<span class="s2">from </span><span class="s1">coverage.report </span><span class="s2">import </span><span class="s1">render_report</span>
<span class="s2">from </span><span class="s1">coverage.results </span><span class="s2">import </span><span class="s1">Analysis, Numbers</span>
<span class="s2">from </span><span class="s1">coverage.summary </span><span class="s2">import </span><span class="s1">SummaryReporter</span>
<span class="s2">from </span><span class="s1">coverage.xmlreport </span><span class="s2">import </span><span class="s1">XmlReporter</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">coverage.multiproc </span><span class="s2">import </span><span class="s1">patch_multiprocessing</span>
<span class="s2">except </span><span class="s1">ImportError:                                         </span><span class="s0"># pragma: only jython</span>
    <span class="s0"># Jython has no multiprocessing module.</span>
    <span class="s1">patch_multiprocessing = </span><span class="s2">None</span>

<span class="s1">os = isolate_module(os)</span>

<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">override_config(cov, **kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Temporarily tweak the configuration of `cov`. 
 
    The arguments are applied to `cov.config` with the `from_args` method. 
    At the end of the with-statement, the old configuration is restored. 
    &quot;&quot;&quot;</span>
    <span class="s1">original_config = cov.config</span>
    <span class="s1">cov.config = cov.config.copy()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">cov.config.from_args(**kwargs)</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">cov.config = original_config</span>


<span class="s1">_DEFAULT_DATAFILE = DefaultValue(</span><span class="s3">&quot;MISSING&quot;</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">Coverage(object):</span>
    <span class="s0">&quot;&quot;&quot;Programmatic access to coverage.py. 
 
    To use:: 
 
        from coverage import Coverage 
 
        cov = Coverage() 
        cov.start() 
        #.. call your code .. 
        cov.stop() 
        cov.html_report(directory='covhtml') 
 
    Note: in keeping with Python custom, names starting with underscore are 
    not part of the public API. They might stop working at any point.  Please 
    limit yourself to documented methods to avoid problems. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># The stack of started Coverage instances.</span>
    <span class="s1">_instances = []</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">current(cls):</span>
        <span class="s0">&quot;&quot;&quot;Get the latest started `Coverage` instance, if any. 
 
        Returns: a `Coverage` instance, or None. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">cls._instances:</span>
            <span class="s2">return </span><span class="s1">cls._instances[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self, data_file=_DEFAULT_DATAFILE, data_suffix=</span><span class="s2">None</span><span class="s1">, cover_pylib=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">auto_data=</span><span class="s2">False</span><span class="s1">, timid=</span><span class="s2">None</span><span class="s1">, branch=</span><span class="s2">None</span><span class="s1">, config_file=</span><span class="s2">True</span><span class="s1">,</span>
        <span class="s1">source=</span><span class="s2">None</span><span class="s1">, source_pkgs=</span><span class="s2">None</span><span class="s1">, omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, debug=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">concurrency=</span><span class="s2">None</span><span class="s1">, check_preimported=</span><span class="s2">False</span><span class="s1">, context=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):  </span><span class="s0"># pylint: disable=too-many-arguments</span>
        <span class="s0">&quot;&quot;&quot; 
        Many of these arguments duplicate and override values that can be 
        provided in a configuration file.  Parameters that are missing here 
        will use values from the config file. 
 
        `data_file` is the base name of the data file to use. The config value 
        defaults to &quot;.coverage&quot;.  None can be provided to prevent writing a data 
        file.  `data_suffix` is appended (with a dot) to `data_file` to create 
        the final file name.  If `data_suffix` is simply True, then a suffix is 
        created with the machine and process identity included. 
 
        `cover_pylib` is a boolean determining whether Python code installed 
        with the Python interpreter is measured.  This includes the Python 
        standard library and any packages installed with the interpreter. 
 
        If `auto_data` is true, then any existing data file will be read when 
        coverage measurement starts, and data will be saved automatically when 
        measurement stops. 
 
        If `timid` is true, then a slower and simpler trace function will be 
        used.  This is important for some environments where manipulation of 
        tracing functions breaks the faster trace function. 
 
        If `branch` is true, then branch coverage will be measured in addition 
        to the usual statement coverage. 
 
        `config_file` determines what configuration file to read: 
 
            * If it is &quot;.coveragerc&quot;, it is interpreted as if it were True, 
              for backward compatibility. 
 
            * If it is a string, it is the name of the file to read.  If the 
              file can't be read, it is an error. 
 
            * If it is True, then a few standard files names are tried 
              (&quot;.coveragerc&quot;, &quot;setup.cfg&quot;, &quot;tox.ini&quot;).  It is not an error for 
              these files to not be found. 
 
            * If it is False, then no configuration file is read. 
 
        `source` is a list of file paths or package names.  Only code located 
        in the trees indicated by the file paths or package names will be 
        measured. 
 
        `source_pkgs` is a list of package names. It works the same as 
        `source`, but can be used to name packages where the name can also be 
        interpreted as a file path. 
 
        `include` and `omit` are lists of file name patterns. Files that match 
        `include` will be measured, files that match `omit` will not.  Each 
        will also accept a single string argument. 
 
        `debug` is a list of strings indicating what debugging information is 
        desired. 
 
        `concurrency` is a string indicating the concurrency library being used 
        in the measured code.  Without this, coverage.py will get incorrect 
        results if these libraries are in use.  Valid strings are &quot;greenlet&quot;, 
        &quot;eventlet&quot;, &quot;gevent&quot;, &quot;multiprocessing&quot;, or &quot;thread&quot; (the default). 
        This can also be a list of these strings. 
 
        If `check_preimported` is true, then when coverage is started, the 
        already-imported files will be checked to see if they should be 
        measured by coverage.  Importing measured files before coverage is 
        started can mean that code is missed. 
 
        `context` is a string to use as the :ref:`static context 
        &lt;static_contexts&gt;` label for collected data. 
 
        .. versionadded:: 4.0 
            The `concurrency` parameter. 
 
        .. versionadded:: 4.2 
            The `concurrency` parameter can now be a list of strings. 
 
        .. versionadded:: 5.0 
            The `check_preimported` and `context` parameters. 
 
        .. versionadded:: 5.3 
            The `source_pkgs` parameter. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># data_file=None means no disk file at all. data_file missing means</span>
        <span class="s0"># use the value from the config file.</span>
        <span class="s1">self._no_disk = data_file </span><span class="s2">is None</span>
        <span class="s2">if </span><span class="s1">data_file </span><span class="s2">is </span><span class="s1">_DEFAULT_DATAFILE:</span>
            <span class="s1">data_file = </span><span class="s2">None</span>

        <span class="s0"># Build our configuration from a number of sources.</span>
        <span class="s1">self.config = read_coverage_config(</span>
            <span class="s1">config_file=config_file,</span>
            <span class="s1">data_file=data_file, cover_pylib=cover_pylib, timid=timid,</span>
            <span class="s1">branch=branch, parallel=bool_or_none(data_suffix),</span>
            <span class="s1">source=source, source_pkgs=source_pkgs, run_omit=omit, run_include=include, debug=debug,</span>
            <span class="s1">report_omit=omit, report_include=include,</span>
            <span class="s1">concurrency=concurrency, context=context,</span>
            <span class="s1">)</span>

        <span class="s0"># This is injectable by tests.</span>
        <span class="s1">self._debug_file = </span><span class="s2">None</span>

        <span class="s1">self._auto_load = self._auto_save = auto_data</span>
        <span class="s1">self._data_suffix_specified = data_suffix</span>

        <span class="s0"># Is it ok for no data to be collected?</span>
        <span class="s1">self._warn_no_data = </span><span class="s2">True</span>
        <span class="s1">self._warn_unimported_source = </span><span class="s2">True</span>
        <span class="s1">self._warn_preimported_source = check_preimported</span>
        <span class="s1">self._no_warn_slugs = </span><span class="s2">None</span>

        <span class="s0"># A record of all the warnings that have been issued.</span>
        <span class="s1">self._warnings = []</span>

        <span class="s0"># Other instance attributes, set later.</span>
        <span class="s1">self._data = self._collector = </span><span class="s2">None</span>
        <span class="s1">self._plugins = </span><span class="s2">None</span>
        <span class="s1">self._inorout = </span><span class="s2">None</span>
        <span class="s1">self._data_suffix = self._run_suffix = </span><span class="s2">None</span>
        <span class="s1">self._exclude_re = </span><span class="s2">None</span>
        <span class="s1">self._debug = </span><span class="s2">None</span>
        <span class="s1">self._file_mapper = </span><span class="s2">None</span>

        <span class="s0"># State machine variables:</span>
        <span class="s0"># Have we initialized everything?</span>
        <span class="s1">self._inited = </span><span class="s2">False</span>
        <span class="s1">self._inited_for_start = </span><span class="s2">False</span>
        <span class="s0"># Have we started collecting and not stopped it?</span>
        <span class="s1">self._started = </span><span class="s2">False</span>
        <span class="s0"># Should we write the debug output?</span>
        <span class="s1">self._should_write_debug = </span><span class="s2">True</span>

        <span class="s0"># If we have sub-process measurement happening automatically, then we</span>
        <span class="s0"># want any explicit creation of a Coverage object to mean, this process</span>
        <span class="s0"># is already coverage-aware, so don't auto-measure it.  By now, the</span>
        <span class="s0"># auto-creation of a Coverage object has already happened.  But we can</span>
        <span class="s0"># find it and tell it not to save its data.</span>
        <span class="s2">if not </span><span class="s1">env.METACOV:</span>
            <span class="s1">_prevent_sub_process_measurement()</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s0">&quot;&quot;&quot;Set all the initial state. 
 
        This is called by the public methods to initialize state. This lets us 
        construct a :class:`Coverage` object, then tweak its state before this 
        function is called. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._inited:</span>
            <span class="s2">return</span>

        <span class="s1">self._inited = </span><span class="s2">True</span>

        <span class="s0"># Create and configure the debugging controller. COVERAGE_DEBUG_FILE</span>
        <span class="s0"># is an environment variable, the name of a file to append debug logs</span>
        <span class="s0"># to.</span>
        <span class="s1">self._debug = DebugControl(self.config.debug, self._debug_file)</span>

        <span class="s2">if </span><span class="s3">&quot;multiprocessing&quot; </span><span class="s2">in </span><span class="s1">(self.config.concurrency </span><span class="s2">or </span><span class="s1">()):</span>
            <span class="s0"># Multi-processing uses parallel for the subprocesses, so also use</span>
            <span class="s0"># it for the main process.</span>
            <span class="s1">self.config.parallel = </span><span class="s2">True</span>

        <span class="s0"># _exclude_re is a dict that maps exclusion list names to compiled regexes.</span>
        <span class="s1">self._exclude_re = {}</span>

        <span class="s1">set_relative_directory()</span>
        <span class="s1">self._file_mapper = relative_filename </span><span class="s2">if </span><span class="s1">self.config.relative_files </span><span class="s2">else </span><span class="s1">abs_file</span>

        <span class="s0"># Load plugins</span>
        <span class="s1">self._plugins = Plugins.load_plugins(self.config.plugins, self.config, self._debug)</span>

        <span class="s0"># Run configuring plugins.</span>
        <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins.configurers:</span>
            <span class="s0"># We need an object with set_option and get_option. Either self or</span>
            <span class="s0"># self.config will do. Choosing randomly stops people from doing</span>
            <span class="s0"># other things with those objects, against the public API.  Yes,</span>
            <span class="s0"># this is a bit childish. :)</span>
            <span class="s1">plugin.configure([self, self.config][int(time.time()) % </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_post_init(self):</span>
        <span class="s0">&quot;&quot;&quot;Stuff to do after everything is initialized.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._should_write_debug:</span>
            <span class="s1">self._should_write_debug = </span><span class="s2">False</span>
            <span class="s1">self._write_startup_debug()</span>

        <span class="s0"># '[run] _crash' will raise an exception if the value is close by in</span>
        <span class="s0"># the call stack, for testing error handling.</span>
        <span class="s2">if </span><span class="s1">self.config._crash </span><span class="s2">and </span><span class="s1">self.config._crash </span><span class="s2">in </span><span class="s1">short_stack(limit=</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">Exception(</span><span class="s3">&quot;Crashing because called by {}&quot;</span><span class="s1">.format(self.config._crash))</span>

    <span class="s2">def </span><span class="s1">_write_startup_debug(self):</span>
        <span class="s0">&quot;&quot;&quot;Write out debug info at startup if needed.&quot;&quot;&quot;</span>
        <span class="s1">wrote_any = </span><span class="s2">False</span>
        <span class="s2">with </span><span class="s1">self._debug.without_callers():</span>
            <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'config'</span><span class="s1">):</span>
                <span class="s1">config_info = sorted(self.config.__dict__.items())</span>
                <span class="s1">config_info = [(k, v) </span><span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">config_info </span><span class="s2">if not </span><span class="s1">k.startswith(</span><span class="s3">'_'</span><span class="s1">)]</span>
                <span class="s1">write_formatted_info(self._debug, </span><span class="s3">&quot;config&quot;</span><span class="s1">, config_info)</span>
                <span class="s1">wrote_any = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'sys'</span><span class="s1">):</span>
                <span class="s1">write_formatted_info(self._debug, </span><span class="s3">&quot;sys&quot;</span><span class="s1">, self.sys_info())</span>
                <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins:</span>
                    <span class="s1">header = </span><span class="s3">&quot;sys: &quot; </span><span class="s1">+ plugin._coverage_plugin_name</span>
                    <span class="s1">info = plugin.sys_info()</span>
                    <span class="s1">write_formatted_info(self._debug, header, info)</span>
                <span class="s1">wrote_any = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">wrote_any:</span>
            <span class="s1">write_formatted_info(self._debug, </span><span class="s3">&quot;end&quot;</span><span class="s1">, ())</span>

    <span class="s2">def </span><span class="s1">_should_trace(self, filename, frame):</span>
        <span class="s0">&quot;&quot;&quot;Decide whether to trace execution in `filename`. 
 
        Calls `_should_trace_internal`, and returns the FileDisposition. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">disp = self._inorout.should_trace(filename, frame)</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'trace'</span><span class="s1">):</span>
            <span class="s1">self._debug.write(disposition_debug_msg(disp))</span>
        <span class="s2">return </span><span class="s1">disp</span>

    <span class="s2">def </span><span class="s1">_check_include_omit_etc(self, filename, frame):</span>
        <span class="s0">&quot;&quot;&quot;Check a file name against the include/omit/etc, rules, verbosely. 
 
        Returns a boolean: True if the file should be traced, False if not. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">reason = self._inorout.check_include_omit_etc(filename, frame)</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'trace'</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">reason:</span>
                <span class="s1">msg = </span><span class="s3">&quot;Including %r&quot; </span><span class="s1">% (filename,)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;Not including %r: %s&quot; </span><span class="s1">% (filename, reason)</span>
            <span class="s1">self._debug.write(msg)</span>

        <span class="s2">return not </span><span class="s1">reason</span>

    <span class="s2">def </span><span class="s1">_warn(self, msg, slug=</span><span class="s2">None</span><span class="s1">, once=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Use `msg` as a warning. 
 
        For warning suppression, use `slug` as the shorthand. 
 
        If `once` is true, only show this warning once (determined by the 
        slug.) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._no_warn_slugs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._no_warn_slugs = list(self.config.disable_warnings)</span>

        <span class="s2">if </span><span class="s1">slug </span><span class="s2">in </span><span class="s1">self._no_warn_slugs:</span>
            <span class="s0"># Don't issue the warning</span>
            <span class="s2">return</span>

        <span class="s1">self._warnings.append(msg)</span>
        <span class="s2">if </span><span class="s1">slug:</span>
            <span class="s1">msg = </span><span class="s3">&quot;%s (%s)&quot; </span><span class="s1">% (msg, slug)</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'pid'</span><span class="s1">):</span>
            <span class="s1">msg = </span><span class="s3">&quot;[%d] %s&quot; </span><span class="s1">% (os.getpid(), msg)</span>
        <span class="s1">sys.stderr.write(</span><span class="s3">&quot;Coverage.py warning: %s</span><span class="s5">\n</span><span class="s3">&quot; </span><span class="s1">% msg)</span>

        <span class="s2">if </span><span class="s1">once:</span>
            <span class="s1">self._no_warn_slugs.append(slug)</span>

    <span class="s2">def </span><span class="s1">get_option(self, option_name):</span>
        <span class="s0">&quot;&quot;&quot;Get an option from the configuration. 
 
        `option_name` is a colon-separated string indicating the section and 
        option name.  For example, the ``branch`` option in the ``[run]`` 
        section of the config file would be indicated with `&quot;run:branch&quot;`. 
 
        Returns the value of the option.  The type depends on the option 
        selected. 
 
        As a special case, an `option_name` of ``&quot;paths&quot;`` will return an 
        OrderedDict with the entire ``[paths]`` section value. 
 
        .. versionadded:: 4.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.config.get_option(option_name)</span>

    <span class="s2">def </span><span class="s1">set_option(self, option_name, value):</span>
        <span class="s0">&quot;&quot;&quot;Set an option in the configuration. 
 
        `option_name` is a colon-separated string indicating the section and 
        option name.  For example, the ``branch`` option in the ``[run]`` 
        section of the config file would be indicated with ``&quot;run:branch&quot;``. 
 
        `value` is the new value for the option.  This should be an 
        appropriate Python value.  For example, use True for booleans, not the 
        string ``&quot;True&quot;``. 
 
        As an example, calling:: 
 
            cov.set_option(&quot;run:branch&quot;, True) 
 
        has the same effect as this configuration file:: 
 
            [run] 
            branch = True 
 
        As a special case, an `option_name` of ``&quot;paths&quot;`` will replace the 
        entire ``[paths]`` section.  The value should be an OrderedDict. 
 
        .. versionadded:: 4.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.config.set_option(option_name, value)</span>

    <span class="s2">def </span><span class="s1">load(self):</span>
        <span class="s0">&quot;&quot;&quot;Load previously-collected coverage data from the data file.&quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s2">if </span><span class="s1">self._collector:</span>
            <span class="s1">self._collector.reset()</span>
        <span class="s1">should_skip = self.config.parallel </span><span class="s2">and not </span><span class="s1">os.path.exists(self.config.data_file)</span>
        <span class="s2">if not </span><span class="s1">should_skip:</span>
            <span class="s1">self._init_data(suffix=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self._post_init()</span>
        <span class="s2">if not </span><span class="s1">should_skip:</span>
            <span class="s1">self._data.read()</span>

    <span class="s2">def </span><span class="s1">_init_for_start(self):</span>
        <span class="s0">&quot;&quot;&quot;Initialization for start()&quot;&quot;&quot;</span>
        <span class="s0"># Construct the collector.</span>
        <span class="s1">concurrency = self.config.concurrency </span><span class="s2">or </span><span class="s1">()</span>
        <span class="s2">if </span><span class="s3">&quot;multiprocessing&quot; </span><span class="s2">in </span><span class="s1">concurrency:</span>
            <span class="s2">if not </span><span class="s1">patch_multiprocessing:</span>
                <span class="s2">raise </span><span class="s1">CoverageException(                    </span><span class="s0"># pragma: only jython</span>
                    <span class="s3">&quot;multiprocessing is not supported on this Python&quot;</span>
                <span class="s1">)</span>
            <span class="s1">patch_multiprocessing(rcfile=self.config.config_file)</span>

        <span class="s1">dycon = self.config.dynamic_context</span>
        <span class="s2">if not </span><span class="s1">dycon </span><span class="s2">or </span><span class="s1">dycon == </span><span class="s3">&quot;none&quot;</span><span class="s1">:</span>
            <span class="s1">context_switchers = []</span>
        <span class="s2">elif </span><span class="s1">dycon == </span><span class="s3">&quot;test_function&quot;</span><span class="s1">:</span>
            <span class="s1">context_switchers = [should_start_context_test_function]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span>
                <span class="s3">&quot;Don't understand dynamic_context setting: {!r}&quot;</span><span class="s1">.format(dycon)</span>
            <span class="s1">)</span>

        <span class="s1">context_switchers.extend(</span>
            <span class="s1">plugin.dynamic_context </span><span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins.context_switchers</span>
        <span class="s1">)</span>

        <span class="s1">should_start_context = combine_context_switchers(context_switchers)</span>

        <span class="s1">self._collector = Collector(</span>
            <span class="s1">should_trace=self._should_trace,</span>
            <span class="s1">check_include=self._check_include_omit_etc,</span>
            <span class="s1">should_start_context=should_start_context,</span>
            <span class="s1">file_mapper=self._file_mapper,</span>
            <span class="s1">timid=self.config.timid,</span>
            <span class="s1">branch=self.config.branch,</span>
            <span class="s1">warn=self._warn,</span>
            <span class="s1">concurrency=concurrency,</span>
            <span class="s1">)</span>

        <span class="s1">suffix = self._data_suffix_specified</span>
        <span class="s2">if </span><span class="s1">suffix </span><span class="s2">or </span><span class="s1">self.config.parallel:</span>
            <span class="s2">if not </span><span class="s1">isinstance(suffix, string_class):</span>
                <span class="s0"># if data_suffix=True, use .machinename.pid.random</span>
                <span class="s1">suffix = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">suffix = </span><span class="s2">None</span>

        <span class="s1">self._init_data(suffix)</span>

        <span class="s1">self._collector.use_data(self._data, self.config.context)</span>

        <span class="s0"># Early warning if we aren't going to be able to support plugins.</span>
        <span class="s2">if </span><span class="s1">self._plugins.file_tracers </span><span class="s2">and not </span><span class="s1">self._collector.supports_plugins:</span>
            <span class="s1">self._warn(</span>
                <span class="s3">&quot;Plugin file tracers (%s) aren't supported with %s&quot; </span><span class="s1">% (</span>
                    <span class="s3">&quot;, &quot;</span><span class="s1">.join(</span>
                        <span class="s1">plugin._coverage_plugin_name</span>
                            <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins.file_tracers</span>
                        <span class="s1">),</span>
                    <span class="s1">self._collector.tracer_name(),</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins.file_tracers:</span>
                <span class="s1">plugin._coverage_enabled = </span><span class="s2">False</span>

        <span class="s0"># Create the file classifying substructure.</span>
        <span class="s1">self._inorout = InOrOut(</span>
            <span class="s1">warn=self._warn,</span>
            <span class="s1">debug=(self._debug </span><span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">'trace'</span><span class="s1">) </span><span class="s2">else None</span><span class="s1">),</span>
        <span class="s1">)</span>
        <span class="s1">self._inorout.configure(self.config)</span>
        <span class="s1">self._inorout.plugins = self._plugins</span>
        <span class="s1">self._inorout.disp_class = self._collector.file_disposition_class</span>

        <span class="s0"># It's useful to write debug info after initing for start.</span>
        <span class="s1">self._should_write_debug = </span><span class="s2">True</span>

        <span class="s1">atexit.register(self._atexit)</span>

    <span class="s2">def </span><span class="s1">_init_data(self, suffix):</span>
        <span class="s0">&quot;&quot;&quot;Create a data file if we don't have one yet.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Create the data file.  We do this at construction time so that the</span>
            <span class="s0"># data file will be written into the directory where the process</span>
            <span class="s0"># started rather than wherever the process eventually chdir'd to.</span>
            <span class="s1">ensure_dir_for_file(self.config.data_file)</span>
            <span class="s1">self._data = CoverageData(</span>
                <span class="s1">basename=self.config.data_file,</span>
                <span class="s1">suffix=suffix,</span>
                <span class="s1">warn=self._warn,</span>
                <span class="s1">debug=self._debug,</span>
                <span class="s1">no_disk=self._no_disk,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">start(self):</span>
        <span class="s0">&quot;&quot;&quot;Start measuring code coverage. 
 
        Coverage measurement only occurs in functions called after 
        :meth:`start` is invoked.  Statements in the same scope as 
        :meth:`start` won't be measured. 
 
        Once you invoke :meth:`start`, you must also call :meth:`stop` 
        eventually, or your process might not shut down cleanly. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s2">if not </span><span class="s1">self._inited_for_start:</span>
            <span class="s1">self._inited_for_start = </span><span class="s2">True</span>
            <span class="s1">self._init_for_start()</span>
        <span class="s1">self._post_init()</span>

        <span class="s0"># Issue warnings for possible problems.</span>
        <span class="s1">self._inorout.warn_conflicting_settings()</span>

        <span class="s0"># See if we think some code that would eventually be measured has</span>
        <span class="s0"># already been imported.</span>
        <span class="s2">if </span><span class="s1">self._warn_preimported_source:</span>
            <span class="s1">self._inorout.warn_already_imported_files()</span>

        <span class="s2">if </span><span class="s1">self._auto_load:</span>
            <span class="s1">self.load()</span>

        <span class="s1">self._collector.start()</span>
        <span class="s1">self._started = </span><span class="s2">True</span>
        <span class="s1">self._instances.append(self)</span>

    <span class="s2">def </span><span class="s1">stop(self):</span>
        <span class="s0">&quot;&quot;&quot;Stop measuring code coverage.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._instances:</span>
            <span class="s2">if </span><span class="s1">self._instances[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">is </span><span class="s1">self:</span>
                <span class="s1">self._instances.pop()</span>
        <span class="s2">if </span><span class="s1">self._started:</span>
            <span class="s1">self._collector.stop()</span>
        <span class="s1">self._started = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_atexit(self):</span>
        <span class="s0">&quot;&quot;&quot;Clean up on process shutdown.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._debug.should(</span><span class="s3">&quot;process&quot;</span><span class="s1">):</span>
            <span class="s1">self._debug.write(</span><span class="s3">&quot;atexit: pid: {}, instance: {!r}&quot;</span><span class="s1">.format(os.getpid(), self))</span>
        <span class="s2">if </span><span class="s1">self._started:</span>
            <span class="s1">self.stop()</span>
        <span class="s2">if </span><span class="s1">self._auto_save:</span>
            <span class="s1">self.save()</span>

    <span class="s2">def </span><span class="s1">erase(self):</span>
        <span class="s0">&quot;&quot;&quot;Erase previously collected coverage data. 
 
        This removes the in-memory data collected in this session as well as 
        discarding the data file. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s1">self._post_init()</span>
        <span class="s2">if </span><span class="s1">self._collector:</span>
            <span class="s1">self._collector.reset()</span>
        <span class="s1">self._init_data(suffix=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self._data.erase(parallel=self.config.parallel)</span>
        <span class="s1">self._data = </span><span class="s2">None</span>
        <span class="s1">self._inited_for_start = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">switch_context(self, new_context):</span>
        <span class="s0">&quot;&quot;&quot;Switch to a new dynamic context. 
 
        `new_context` is a string to use as the :ref:`dynamic context 
        &lt;dynamic_contexts&gt;` label for collected data.  If a :ref:`static 
        context &lt;static_contexts&gt;` is in use, the static and dynamic context 
        labels will be joined together with a pipe character. 
 
        Coverage collection must be started already. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._started:                           </span><span class="s0"># pragma: part started</span>
            <span class="s2">raise </span><span class="s1">CoverageException(</span>
                <span class="s3">&quot;Cannot switch context, coverage is not started&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._collector.should_start_context:</span>
            <span class="s1">self._warn(</span><span class="s3">&quot;Conflicting dynamic contexts&quot;</span><span class="s1">, slug=</span><span class="s3">&quot;dynamic-conflict&quot;</span><span class="s1">, once=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">self._collector.switch_context(new_context)</span>

    <span class="s2">def </span><span class="s1">clear_exclude(self, which=</span><span class="s3">'exclude'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Clear the exclude list.&quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s1">setattr(self.config, which + </span><span class="s3">&quot;_list&quot;</span><span class="s1">, [])</span>
        <span class="s1">self._exclude_regex_stale()</span>

    <span class="s2">def </span><span class="s1">exclude(self, regex, which=</span><span class="s3">'exclude'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Exclude source lines from execution consideration. 
 
        A number of lists of regular expressions are maintained.  Each list 
        selects lines that are treated differently during reporting. 
 
        `which` determines which list is modified.  The &quot;exclude&quot; list selects 
        lines that are not considered executable at all.  The &quot;partial&quot; list 
        indicates lines with branches that are not taken. 
 
        `regex` is a regular expression.  The regex is added to the specified 
        list.  If any of the regexes in the list is found in a line, the line 
        is marked for special treatment during reporting. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s1">excl_list = getattr(self.config, which + </span><span class="s3">&quot;_list&quot;</span><span class="s1">)</span>
        <span class="s1">excl_list.append(regex)</span>
        <span class="s1">self._exclude_regex_stale()</span>

    <span class="s2">def </span><span class="s1">_exclude_regex_stale(self):</span>
        <span class="s0">&quot;&quot;&quot;Drop all the compiled exclusion regexes, a list was modified.&quot;&quot;&quot;</span>
        <span class="s1">self._exclude_re.clear()</span>

    <span class="s2">def </span><span class="s1">_exclude_regex(self, which):</span>
        <span class="s0">&quot;&quot;&quot;Return a compiled regex for the given exclusion list.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">which </span><span class="s2">not in </span><span class="s1">self._exclude_re:</span>
            <span class="s1">excl_list = getattr(self.config, which + </span><span class="s3">&quot;_list&quot;</span><span class="s1">)</span>
            <span class="s1">self._exclude_re[which] = join_regex(excl_list)</span>
        <span class="s2">return </span><span class="s1">self._exclude_re[which]</span>

    <span class="s2">def </span><span class="s1">get_exclude_list(self, which=</span><span class="s3">'exclude'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return a list of excluded regex patterns. 
 
        `which` indicates which list is desired.  See :meth:`exclude` for the 
        lists that are available, and their meaning. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s2">return </span><span class="s1">getattr(self.config, which + </span><span class="s3">&quot;_list&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">save(self):</span>
        <span class="s0">&quot;&quot;&quot;Save the collected coverage data to the data file.&quot;&quot;&quot;</span>
        <span class="s1">data = self.get_data()</span>
        <span class="s1">data.write()</span>

    <span class="s2">def </span><span class="s1">combine(self, data_paths=</span><span class="s2">None</span><span class="s1">, strict=</span><span class="s2">False</span><span class="s1">, keep=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Combine together a number of similarly-named coverage data files. 
 
        All coverage data files whose name starts with `data_file` (from the 
        coverage() constructor) will be read, and combined together into the 
        current measurements. 
 
        `data_paths` is a list of files or directories from which data should 
        be combined. If no list is passed, then the data files from the 
        directory indicated by the current data file (probably the current 
        directory) will be combined. 
 
        If `strict` is true, then it is an error to attempt to combine when 
        there are no data files to combine. 
 
        If `keep` is true, then original input data files won't be deleted. 
 
        .. versionadded:: 4.0 
            The `data_paths` parameter. 
 
        .. versionadded:: 4.3 
            The `strict` parameter. 
 
        .. versionadded: 5.5 
            The `keep` parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s1">self._init_data(suffix=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self._post_init()</span>
        <span class="s1">self.get_data()</span>

        <span class="s1">aliases = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.config.paths:</span>
            <span class="s1">aliases = PathAliases()</span>
            <span class="s2">for </span><span class="s1">paths </span><span class="s2">in </span><span class="s1">self.config.paths.values():</span>
                <span class="s1">result = paths[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">paths[</span><span class="s4">1</span><span class="s1">:]:</span>
                    <span class="s1">aliases.add(pattern, result)</span>

        <span class="s1">combine_parallel_data(</span>
            <span class="s1">self._data,</span>
            <span class="s1">aliases=aliases,</span>
            <span class="s1">data_paths=data_paths,</span>
            <span class="s1">strict=strict,</span>
            <span class="s1">keep=keep,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the collected data. 
 
        Also warn about various problems collecting data. 
 
        Returns a :class:`coverage.CoverageData`, the collected coverage data. 
 
        .. versionadded:: 4.0 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._init()</span>
        <span class="s1">self._init_data(suffix=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self._post_init()</span>

        <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">self._plugins:</span>
            <span class="s2">if not </span><span class="s1">plugin._coverage_enabled:</span>
                <span class="s1">self._collector.plugin_was_disabled(plugin)</span>

        <span class="s2">if </span><span class="s1">self._collector </span><span class="s2">and </span><span class="s1">self._collector.flush_data():</span>
            <span class="s1">self._post_save_work()</span>

        <span class="s2">return </span><span class="s1">self._data</span>

    <span class="s2">def </span><span class="s1">_post_save_work(self):</span>
        <span class="s0">&quot;&quot;&quot;After saving data, look for warnings, post-work, etc. 
 
        Warn about things that should have happened but didn't. 
        Look for unexecuted files. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># If there are still entries in the source_pkgs_unmatched list,</span>
        <span class="s0"># then we never encountered those packages.</span>
        <span class="s2">if </span><span class="s1">self._warn_unimported_source:</span>
            <span class="s1">self._inorout.warn_unimported_source()</span>

        <span class="s0"># Find out if we got any data.</span>
        <span class="s2">if not </span><span class="s1">self._data </span><span class="s2">and </span><span class="s1">self._warn_no_data:</span>
            <span class="s1">self._warn(</span><span class="s3">&quot;No data was collected.&quot;</span><span class="s1">, slug=</span><span class="s3">&quot;no-data-collected&quot;</span><span class="s1">)</span>

        <span class="s0"># Touch all the files that could have executed, so that we can</span>
        <span class="s0"># mark completely unexecuted files as 0% covered.</span>
        <span class="s2">if </span><span class="s1">self._data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">file_paths = collections.defaultdict(list)</span>
            <span class="s2">for </span><span class="s1">file_path, plugin_name </span><span class="s2">in </span><span class="s1">self._inorout.find_possibly_unexecuted_files():</span>
                <span class="s1">file_path = self._file_mapper(file_path)</span>
                <span class="s1">file_paths[plugin_name].append(file_path)</span>
            <span class="s2">for </span><span class="s1">plugin_name, paths </span><span class="s2">in </span><span class="s1">file_paths.items():</span>
                <span class="s1">self._data.touch_files(paths, plugin_name)</span>

        <span class="s2">if </span><span class="s1">self.config.note:</span>
            <span class="s1">self._warn(</span><span class="s3">&quot;The '[run] note' setting is no longer supported.&quot;</span><span class="s1">)</span>

    <span class="s0"># Backward compatibility with version 1.</span>
    <span class="s2">def </span><span class="s1">analysis(self, morf):</span>
        <span class="s0">&quot;&quot;&quot;Like `analysis2` but doesn't return excluded line numbers.&quot;&quot;&quot;</span>
        <span class="s1">f, s, _, m, mf = self.analysis2(morf)</span>
        <span class="s2">return </span><span class="s1">f, s, m, mf</span>

    <span class="s2">def </span><span class="s1">analysis2(self, morf):</span>
        <span class="s0">&quot;&quot;&quot;Analyze a module. 
 
        `morf` is a module or a file name.  It will be analyzed to determine 
        its coverage statistics.  The return value is a 5-tuple: 
 
        * The file name for the module. 
        * A list of line numbers of executable statements. 
        * A list of line numbers of excluded statements. 
        * A list of line numbers of statements not run (missing from 
          execution). 
        * A readable formatted string of the missing line numbers. 
 
        The analysis uses the source file itself and the current measured 
        coverage data. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">analysis = self._analyze(morf)</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">analysis.filename,</span>
            <span class="s1">sorted(analysis.statements),</span>
            <span class="s1">sorted(analysis.excluded),</span>
            <span class="s1">sorted(analysis.missing),</span>
            <span class="s1">analysis.missing_formatted(),</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_analyze(self, it):</span>
        <span class="s0">&quot;&quot;&quot;Analyze a single morf or code unit. 
 
        Returns an `Analysis` object. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># All reporting comes through here, so do reporting initialization.</span>
        <span class="s1">self._init()</span>
        <span class="s1">Numbers.set_precision(self.config.precision)</span>
        <span class="s1">self._post_init()</span>

        <span class="s1">data = self.get_data()</span>
        <span class="s2">if not </span><span class="s1">isinstance(it, FileReporter):</span>
            <span class="s1">it = self._get_file_reporter(it)</span>

        <span class="s2">return </span><span class="s1">Analysis(data, it, self._file_mapper)</span>

    <span class="s2">def </span><span class="s1">_get_file_reporter(self, morf):</span>
        <span class="s0">&quot;&quot;&quot;Get a FileReporter for a module or file name.&quot;&quot;&quot;</span>
        <span class="s1">plugin = </span><span class="s2">None</span>
        <span class="s1">file_reporter = </span><span class="s3">&quot;python&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(morf, string_class):</span>
            <span class="s1">mapped_morf = self._file_mapper(morf)</span>
            <span class="s1">plugin_name = self._data.file_tracer(mapped_morf)</span>
            <span class="s2">if </span><span class="s1">plugin_name:</span>
                <span class="s1">plugin = self._plugins.get(plugin_name)</span>

                <span class="s2">if </span><span class="s1">plugin:</span>
                    <span class="s1">file_reporter = plugin.file_reporter(mapped_morf)</span>
                    <span class="s2">if </span><span class="s1">file_reporter </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">CoverageException(</span>
                            <span class="s3">&quot;Plugin %r did not provide a file reporter for %r.&quot; </span><span class="s1">% (</span>
                                <span class="s1">plugin._coverage_plugin_name, morf</span>
                            <span class="s1">)</span>
                        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">file_reporter == </span><span class="s3">&quot;python&quot;</span><span class="s1">:</span>
            <span class="s1">file_reporter = PythonFileReporter(morf, self)</span>

        <span class="s2">return </span><span class="s1">file_reporter</span>

    <span class="s2">def </span><span class="s1">_get_file_reporters(self, morfs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of FileReporters for a list of modules or file names. 
 
        For each module or file name in `morfs`, find a FileReporter.  Return 
        the list of FileReporters. 
 
        If `morfs` is a single module or file name, this returns a list of one 
        FileReporter.  If `morfs` is empty or None, then the list of all files 
        measured is used to find the FileReporters. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">morfs:</span>
            <span class="s1">morfs = self._data.measured_files()</span>

        <span class="s0"># Be sure we have a collection.</span>
        <span class="s2">if not </span><span class="s1">isinstance(morfs, (list, tuple, set)):</span>
            <span class="s1">morfs = [morfs]</span>

        <span class="s1">file_reporters = [self._get_file_reporter(morf) </span><span class="s2">for </span><span class="s1">morf </span><span class="s2">in </span><span class="s1">morfs]</span>
        <span class="s2">return </span><span class="s1">file_reporters</span>

    <span class="s2">def </span><span class="s1">report(</span>
        <span class="s1">self, morfs=</span><span class="s2">None</span><span class="s1">, show_missing=</span><span class="s2">None</span><span class="s1">, ignore_errors=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">file=</span><span class="s2">None</span><span class="s1">, omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, skip_covered=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">contexts=</span><span class="s2">None</span><span class="s1">, skip_empty=</span><span class="s2">None</span><span class="s1">, precision=</span><span class="s2">None</span><span class="s1">, sort=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Write a textual summary report to `file`. 
 
        Each module in `morfs` is listed, with counts of statements, executed 
        statements, missing statements, and a list of lines missed. 
 
        If `show_missing` is true, then details of which lines or branches are 
        missing will be included in the report.  If `ignore_errors` is true, 
        then a failure while reporting a single file will not stop the entire 
        report. 
 
        `file` is a file-like object, suitable for writing. 
 
        `include` is a list of file name patterns.  Files that match will be 
        included in the report. Files matching `omit` will not be included in 
        the report. 
 
        If `skip_covered` is true, don't report on files with 100% coverage. 
 
        If `skip_empty` is true, don't report on empty files (those that have 
        no statements). 
 
        `contexts` is a list of regular expressions.  Only data from 
        :ref:`dynamic contexts &lt;dynamic_contexts&gt;` that match one of those 
        expressions (using :func:`re.search &lt;python:re.search&gt;`) will be 
        included in the report. 
 
        `precision` is the number of digits to display after the decimal 
        point for percentages. 
 
        All of the arguments default to the settings read from the 
        :ref:`configuration file &lt;config&gt;`. 
 
        Returns a float, the total percentage covered. 
 
        .. versionadded:: 4.0 
            The `skip_covered` parameter. 
 
        .. versionadded:: 5.0 
            The `contexts` and `skip_empty` parameters. 
 
        .. versionadded:: 5.2 
            The `precision` parameter. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">override_config(</span>
            <span class="s1">self,</span>
            <span class="s1">ignore_errors=ignore_errors, report_omit=omit, report_include=include,</span>
            <span class="s1">show_missing=show_missing, skip_covered=skip_covered,</span>
            <span class="s1">report_contexts=contexts, skip_empty=skip_empty, precision=precision,</span>
            <span class="s1">sort=sort</span>
        <span class="s1">):</span>
            <span class="s1">reporter = SummaryReporter(self)</span>
            <span class="s2">return </span><span class="s1">reporter.report(morfs, outfile=file)</span>

    <span class="s2">def </span><span class="s1">annotate(</span>
        <span class="s1">self, morfs=</span><span class="s2">None</span><span class="s1">, directory=</span><span class="s2">None</span><span class="s1">, ignore_errors=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, contexts=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Annotate a list of modules. 
 
        Each module in `morfs` is annotated.  The source is written to a new 
        file, named with a &quot;,cover&quot; suffix, with each line prefixed with a 
        marker to indicate the coverage of the line.  Covered lines have &quot;&gt;&quot;, 
        excluded lines have &quot;-&quot;, and missing lines have &quot;!&quot;. 
 
        See :meth:`report` for other arguments. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">override_config(self,</span>
            <span class="s1">ignore_errors=ignore_errors, report_omit=omit,</span>
            <span class="s1">report_include=include, report_contexts=contexts,</span>
        <span class="s1">):</span>
            <span class="s1">reporter = AnnotateReporter(self)</span>
            <span class="s1">reporter.report(morfs, directory=directory)</span>

    <span class="s2">def </span><span class="s1">html_report(</span>
        <span class="s1">self, morfs=</span><span class="s2">None</span><span class="s1">, directory=</span><span class="s2">None</span><span class="s1">, ignore_errors=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, extra_css=</span><span class="s2">None</span><span class="s1">, title=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">skip_covered=</span><span class="s2">None</span><span class="s1">, show_contexts=</span><span class="s2">None</span><span class="s1">, contexts=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">skip_empty=</span><span class="s2">None</span><span class="s1">, precision=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate an HTML report. 
 
        The HTML is written to `directory`.  The file &quot;index.html&quot; is the 
        overview starting point, with links to more detailed pages for 
        individual modules. 
 
        `extra_css` is a path to a file of other CSS to apply on the page. 
        It will be copied into the HTML directory. 
 
        `title` is a text string (not HTML) to use as the title of the HTML 
        report. 
 
        See :meth:`report` for other arguments. 
 
        Returns a float, the total percentage covered. 
 
        .. note:: 
            The HTML report files are generated incrementally based on the 
            source files and coverage results. If you modify the report files, 
            the changes will not be considered.  You should be careful about 
            changing the files in the report folder. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">override_config(self,</span>
            <span class="s1">ignore_errors=ignore_errors, report_omit=omit, report_include=include,</span>
            <span class="s1">html_dir=directory, extra_css=extra_css, html_title=title,</span>
            <span class="s1">html_skip_covered=skip_covered, show_contexts=show_contexts, report_contexts=contexts,</span>
            <span class="s1">html_skip_empty=skip_empty, precision=precision,</span>
        <span class="s1">):</span>
            <span class="s1">reporter = HtmlReporter(self)</span>
            <span class="s2">return </span><span class="s1">reporter.report(morfs)</span>

    <span class="s2">def </span><span class="s1">xml_report(</span>
        <span class="s1">self, morfs=</span><span class="s2">None</span><span class="s1">, outfile=</span><span class="s2">None</span><span class="s1">, ignore_errors=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, contexts=</span><span class="s2">None</span><span class="s1">, skip_empty=</span><span class="s2">None</span><span class="s1">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate an XML report of coverage results. 
 
        The report is compatible with Cobertura reports. 
 
        Each module in `morfs` is included in the report.  `outfile` is the 
        path to write the file to, &quot;-&quot; will write to stdout. 
 
        See :meth:`report` for other arguments. 
 
        Returns a float, the total percentage covered. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">override_config(self,</span>
            <span class="s1">ignore_errors=ignore_errors, report_omit=omit, report_include=include,</span>
            <span class="s1">xml_output=outfile, report_contexts=contexts, skip_empty=skip_empty,</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">render_report(self.config.xml_output, XmlReporter(self), morfs)</span>

    <span class="s2">def </span><span class="s1">json_report(</span>
        <span class="s1">self, morfs=</span><span class="s2">None</span><span class="s1">, outfile=</span><span class="s2">None</span><span class="s1">, ignore_errors=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">omit=</span><span class="s2">None</span><span class="s1">, include=</span><span class="s2">None</span><span class="s1">, contexts=</span><span class="s2">None</span><span class="s1">, pretty_print=</span><span class="s2">None</span><span class="s1">,</span>
        <span class="s1">show_contexts=</span><span class="s2">None</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate a JSON report of coverage results. 
 
        Each module in `morfs` is included in the report.  `outfile` is the 
        path to write the file to, &quot;-&quot; will write to stdout. 
 
        See :meth:`report` for other arguments. 
 
        Returns a float, the total percentage covered. 
 
        .. versionadded:: 5.0 
 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">override_config(self,</span>
            <span class="s1">ignore_errors=ignore_errors, report_omit=omit, report_include=include,</span>
            <span class="s1">json_output=outfile, report_contexts=contexts, json_pretty_print=pretty_print,</span>
            <span class="s1">json_show_contexts=show_contexts</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">render_report(self.config.json_output, JsonReporter(self), morfs)</span>

    <span class="s2">def </span><span class="s1">sys_info(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a list of (key, value) pairs showing internal information.&quot;&quot;&quot;</span>

        <span class="s2">import </span><span class="s1">coverage </span><span class="s2">as </span><span class="s1">covmod</span>

        <span class="s1">self._init()</span>
        <span class="s1">self._post_init()</span>

        <span class="s2">def </span><span class="s1">plugin_info(plugins):</span>
            <span class="s0">&quot;&quot;&quot;Make an entry for the sys_info from a list of plug-ins.&quot;&quot;&quot;</span>
            <span class="s1">entries = []</span>
            <span class="s2">for </span><span class="s1">plugin </span><span class="s2">in </span><span class="s1">plugins:</span>
                <span class="s1">entry = plugin._coverage_plugin_name</span>
                <span class="s2">if not </span><span class="s1">plugin._coverage_enabled:</span>
                    <span class="s1">entry += </span><span class="s3">&quot; (disabled)&quot;</span>
                <span class="s1">entries.append(entry)</span>
            <span class="s2">return </span><span class="s1">entries</span>

        <span class="s1">info = [</span>
            <span class="s1">(</span><span class="s3">'version'</span><span class="s1">, covmod.__version__),</span>
            <span class="s1">(</span><span class="s3">'coverage'</span><span class="s1">, covmod.__file__),</span>
            <span class="s1">(</span><span class="s3">'tracer'</span><span class="s1">, self._collector.tracer_name() </span><span class="s2">if </span><span class="s1">self._collector </span><span class="s2">else </span><span class="s3">&quot;-none-&quot;</span><span class="s1">),</span>
            <span class="s1">(</span><span class="s3">'CTracer'</span><span class="s1">, </span><span class="s3">'available' </span><span class="s2">if </span><span class="s1">CTracer </span><span class="s2">else </span><span class="s3">&quot;unavailable&quot;</span><span class="s1">),</span>
            <span class="s1">(</span><span class="s3">'plugins.file_tracers'</span><span class="s1">, plugin_info(self._plugins.file_tracers)),</span>
            <span class="s1">(</span><span class="s3">'plugins.configurers'</span><span class="s1">, plugin_info(self._plugins.configurers)),</span>
            <span class="s1">(</span><span class="s3">'plugins.context_switchers'</span><span class="s1">, plugin_info(self._plugins.context_switchers)),</span>
            <span class="s1">(</span><span class="s3">'configs_attempted'</span><span class="s1">, self.config.attempted_config_files),</span>
            <span class="s1">(</span><span class="s3">'configs_read'</span><span class="s1">, self.config.config_files_read),</span>
            <span class="s1">(</span><span class="s3">'config_file'</span><span class="s1">, self.config.config_file),</span>
            <span class="s1">(</span><span class="s3">'config_contents'</span><span class="s1">,</span>
                <span class="s1">repr(self.config._config_contents)</span>
                <span class="s2">if </span><span class="s1">self.config._config_contents</span>
                <span class="s2">else </span><span class="s3">'-none-'</span>
            <span class="s1">),</span>
            <span class="s1">(</span><span class="s3">'data_file'</span><span class="s1">, self._data.data_filename() </span><span class="s2">if </span><span class="s1">self._data </span><span class="s2">is not None else </span><span class="s3">&quot;-none-&quot;</span><span class="s1">),</span>
            <span class="s1">(</span><span class="s3">'python'</span><span class="s1">, sys.version.replace(</span><span class="s3">'</span><span class="s5">\n</span><span class="s3">'</span><span class="s1">, </span><span class="s3">''</span><span class="s1">)),</span>
            <span class="s1">(</span><span class="s3">'platform'</span><span class="s1">, platform.platform()),</span>
            <span class="s1">(</span><span class="s3">'implementation'</span><span class="s1">, platform.python_implementation()),</span>
            <span class="s1">(</span><span class="s3">'executable'</span><span class="s1">, sys.executable),</span>
            <span class="s1">(</span><span class="s3">'def_encoding'</span><span class="s1">, sys.getdefaultencoding()),</span>
            <span class="s1">(</span><span class="s3">'fs_encoding'</span><span class="s1">, sys.getfilesystemencoding()),</span>
            <span class="s1">(</span><span class="s3">'pid'</span><span class="s1">, os.getpid()),</span>
            <span class="s1">(</span><span class="s3">'cwd'</span><span class="s1">, os.getcwd()),</span>
            <span class="s1">(</span><span class="s3">'path'</span><span class="s1">, sys.path),</span>
            <span class="s1">(</span><span class="s3">'environment'</span><span class="s1">, sorted(</span>
                <span class="s1">(</span><span class="s3">&quot;%s = %s&quot; </span><span class="s1">% (k, v))</span>
                <span class="s2">for </span><span class="s1">k, v </span><span class="s2">in </span><span class="s1">iitems(os.environ)</span>
                <span class="s2">if </span><span class="s1">any(slug </span><span class="s2">in </span><span class="s1">k </span><span class="s2">for </span><span class="s1">slug </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;COV&quot;</span><span class="s1">, </span><span class="s3">&quot;PY&quot;</span><span class="s1">))</span>
            <span class="s1">)),</span>
            <span class="s1">(</span><span class="s3">'command_line'</span><span class="s1">, </span><span class="s3">&quot; &quot;</span><span class="s1">.join(getattr(sys, </span><span class="s3">'argv'</span><span class="s1">, [</span><span class="s3">'-none-'</span><span class="s1">]))),</span>
            <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self._inorout:</span>
            <span class="s1">info.extend(self._inorout.sys_info())</span>

        <span class="s1">info.extend(CoverageData.sys_info())</span>

        <span class="s2">return </span><span class="s1">info</span>


<span class="s0"># Mega debugging...</span>
<span class="s0"># $set_env.py: COVERAGE_DEBUG_CALLS - Lots and lots of output about calls to Coverage.</span>
<span class="s2">if </span><span class="s1">int(os.environ.get(</span><span class="s3">&quot;COVERAGE_DEBUG_CALLS&quot;</span><span class="s1">, </span><span class="s4">0</span><span class="s1">)):              </span><span class="s0"># pragma: debugging</span>
    <span class="s2">from </span><span class="s1">coverage.debug </span><span class="s2">import </span><span class="s1">decorate_methods, show_calls</span>

    <span class="s1">Coverage = decorate_methods(show_calls(show_args=</span><span class="s2">True</span><span class="s1">), butnot=[</span><span class="s3">'get_data'</span><span class="s1">])(Coverage)</span>


<span class="s2">def </span><span class="s1">process_startup():</span>
    <span class="s0">&quot;&quot;&quot;Call this at Python start-up to perhaps measure coverage. 
 
    If the environment variable COVERAGE_PROCESS_START is defined, coverage 
    measurement is started.  The value of the variable is the config file 
    to use. 
 
    There are two ways to configure your Python installation to invoke this 
    function when Python starts: 
 
    #. Create or append to sitecustomize.py to add these lines:: 
 
        import coverage 
        coverage.process_startup() 
 
    #. Create a .pth file in your Python installation containing:: 
 
        import coverage; coverage.process_startup() 
 
    Returns the :class:`Coverage` instance that was started, or None if it was 
    not started by this call. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">cps = os.environ.get(</span><span class="s3">&quot;COVERAGE_PROCESS_START&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">cps:</span>
        <span class="s0"># No request for coverage, nothing to do.</span>
        <span class="s2">return None</span>

    <span class="s0"># This function can be called more than once in a process. This happens</span>
    <span class="s0"># because some virtualenv configurations make the same directory visible</span>
    <span class="s0"># twice in sys.path.  This means that the .pth file will be found twice,</span>
    <span class="s0"># and executed twice, executing this function twice.  We set a global</span>
    <span class="s0"># flag (an attribute on this function) to indicate that coverage.py has</span>
    <span class="s0"># already been started, so we can avoid doing it twice.</span>
    <span class="s0">#</span>
    <span class="s0"># https://github.com/nedbat/coveragepy/issues/340 has more details.</span>

    <span class="s2">if </span><span class="s1">hasattr(process_startup, </span><span class="s3">&quot;coverage&quot;</span><span class="s1">):</span>
        <span class="s0"># We've annotated this function before, so we must have already</span>
        <span class="s0"># started coverage.py in this process.  Nothing to do.</span>
        <span class="s2">return None</span>

    <span class="s1">cov = Coverage(config_file=cps)</span>
    <span class="s1">process_startup.coverage = cov</span>
    <span class="s1">cov._warn_no_data = </span><span class="s2">False</span>
    <span class="s1">cov._warn_unimported_source = </span><span class="s2">False</span>
    <span class="s1">cov._warn_preimported_source = </span><span class="s2">False</span>
    <span class="s1">cov._auto_save = </span><span class="s2">True</span>
    <span class="s1">cov.start()</span>

    <span class="s2">return </span><span class="s1">cov</span>


<span class="s2">def </span><span class="s1">_prevent_sub_process_measurement():</span>
    <span class="s0">&quot;&quot;&quot;Stop any subprocess auto-measurement from writing data.&quot;&quot;&quot;</span>
    <span class="s1">auto_created_coverage = getattr(process_startup, </span><span class="s3">&quot;coverage&quot;</span><span class="s1">, </span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">auto_created_coverage </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">auto_created_coverage._auto_save = </span><span class="s2">False</span>
</pre>
</body>
</html>